<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>面试题 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Vue 的生命周期 **总共分为 8 个阶段创建前&#x2F;后，载入前&#x2F;后，更新前&#x2F;后，销毁 前&#x2F;后。 ** 创建前&#x2F;后：在 beforeCreate 阶段，vue 实例的挂载元素$el 和数据对象 data 都为 undefifined，还未初始化。 在 created 阶段，vue 实例的数据对象 data 有了，$el 还没有。 载入前&#x2F;后">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题">
<meta property="og:url" content="http://example.com/2023/04/26/mianshiti/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Vue 的生命周期 **总共分为 8 个阶段创建前&#x2F;后，载入前&#x2F;后，更新前&#x2F;后，销毁 前&#x2F;后。 ** 创建前&#x2F;后：在 beforeCreate 阶段，vue 实例的挂载元素$el 和数据对象 data 都为 undefifined，还未初始化。 在 created 阶段，vue 实例的数据对象 data 有了，$el 还没有。 载入前&#x2F;后">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:\Users\%E5%B8%8C%E6%9C%9B%E4%BD%A0%E6%84%BF%E6%84%8F%E3%80%82\Desktop\QQ%E5%9B%BE%E7%89%8720201202153128.png">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a4a8b7b9ec247e6a73f24b4ea907110~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b4e8dfe2eae4ccba8a229fe526384bc~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-82a4441f6fab0bfbf737e731bf35e8f4_720w.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-c9c617c61dfe2f08012da96b35edad93_720w.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-0b250b0c928d1f206222cf3018a228de_720w.png">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-e22a10a23d17c29d0f0de8217656fde4_720w.png">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-be4e4cb3860783e2ac642bfd4ee50df1_720w.jpg">
<meta property="article:published_time" content="2023-04-26T01:52:02.375Z">
<meta property="article:modified_time" content="2023-04-26T01:53:58.412Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\%E5%B8%8C%E6%9C%9B%E4%BD%A0%E6%84%BF%E6%84%8F%E3%80%82\Desktop\QQ%E5%9B%BE%E7%89%8720201202153128.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-mianshiti" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/26/mianshiti/" class="article-date">
  <time class="dt-published" datetime="2023-04-26T01:52:02.375Z" itemprop="datePublished">2023-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      面试题
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Vue 的生命周期</p>
<p>**总共分为 8 个阶段创建前&#x2F;后，载入前&#x2F;后，更新前&#x2F;后，销毁 前&#x2F;后。 **</p>
<p><strong>创建前&#x2F;后</strong>：在 beforeCreate 阶段，vue 实例的挂载元素$el 和数据对象 data 都为 undefifined，还未初始化。</p>
<p>在 created 阶段，vue 实例的数据对象 data 有了，$el 还没有。</p>
<p><strong>载入前&#x2F;后</strong>：在 beforeMount 阶段，vue 实例的$el 和 data 都 初始化了，但还是挂载之前为虚拟的 dom 节点， data.message 还未替换。</p>
<p>在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。</p>
<p><strong>更新前&#x2F;后</strong>：当 data 变化时，会触发 beforeUpdate 和 updated 方法。</p>
<p><strong>销毁前&#x2F;后</strong>：beforeDestroy 在执行 destroyed 方法后，对 data 的改变不会再触发周期函数,说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定以及释放定时器，但是 dom 结构依然存在</p>
<h1 id="vue-组件之间如何传值通信"><a href="#vue-组件之间如何传值通信" class="headerlink" title="vue 组件之间如何传值通信"></a><strong>vue 组件之间如何传值通信</strong></h1><p><strong>父到子</strong>： 子组件在 props 中创建一个属性，用来接收父组件传过来 的值； 在父组件中注册子组件； 在子组件标签中添加子组件 props 中创建的属性,把需要传给子组件的值赋给该属性</p>
<p><strong>子到父</strong>： 子组件中需要以某种方式（如点击事件）的方法来触发一 个自定义的事件；将需要传的值作为$emit 的第二个参数，该值将作为实参传给响应事件的方法,在父组件中注册子组件并在子组件标签上绑定自定义事件的监听。</p>
<p><strong>平行组件</strong>： $emit推送，$on 接收,</p>
<h1 id="Vue2-x-组件通信有哪些方式"><a href="#Vue2-x-组件通信有哪些方式" class="headerlink" title="Vue2.x 组件通信有哪些方式"></a>Vue2.x 组件通信有哪些方式</h1><p><strong>父子组件通信</strong>: props 、$on、$emit、 Ref 获取实例的方式调用组件的属性或者方法、（Provide、inject 官方不推荐使用，但是写组件库时很常用）</p>
<p><strong>兄弟组件通信</strong>: EventBus 、Vuex</p>
<p>借助父组件，让两个兄弟组件可以联动，子组件 A 将值传递给父组件，父组件再将值传递给子组件 B;</p>
<p>1.子组件 A 传值给父组件通过$emit 将 e.target.innerText 传递给父组件;</p>
<p>2.父组件接收子组件 A 的传值，并将值保存到自己的 data 中，并取名 letter(letter:字母);</p>
<p>3.父组件将 letter 传递给子组件 B,子组件 B 通过 props 接收该值;</p>
<p>注意:子组件 B 监听到 letter 值的变化后作出反应：用 watch 对象来监听;</p>
<p>还可以用 bus 总线传值;</p>
<p><strong>跨级组件通信</strong>：Vuex、$attrs、$listeners、Provide,（Provide、inject 官方不推荐使用，但是写组件库时很用）</p>
<h1 id="created-和-mounted-的区别"><a href="#created-和-mounted-的区别" class="headerlink" title="created 和 mounted 的区别"></a>created 和 mounted 的区别</h1><p>.</p>
<p><strong>created</strong>：在模板渲染成 html 前调用，即通常初始化某些属性值，然后再渲染成视图。</p>
<p><strong>mounted</strong>：在模板渲染成 html 后调用，通常是初始化页面完成后，再对 html 的 dom 节点进行一些需要的操作</p>
<h1 id="vuex-的-state、getter、-mutation、action、module-特性分别是什么？"><a href="#vuex-的-state、getter、-mutation、action、module-特性分别是什么？" class="headerlink" title="vuex 的 state、getter、 mutation、action、module 特性分别是什么？"></a><strong>vuex 的 state、getter、 mutation、action、module 特性分别是什么</strong>？</h1><p><strong>State</strong>: 保存着所有的全局变量</p>
<p><strong>Getter</strong>: store 中的计算属性，就像计算属性一样，getter 的 返回值会根据它的依赖被缓存起来，且只有当它的依赖值发 生了改变才会被重新计算。 getters 接收 state 作为其第一个 参数，接受其他 getters 作为第二个参数，如不需要，第二 个参数可以省略。</p>
<p><strong>Mutation</strong>: 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation, mutation 必须是同步函数</p>
<p><strong>Action</strong>: Action 可以包含任意异步操作, 在组件中使用 this.$store.dispatch(‘xxx’) 分发 action</p>
<p><strong>Module</strong>: 可以写很多模块，Vuex 允许我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、 action、getters，最后都引入到一个文件。分散管理。</p>
<h1 id="为什么-mutation-里面只能同步不能异步？"><a href="#为什么-mutation-里面只能同步不能异步？" class="headerlink" title="为什么 mutation 里面只能同步不能异步？"></a>为什么 mutation 里面只能同步不能异步？</h1><p>方便追踪到 state 的变化，因为 state 里面的数据会改变异步的话组件有可能会收不到 ，不能实时追踪 严格模式会报错</p>
<h1 id="页面刷新后-vuex-的-state-数据丢失怎么解决"><a href="#页面刷新后-vuex-的-state-数据丢失怎么解决" class="headerlink" title="页面刷新后 vuex 的 state 数据丢失怎么解决?"></a>页面刷新后 vuex 的 state 数据丢失怎么解决?</h1><p>将 Vuex 里的数据同步更新到 localStorage 里。就是只要一改变 vuex 里的数据,便触发 localStorage.setItem 方法</p>
<h1 id="store-提供了哪些函数"><a href="#store-提供了哪些函数" class="headerlink" title="store 提供了哪些函数"></a>store 提供了哪些函数</h1><p>提供 getState( )方法获取 state；</p>
<p>提供 dispatch(action)方法更新 state；</p>
<p>通过 subscribe(listener)注册监听器；</p>
<p>通过 subscribe(listener)返回的函数注销监听器</p>
<p>使用 mapState 工具函数会将 store 中的 state 映射到局部计算 属性中 mapGetter，mapMutation，mapAction 会将 store 中各自 的方法映射过来</p>
<h1 id="vuex-是什么呢？哪些场景会用到？"><a href="#vuex-是什么呢？哪些场景会用到？" class="headerlink" title="vuex 是什么呢？哪些场景会用到？"></a><strong>vuex 是什么呢？哪些场景会用到？</strong></h1><p>vuex 是一个专为 vue.js 应用程序开发的状态管理模式 我们大概可以理解为 vuex 是一个公共 状态库 , 你可以在所有 的组件里面去使用,修改 场景有：单页应用中，组件之间的状态、音乐播放、登录状 态、加入购物车</p>
<p>vuex 为状态管理，它集中存储管理应用的所有组件的状态， 可以理解成一个全局仓库</p>
<p>VueRouter 是路由（spa）单页面应用的方式</p>
<h1 id="使用-vuex-的优势是什么？有用过-Vuex-么-它主要解决什么问题？"><a href="#使用-vuex-的优势是什么？有用过-Vuex-么-它主要解决什么问题？" class="headerlink" title="使用 vuex 的优势是什么？有用过 Vuex 么?它主要解决什么问题？"></a><strong>使用 vuex 的优势是什么？有用过 Vuex 么?它主要解决什么问题？</strong></h1><p><strong>Vuex 的优势：</strong></p>
<p>1.解决了非父子组件的消息传递（将数据存放在 state 中）</p>
<p>2.减少了 AJAX 请求次数，有些情景可以直接从内存中的 state 获取</p>
<p><strong>主要解决的问题是：</strong></p>
<p>用来管理全局的组件状态，比如有很多个组件都会修改同一 个数据，同时这个数据又要在多个组件上同时显示，这个时 候用 vuex 来统一管理这些组件的状态，会让逻辑更清晰，更方便维护</p>
<h1 id="vue-中路由的模式如何选择，不同模式有什么区别？"><a href="#vue-中路由的模式如何选择，不同模式有什么区别？" class="headerlink" title="vue 中路由的模式如何选择，不同模式有什么区别？"></a><strong>vue 中路由的模式如何选择，不同模式有什么区别？</strong></h1><p><strong>Hash 模式</strong><br>重点</p>
<hr>
<p><a target="_blank" rel="noopener" href="http://www.test.com/#/">www.test.com/#/</a> 就是 Hash URL，当 # 后面的哈希值发生变化时，可以通过 hashchange 事件来监听到 URL 的变化， 从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 URL 请求永远是 <a target="_blank" rel="noopener" href="http://www.test.com.hash模式相对来说更简单,并且兼容性也更好./">www.test.com。Hash模式相对来说更简单，并且兼容性也更好。</a></p>
<p><strong>History 模式</strong></p>
<p>History 模式是 HTML5 新推出的功能，主要使用 history.pushState 和 history.replaceState 改变 URL。 通过 History 模式改变 URL 同样不会引起页面的刷新，只会更新浏览器的历史记录。</p>
<p><strong>两种模式对比</strong></p>
<p><strong>Hash 模式</strong>只可以更改 # 后面的内容，History 模式可以通 过 API 设置任意的同源 URL</p>
<p><strong>History 模式</strong>可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串· Hash 模式无需后端配置，并且兼容性好。History 模式在 用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 index.html 页面用于匹配不到静态资源的时候</p>
<h1 id="route和-router-有什么区别，有什么关联关系"><a href="#route和-router-有什么区别，有什么关联关系" class="headerlink" title="$route和$router 有什么区别，有什么关联关系"></a>$route和$router 有什么区别，有什么关联关系</h1><p>**$router **为 VueRouter 实例，想要导航到不同 URL，则使用 $router.push 方法。</p>
<p><strong>$route</strong> 为当前 router 跳转对象里面可以获取 name 、 path 、 query 、 params 等。</p>
<h1 id="插槽-slot"><a href="#插槽-slot" class="headerlink" title="插槽 slot"></a><strong>插槽 slot</strong></h1><p>插槽（Slot）插槽用于决定将所携带的内容，插入到指定的某 个位置，从而使模板分块，具有模块化的特质和更大的重用 性，插槽就是 Vue 实现的一套内容分发的 API</p>
<p><strong>匿名插槽</strong> ：叫做默认插槽 就是没有名 name</p>
<p><strong>具名插槽</strong>：需要多个插槽时，可以利用元素的一个特殊的特性：name 来定义具名插槽</p>
<p><strong>作用域插槽</strong>：是父组件引用子组件中的数据，使用 slot-scope 进行数据的传递，子组件中将数据传递给父组件</p>
<h1 id="v-for-和-v-if-的优先级"><a href="#v-for-和-v-if-的优先级" class="headerlink" title="v-for 和 v-if 的优先级"></a>v-for 和 v-if 的优先级</h1><p>v-for 的优先级高于 v-if</p>
<h1 id="watch-的原理"><a href="#watch-的原理" class="headerlink" title="watch 的原理"></a>watch 的原理</h1><p>通过 watch 的方法，监听被改变的变量,然后再 watch 的那个 变量命名的函数中去对我们要修改的值进行重新的赋值，或 者是触发一次更新。 watch 的执行类似于 emit 与 on 这种触发方式，通过 vue 的 watch 实例监听值来自动触发一个函数的执行。</p>
<p>· watch 函数的参数中，第一个是改变之前的值，第二个是改变之后的值，这两个参数非常有用。</p>
<p>· 这里分别使用了三种定义函数（或 option）的方法。</p>
<p>· 如果要观察 data 下一个对象的属性，我们可以使用对象属性的方式， 注意： 一定要要引号。</p>
<p>· 如果改变了一个对象的属性，就必须使用 deep: true，否则检测不到变化。</p>
<h1 id="watch-和-computed-差异"><a href="#watch-和-computed-差异" class="headerlink" title="watch 和 computed 差异"></a>watch 和 computed 差异</h1><p><strong>watch</strong>是进行数据监听，然后进行相应的操作，执行方法等 conputed 和 methods 的合体使用，比较耗性能，与 vue 性能优化相背而驰，尽量减少使用！</p>
<p><strong>computed</strong>是数据改变进行 相应的数据变化，由老数据迸发新的数据（return 返回）， 会利用缓存机制对数据进行缓存 ，只有当依赖数据变化的 时候才会进行相应的变化</p>
<h1 id="Vue-中的-computed-是如何实现缓存的"><a href="#Vue-中的-computed-是如何实现缓存的" class="headerlink" title="Vue 中的 computed 是如何实现缓存的"></a>Vue 中的 computed 是如何实现缓存的</h1><p>计算属性<code>Watcher</code>会带有一个 <code>dirty</code> 的属性，在初始化取值完成后，会将求值结果缓存起来，并把 <code>dirty</code> 设置为 <code>false</code>。只要依赖属性不更新，<code>dirty</code> 永远为 <code>false</code>，重复取值也不会再去执行求值函数，而是直接返回缓存结果，从而实现缓存。相反，依赖属性更新会将“计算属性 <code>Watcher</code>”的 <code>dirty</code> 设置为 <code>true</code>，在页面渲染对计算属性取值时，再次触发求值函数更新计算属性。</p>
<h1 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h1><p>在下次 DOM 更新循环结束之后执行延迟回调， 在修改数据之后使用 $nextTick，则可以在回调中获取更新后 的 DOM。</p>
<h1 id="key"><a href="#key" class="headerlink" title="key"></a><strong>key</strong></h1><p><code>key</code> 是每个 <code>VNode</code> 的唯一标识，依靠 <code>key</code> 能够在 <code>diff</code> 算法执行时更快的找到对应的 <code>VNode</code>，提高 <code>diff</code> 速度。</p>
<p>key 具有唯一性，使用 key，它会基于 key 的变化重新排列元 素顺序，并且会移除 key 不存在的元素。 有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。</p>
<p>带 key 就不会使用就地复用了，在 sameNode 函数 a.key&#x3D;&#x3D;&#x3D;b.key 对比中可以避免就地复用的情况。</p>
<p>vue 中列表循环需加:key&#x3D;”唯一标识” 唯一标识可以是 item 里面 id index 等，因为 vue 组件高度复用增加 Key 可以标识组件的唯一性，为了更好地区别各个组件 key 的作用主要是为了高效的更新虚拟 DOM</p>
<p>可以这样简单地理解，没有 key 属性时，状态默认绑定的是位 置；有 key 属性时，状态会根据 key 的属性值绑定到了相应的 数组元素。</p>
<p>若用数组索引 index 为 key，当向数组中指定位置插入一个新元素后，对应着后面的虚拟 DOM 的 key 值全部更新了，这个时候还是会做不必要的更新，就像没有加 key 一样</p>
<p>key 的作用就是更新组件时判断两个节点是否相同。相同就复用，不相同就删除旧的创建新的。在渲染简单的无状态组件 时，如果不添加 key 组件默认都是就地复用，不会删除添加节点，只是改变列表项中的文本值，要知道节点操作是十分耗 费性能的。而添加了 key 之后，当对比内容不一致时，就会认为是两个节点，会先删除掉旧节点，然后添加新节点。</p>
<h1 id="vue-自定义指令"><a href="#vue-自定义指令" class="headerlink" title="vue 自定义指令"></a>vue 自定义指令</h1><p>注册自定义指令分为全局注册与局部注册两种</p>
<h1 id="vue-自定义插件"><a href="#vue-自定义插件" class="headerlink" title="vue 自定义插件"></a>vue 自定义插件</h1><p>1.创建组件构造器</p>
<p>2.使用 new 的方式，根据组件构造器，可以创建出一个组件对象</p>
<p>3.将组件对象,手动挂载到某一个元素上</p>
<p>4.通过 Vue 的原型注册一个方法</p>
<hr>
<p>重点</p>
<h1 id="vue-cli3-开发环境与生产环境的区分"><a href="#vue-cli3-开发环境与生产环境的区分" class="headerlink" title="vue-cli3 开发环境与生产环境的区分"></a>vue-cli3 开发环境与生产环境的区分</h1><p>在 vue-cli3 的项目中,</p>
<p>npm run serve 时会把 process.env.NODE_ENV 设置 为‘development’；</p>
<p>npm run build 时会把 process.env.NODE_ENV 设置 为‘production’；</p>
<p>那么，就可以直接根据不同环境配置 vue.config.js 了</p>
<h1 id="在-vue-里面你如何做数据的监听"><a href="#在-vue-里面你如何做数据的监听" class="headerlink" title="在 vue 里面你如何做数据的监听"></a>在 vue 里面你如何做数据的监听</h1><ol>
<li>watch 里面监听</li>
<li>可设置 deep 为 true 对数据进行深层遍历监听</li>
<li>computed 里面监听,computed 里面的依赖改变时，所计算的属性会作出实时的改变</li>
</ol>
<hr>
<p>重点</p>
<h1 id="关于单页应用首屏加载速度慢，出现白屏时间过长问题你怎么处理"><a href="#关于单页应用首屏加载速度慢，出现白屏时间过长问题你怎么处理" class="headerlink" title="关于单页应用首屏加载速度慢，出现白屏时间过长问题你怎么处理"></a><strong>关于单页应用首屏加载速度慢，出现白屏时间过长问题你怎么处理</strong></h1><p>1.将公用的 JS 库通过 script 标签在 index.html 进行外部引入,减少我们打包出来的 js 文件的大小，让浏览器并行下载资 源文件，提高下载速度</p>
<p>2.在配置路由的时候进行路由的懒加载，在调用到该路由时 再加载此路由相对应的 js 文件加一个首屏 loading 图或骨架屏，提高用户的体验</p>
<p>3.尽可能使用 CSS Sprites 和字体图标库</p>
<p>4.图片的懒加载等</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>基本数据类型（按值访问）：Undefifined 、 Null 、 Boolean 、 Number 和 String</p>
<p>引用数据类型（按引用访问）：object、Array、function</p>
<p>两种类型的区别是：存储位置不同；</p>
<h1 id="let-var-const-的区别"><a href="#let-var-const-的区别" class="headerlink" title="let,var,const 的区别"></a><strong>let,var,const 的区别</strong></h1><p>1、var 定义的变量，没有块的概念，可以跨块访问, 不能跨函 数访问。</p>
<p>2、let 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。</p>
<p>3、let 的用法类似于 var,但是 let 只在所在的代码块内有效，所以我们一般使用 let 替代 var 。而 const 用来声明常量。</p>
<p>4、const 用来定义常量,使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。</p>
<p><img src="C:\Users\希望你愿意。\Desktop\QQ图片20201202153128.png"></p>
<h1 id="Vue2-x-响应式数据原理-数据劫持-数据双向绑定"><a href="#Vue2-x-响应式数据原理-数据劫持-数据双向绑定" class="headerlink" title="Vue2.x 响应式数据原理(数据劫持)数据双向绑定"></a>Vue2.x 响应式数据原理(数据劫持)数据双向绑定</h1><p><strong>Vue 在初始化数据时，会对 data 进行遍历，并使用 Object.defineProperty 把这些属性转为 getter&#x2F;setter。 每个组件实例都对应一个 watcher 实例，当页面使用对应属性 时，首先会用 getter 进行依赖收集(收集当前组件的 watcher) 如果属性发生变化 setter 触发时会通知相关依赖进行更新操作(发布订阅)。</strong></p>
<p>注意：</p>
<ol>
<li><p>Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p>
</li>
<li><p>由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。</p>
<h1 id="vue-的双向数据绑定实现的底层原理"><a href="#vue-的双向数据绑定实现的底层原理" class="headerlink" title="vue 的双向数据绑定实现的底层原理"></a>vue 的双向数据绑定实现的底层原理</h1><p>我们所说的数据双向绑定，一定是对于 UI 控件来说的，非 UI 控件不会涉及到双向绑定<br>Vue 是用数据劫持和发布订阅模式来实现双向数据绑定的，其中数据劫持是利用了 object.defineProprety 这个方法。他给数据对象中的每个属性添加了 set 和 get 的方法。所以在数据写入和读取的时候，都可以触发对应的自定义方法。</p>
<p>我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器 Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者 Watcher 看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器 Dep 来专门收集这些订阅者，然后在监听器 Observer 和订阅者 Watcher 之间进行统一管理的。接着，我们还需要有一个指令解析器 Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者 Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者 Watcher 接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。因此接下去我们执行以下 3 个步骤，实现数据的双向绑定：<hr> 1.实现一个监听器 Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。<hr> 2.实现一个订阅者 Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。<hr> 3.实现一个解析器 Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。</p>
</li>
</ol>
<h1 id="Vue3-x-响应式数据原理"><a href="#Vue3-x-响应式数据原理" class="headerlink" title="Vue3.x 响应式数据原理"></a>Vue3.x 响应式数据原理</h1><p>Vue3.x 改用<strong>Proxy</strong>替代 Object.defineProperty。因为 Proxy 可以直接监听对象和数组的变化，并且有多达 13 种拦截方法。</p>
<h1 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a><strong>导航守卫</strong></h1><p>vue-router 的导航钩子，主要用来作用是拦截导航，让他完成跳转或取消。</p>
<p>有三种方式可以植入路由导航过程中：</p>
<ol>
<li><p>**全局的 **</p>
</li>
<li><p>**单个路由独享的 **</p>
</li>
<li><p><strong>组件级的</strong></p>
</li>
</ol>
<p><strong>1.全局导航钩子</strong>： 全局导航钩子主要有两种钩子：前置守卫、后置钩子，注册一个全局前置守卫：<strong>beforeEach</strong></p>
<p>他有三个参数分别是 to 、from 、next 分别的作用：</p>
<p>1.<strong>to</strong>: 代表要进入的目标，它是一个路由对象 ，</p>
<p>2**.from**:代表当前正要离开的路由，同样也是一个路由对象</p>
<p>3.<strong>next</strong>,这是一个必须需要调用的方法，而具体的执行效果则依赖 next 方法调用的参数</p>
<p>1、next()：进入管道中的下一个钩子，如果全部的钩子执行完了，则导航的状态就是 confirmed（确认的）</p>
<p>2、next(false)：这代表中断掉当前的导航，即 to 代表的路由对象不会进入,被中断,此时该表 URL 地址会被重置到 from 路由对应的地址</p>
<p>3、next(‘&#x2F;’) 和 next({path: ‘&#x2F;’})：在中断掉当前导航的时，跳转到一个不同的地址</p>
<p>4、next(error)：如果传入参数是一个 Error 实例，那么导航被终止的同时会将错误传递给 router.onError() 注册过的回调</p>
<p><strong>全局后置钩子</strong>：<strong>afterEach</strong> 不同于前置守卫，后置钩子并没有 next 函数，也不会改变导航本身</p>
<p><strong>2.路由独享的钩子:beforeEnter</strong></p>
<p>顾名思义，即单个路由独享的导航钩子,它是在路由配置上直接进行定义的,至于他的参数的使,用和全局前置守卫是一样的</p>
<p><strong>3.组件内的导航钩子</strong></p>
<p>组件内的导航钩子主要有这三种：<strong>beforeRouteEnter、 beforeRouteUpdate、beforeRouteLeave</strong>。他们是直接在路由组件内部直接进行定义的</p>
<p>beforeRouteEnter 不能获取组件实例 this，因为当守卫执行前,组件实例被没有被创建出来，剩下两个钩子则可以正常获取组件实例 this 但是并不意味着在 beforeRouteEnter 中无法访问组件实例，我们可以通过给 next 传入一个回调来访问组件实例。在导航被确认是，会执行这个回调，这时就可以访问组件实例了,仅仅是 beforRouteEnter 支持给 next 传递回调,其他两个并不支持。因为归根结底，支持回调是为了解决 this 问题，而其他两个钩子的 this 可以正确访问到组件实例，所有没有必要使用回调</p>
<p>**完整的导航解析流程： **</p>
<p>导航被触发</p>
<p>在失活的组件里调用离开守卫</p>
<p>调用全局的 beforeEach 守卫</p>
<p>在重用的组件里调用 beforeRouteUpdate 守卫</p>
<p>在路由配置里调用 beforEnter</p>
<p>解析异步路由组件</p>
<p>在被激活的组件里调用 beforeRouteEnter</p>
<p>调用全局的 beforeResolve 守卫</p>
<p>导航被确认</p>
<p>调用全局的 afterEach 钩子</p>
<p>触发 DOM 更新</p>
<p>在创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数</p>
<h1 id="vue-常用的修饰符"><a href="#vue-常用的修饰符" class="headerlink" title="vue 常用的修饰符"></a>vue 常用的修饰符</h1><p><strong>prevent</strong>: 提交事件不再重载页面；</p>
<p><strong>stop</strong>: 阻止单击事件冒泡；</p>
<p><strong>self</strong>: 当事件发生在该元素本身而不是子元素的时候会触发；</p>
<p><strong>capture</strong>: 事件侦听，事件发生的时候会调用</p>
<h1 id="vue-项目整体框架解析"><a href="#vue-项目整体框架解析" class="headerlink" title="vue 项目整体框架解析"></a>vue 项目整体框架解析</h1><p><strong>各个文件夹</strong></p>
<ol>
<li><p><strong>node_modules</strong>：用来放很多很多的环境依赖。</p>
</li>
<li><p><strong>public</strong>：用来存放公共资源，其中的 index.html 文件， 就是初始的挂载点。被 App.vue 给取代了。</p>
</li>
<li><p><strong>src</strong>：放各种资源的</p>
</li>
<li><p><strong>assets</strong>：用来存放静态资源，比如图片之类的。</p>
</li>
<li><p><strong>components</strong>：放置各种小组件，相当于是子组件的子组件。</p>
</li>
<li><p><strong>router</strong>：路由，用来设置哪个 url 访问哪个页面组件。</p>
</li>
<li><p><strong>store</strong>：仓库。</p>
</li>
<li><p><strong>views</strong>：都是子组件，用来替换 App.vue 里面的 ,然后展示这个子组件，所以也叫页面组件，里面可以视图组件。</p>
</li>
</ol>
<p><strong>文件</strong></p>
<ol>
<li><p><strong>App.vue</strong>：子组件，用来取代 index.html 的挂载点的。</p>
</li>
<li><p><strong>main.js</strong>：入口文件</p>
</li>
</ol>
<h1 id="promise-的原理"><a href="#promise-的原理" class="headerlink" title="promise 的原理"></a><strong>promise 的原理</strong></h1><p>1、**主要用于异步计算 **</p>
<p>2、<strong>可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果</strong></p>
<p>3、<strong>可以在对象之间传递和操作 promise，帮助我们处理队列</strong></p>
<p><strong>原理</strong>:</p>
<p>1、**解决回调地狱:比如我们经常可能需要异步请求一个数据之后作为下一个异步操作的入参 **</p>
<p>2、<strong>promise 可以实现在多个请求发送完成后再得到或者处理某个结果</strong></p>
<p>基于上面的应用场景发现 promise 可以有三种状态，分别是<strong>pending 、Fulfilled、 Rejected。</strong></p>
<p>1.Pending Promise 对象实例创建时候的初始状态</p>
<p>2.Fulfilled 可以理解为成功的状态</p>
<p>3.Rejected 可以理解为失败的状态</p>
<p>构造一个 Promise 实例需要给 Promise 构造函数传入一个函数。传入的函数需要有两个形参，两个形参都是 function 类型的参数。分别是 resolve 和 reject。</p>
<p>Promise 上还有 then 方法，then 方法就是用来指定 Promise 对象的状态改变时确定执行的操作，resolve 时执行第一个函数（onFulfifilled），reject 时执行第二个函数（onRejected）</p>
<p>当状态变为 resolve 时便不能再变为 reject，反之同理。</p>
<h1 id="promise-的-API"><a href="#promise-的-API" class="headerlink" title="promise 的 API"></a><strong>promise 的 API</strong></h1><p>**Promise 是异步编程的一种解决方案，其实是一个构造函数，自己身上有 all、reject、resolve 这几个方法，原型上有 then、catch 等方法。 **</p>
<p>**Promise 的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。 **</p>
<p><strong>Promise</strong> <strong>的常用</strong> <strong>API</strong> <strong>如下：</strong></p>
<p>**Promise.resolve(value) : 类方法，该方法返回一个以 value 值解析后的 Promise 对象 **</p>
<p><strong>Promise.reject : 类方法，且与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected。</strong></p>
<p><strong>Promise.prototype.then : 实例方法，为 Promise 注册回调函数，函数形式：fn(vlaue){}，value 是上一个任务的返回结果，then 中的函数一定要 return 一个结果或者一 个新的 Promise 对象，才可以让之后的 then 回调接收。</strong></p>
<p><strong>Promise.prototype.catch : 实例方法，捕获异常，函数形式：fn(err){}, err 是 catch 注册 之前的回调抛出的异常信息。</strong></p>
<p><strong>Promise.race ：类方法，多个 Promise 任务同时执行，返回最先执行结束的 Promise 任务的结果，不管这个 Promise 结果是成功还是失败。</strong></p>
<p>**Promise.all : 类方法，多个 Promise 任务同时执行，如果全部成功执行，则以数组的方式返回所有 Promise 任务的执行结果。 如果有一个 Promise 任务 rejected，则只返 回 rejected 任务的结果。 **</p>
<h1 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a><strong>async&#x2F;await</strong></h1><p>它是可以理解为 promise 的语法糖,</p>
<p>async 用于申明一个 function 是异步的，</p>
<p>await 可以认为是 async wait 的简写，等待一个异步方法执行完成。</p>
<p>async&#x2F;await 使得异步代码看起来像同步代码，明显节约了不少代码，大大地提高可读性</p>
<p>async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完 成，并将其 resolve 的结果返回出来。</p>
<h1 id="es6-中-map-和-set-的区别"><a href="#es6-中-map-和-set-的区别" class="headerlink" title="es6 中 map 和 set 的区别"></a>es6 中 map 和 set 的区别</h1><p>Map 中存储的是 key-value 形式的键值对, 其中的 key 和 value 可以是任何类型的, 即对象也可以作为 key . 这比用对象来模拟的方式就灵活了很多</p>
<p><strong>Map 可用的方法</strong></p>
<p>set(key, value): 向其中加入一个键值对</p>
<p>get(key): 若不存在 key 则返回 undefifined</p>
<p>has(key):返回布尔值</p>
<p>delete(key): 删除成功则返回 true, 若 key 不存在或者删除失败会返回 false</p>
<p>clear(): 将全部元素清除</p>
<p><strong>set</strong></p>
<p>Set 和 Map 最大的区别是只有键 key 而没有 value, 所以一般用来判断某个元素(key)是否存在于其中.</p>
<h1 id="水平垂直居中的方法"><a href="#水平垂直居中的方法" class="headerlink" title="水平垂直居中的方法"></a><strong>水平垂直居中的方法</strong></h1><p>absolute + 负 margin</p>
<p>absolute + margin auto</p>
<p>absolute + calc</p>
<p>absolute + transform</p>
<p>lineheight</p>
<p>writing-mode</p>
<p>table</p>
<p>css-table</p>
<p>flex</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wp</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>grid</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wp</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: center;</span><br><span class="line">  justify-self: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a><strong>keep-alive</strong></h1><p>包含两个生命周期:</p>
<p>1.activated&#x3D;&#x3D;&gt;组件激活时调用;</p>
<p>2.deactivated&#x3D;&#x3D;&gt;组件停用时调用</p>
<p>三个属性:</p>
<p>1.include&#x3D;&#x3D;&gt;表示要缓存的组件名(即组件定义时的 name 属性)</p>
<p>2.exclude&#x3D;&#x3D;&gt;有着相反的作用，匹配到的组件不会被缓存。</p>
<p>3.maxage&#x3D;&#x3D;&gt;定义缓存组件上限，超出上限使用 LRU 的策略置换缓存数据。</p>
<h1 id="混合-mixin"><a href="#混合-mixin" class="headerlink" title="混合 mixin"></a>混合 mixin</h1><p>在 mixin 中值是对象的选项,比如:methods,computed,components 等,会合并,键名冲突的话会被覆盖,组件会覆盖混入对象中的属性;</p>
<p>在 mixin 中值是函数的选项,比如说 created,mounted 这些生命周期,混入对象的钩子函数,会先于组件内部的钩子函数调用;</p>
<p><strong>与 vuex 的区别</strong></p>
<p>1.vuex 做统一状态管理,里面定义的状态在每个组件中都可以随便的使用和修改在任一组件里面进行修改,其他组件都会随之更新;</p>
<p>2.mixins 可以进行定义共同的状态,引入到组件之后,各个变量之间是相互独立的,在组件中互不影响;</p>
<p><strong>与公共组件的区别</strong></p>
<p>公共组件:在父组件里面引入,注册,使用,通过 props 传递不同的值,父组件,公共组件,互相独立的;</p>
<p>混入对象:引入到组件里面进行使用的时候,会和当前组件进行融,相当于扩展了当前组件的选项方法,共同形成了一个新的组件;</p>
<p>当混入对象包含异步的时候:在混入对象里面不要直接返回结果,要返回异步函数,在组件里面去执行异步的回调;</p>
<h1 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h1><p>默认:this.<strong>$router.push</strong>();</p>
<p>字符串:this.$router.push(‘home’)</p>
<p>对象:this.$router.push({ path:’home’, query:{ aaa:’nihao’ } })</p>
<p>命名的路由:this.$router.push({  name:’user’,  params:{ userid:’123’ } }) this.$router.replace()</p>
<p>this.<strong>$router.go</strong>()&#x3D;&#x3D;&gt;go()可以接受一个整数,表示在 history 历史记录前进或后退多少;</p>
<h1 id="data-为什么是一个函数"><a href="#data-为什么是一个函数" class="headerlink" title="data 为什么是一个函数"></a>data 为什么是一个函数</h1><p>Vue 构造实例使用的是同一个构造函数，<code>data</code> 直接使用对象会导致实例的共享引用，即组件间的状态会相互影响。通常发生共享引用，都是组件复用的情况。使用函数返回一个对象，由于是不同引用，自然可以避免这个问题发生。</p>
<h1 id="vue-数据持久化"><a href="#vue-数据持久化" class="headerlink" title="vue 数据持久化"></a>vue 数据持久化</h1><p><strong>方法一：使用 localStorage 存储数据</strong></p>
<p>window.localStorage.setItem(key，value)</p>
<p><strong>方法二：使用 vuex-persistedstate 插件</strong></p>
<p>vuex 存在一个痛点，就是刷新以后 vuex 里面存储的 state 就会被浏览器释放掉（state 都是存储在内存中的）。</p>
<h1 id="对-MVVM-模式的理解"><a href="#对-MVVM-模式的理解" class="headerlink" title="对 MVVM 模式的理解"></a>对 MVVM 模式的理解</h1><p>MVVM 对应 3 个组成部分，Model（模型）、View（视图） 和 ViewModel（视图模型）。</p>
<ul>
<li>View 是用户在屏幕上看到的结构、布局和外观，也称 UI。</li>
<li>ViewModel 是一个绑定器，能和 View 层和 Model 层进行通信。</li>
<li>Model 是数据和逻辑。</li>
</ul>
<p>View 不能和 Model 直接通信，它们只能通过 ViewModel 通信。Model 和 ViewModel 之间的交互是双向的，ViewModel 通过双向数据绑定把 View 层和 Model 层连接起来，因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。</p>
<h1 id="Vue-的渲染流程"><a href="#Vue-的渲染流程" class="headerlink" title="Vue 的渲染流程"></a>Vue 的渲染流程</h1><p>流程主要分为三个部分：</p>
<ol>
<li><strong>模板编译</strong>，<code>parse</code> 解析模板生成抽象语法树（AST）；<code>optimize</code> 标记静态节点，在后续页面更新时会跳过静态节点；<code>generate</code> 将 AST 转成 <code>render</code> 函数，<code>render</code> 函数用于构建 <code>VNode</code>。</li>
<li><strong>构建 VNode（虚拟 dom）</strong>，构建过程使用 <code>createElement</code> 构建 <code>VNode</code>，<code>createElement</code> 也是自定义 <code>render</code> 函数时接受到的第一个参数。</li>
<li><strong>VNode 转真实 dom</strong>，<code>patch</code> 函数负责将 <code>VNode</code> 转换成真实 dom，核心方法是<code>createElm</code>，递归创建真实 dom 树，最终渲染到页面上。</li>
</ol>
<h1 id="vue-的指令"><a href="#vue-的指令" class="headerlink" title="vue 的指令"></a>vue 的指令</h1><ol>
<li><code>v-if</code></li>
<li><code>v-for</code></li>
<li><code>v-show</code></li>
<li><code>v-html</code></li>
<li><code>v-model</code></li>
</ol>
<p><strong>v-if 和 v-show 的区别</strong></p>
<p><code>v-if</code> 会让条件块内元素或组件适当地被销毁和重建。</p>
<p><code>v-show</code> 的元素或组件一开始就被渲染，只是简单的进行 css 切换。</p>
<p>相比之下，<code>v-if</code> 会带来更高的切换消耗，所以频繁切换使用 <code>v-show</code>，不常切换则使用 <code>v-if</code>。</p>
<p><strong>v-model</strong></p>
<p><code>v-model</code> 是属性 <code>value</code> 和 <code>input</code> 事件的语法糖。内部默认将 <code>value</code> 作为值，使用 <code>$emit</code> 触发 <code>input</code> 事件更新属性，从而实现双向绑定。而自定义双向绑定可以定义组件的 <code>model</code> 选项设置 <code>prop</code> 和 <code>event</code> 来实现。</p>
<h1 id="子组件为什么不能直接更改-props？什么是单向数据流？"><a href="#子组件为什么不能直接更改-props？什么是单向数据流？" class="headerlink" title="子组件为什么不能直接更改 props？什么是单向数据流？"></a>子组件为什么不能直接更改 props？什么是单向数据流？</h1><p>子组件不能更改 <code>props</code> 是因为要遵循单向数据流的原则。</p>
<p>单向数据流只允许数据由父组件传递给子组件，数据只能由父组件更新。当数据传递到多个子组件，而子组件能够在其内部更新数据时，在主观上很难知道是哪个子组件更新了数据，导致数据流向不明确，从而增加应用调试的难度。</p>
<p>但子组件更新父组件数据的场景确实存在，有 3 种方法可以使用：</p>
<ol>
<li><p>子组件 <code>emit</code>，父组件接受自定义事件。这种方法最终还是由父组件进行修改，子组件只是起到一个通知的作用。</p>
</li>
<li><p>子组件自定义双向绑定，设置组件的 <code>model</code> 选项为组件添加自定义双向绑定。</p>
</li>
<li><p><code>.sync</code> 属性修饰符，它是第一种方法的语法糖，在传递属性添加上该修饰符，子组件内可调用 <code>this.$emit(&#39;update:属性名&#39;, value)</code> 更新属性。</p>
<h1 id="数组的一些方法用法"><a href="#数组的一些方法用法" class="headerlink" title="数组的一些方法用法"></a>数组的一些方法用法</h1><p><strong>Concat</strong>() 连接两个或更多数组</p>
<p><strong>splice</strong>(index,len,[item]) 删除元素，并向数组添加一个新元素。</p>
<p><strong>Slice</strong>() 从某个已有的数组返回选定的元素</p>
<p><strong>Join</strong>() 把数组的所有元素放入一个字符串，元素通过指定的分隔符进行分割</p>
<p><strong>push</strong>() 在数组后添加元素，并返回新的长度</p>
<p><strong>unshift</strong>() 在数组最前添加元素</p>
<p><strong>pop</strong>() 删除数组最后一个元素并返回该元素的值</p>
<p><strong>reverse</strong>() 颠倒数组中元素的顺序</p>
<p><strong>shift</strong>() 删除并返回数组中第一个元素</p>
<p><strong>sort</strong>() 对数组元素进行排序</p>
<p><strong>toSource</strong>() 返回该对象的源代码</p>
<p><strong>toString</strong>() 把数组转换为字符串并返回结果</p>
<p><strong>toLocaleString</strong>() 把数组转换为本地数组，并返回结果</p>
<p><strong>valueOf</strong>() 返回对象的原始值</p>
</li>
</ol>
<h1 id="Vue-如何检测数组更新"><a href="#Vue-如何检测数组更新" class="headerlink" title="Vue 如何检测数组更新"></a>Vue 如何检测数组更新</h1><p><code>Vue</code> 内部重写数组原型链，当数组发生变化时，除了执行原生的数组方法外，还会调用 <code>dep.notify</code> 通知 <code>Watcher</code> 更新。触发数组更新的方法共 7 种：</p>
<ul>
<li><code>push</code></li>
<li><code>pop</code></li>
<li><code>shift</code></li>
<li><code>unshift</code></li>
<li><code>splice</code></li>
<li><code>sort</code></li>
<li><code>reverse</code></li>
</ul>
<h1 id="对比-Vue3-和-Vue2-x"><a href="#对比-Vue3-和-Vue2-x" class="headerlink" title="对比 Vue3 和 Vue2.x"></a>对比 Vue3 和 Vue2.x</h1><ol>
<li>使用 <code>Proxy</code> 代替 <code>Object.defineProperty</code></li>
<li>新增 <code>Composition API</code></li>
<li>模板允许多个根节点</li>
</ol>
<h1 id="Vue3-为什么使用-Proxy-代替-Object-definedProperty"><a href="#Vue3-为什么使用-Proxy-代替-Object-definedProperty" class="headerlink" title="Vue3 为什么使用 Proxy 代替 Object.definedProperty"></a>Vue3 为什么使用 Proxy 代替 Object.definedProperty</h1><p><code>Object.definedProperty</code> 只能检测到属性的获取和设置，对于新增和删除是没办法检测的。在数据初始化时，由于不知道哪些数据会被用到，<code>Vue</code> 是直接递归观测全部数据，这会导致性能多余的消耗。</p>
<p><code>Proxy</code> 劫持整个对象，对象属性的增加和删除都能检测到。<code>Proxy</code> 并不能监听到内部深层的对象变化，因此 Vue 3.0 的处理方式是在 <code>getter</code> 中去递归响应式，只有真正访问到的内部对象才会变成响应式，而不是无脑递归，在很大程度上提升了性能。</p>
<h1 id="路由懒加载是如何实现的"><a href="#路由懒加载是如何实现的" class="headerlink" title="路由懒加载是如何实现的"></a>路由懒加载是如何实现的</h1><p>路由懒加载是性能优化的一种手段，在编写代码时可以使用 <code>import()</code> 引入路由组件，使用懒加载的路由会在打包时单独出来成一个 js 文件，可以使用 <code>webpackChunkName</code> 自定义包名。在项目上线后，懒加载的 js 文件不会在第一时间加载，而是在访问到对应的路由时，才会动态创建 <code>script</code> 标签去加载这个 js 文件。</p>
<h1 id="vuex-怎么跨模块调用"><a href="#vuex-怎么跨模块调用" class="headerlink" title="vuex 怎么跨模块调用"></a>vuex 怎么跨模块调用</h1><p>跨模块调用是指当前命名空间模块调用全局模块或者另一个命名空间模块。在调用 <code>dispatch</code> 和 <code>commit</code> 时设置第三个参数为 <code>&#123;root：true&#125;</code>。</p>
<h1 id="JS-面试题"><a href="#JS-面试题" class="headerlink" title="JS 面试题"></a><strong>JS 面试题</strong></h1><h1 id="js-数据类型"><a href="#js-数据类型" class="headerlink" title="js 数据类型"></a>js 数据类型</h1><ul>
<li><p>基本数据类型：Boolean、Number、String、undefined、Null、Symbol (ES6 新增，表示独一无二的值)</p>
</li>
<li><p><strong>1.基本数据类型</strong>：<br><strong>Undefined</strong>:代表一切未知的事物，啥都没有，无法想象，代码也就更无法去处理了。 注意：typeof(Undefined) 返回也是 Undefined。可以将 Undefined 赋值给任何变量或属性，但并不意味了清除了该变量，反而会因此多了一个属性。</p>
<p><strong>Null</strong>:有那么一个概念，但没有东西。无中似有，有中还无。虽难以想象，但已经可以用代码来处理了。注意：typeof(Null)返回 Object，但 Null 并非 Object，具有 Null 值的变量也并非 object。</p>
<p><strong>Boolean</strong>:布尔类型，true or false，是就是，非就非，没有疑义。对就对，错就错，绝对明确。既能被代码处理，也可以控制代码的流程。</p>
<p><strong>Number</strong>:线性的事物，大小和次序分明，多而不乱。便于代码进行批量处理，也控制代码的迭代和循环等。</p>
<p><strong>注意：typeof(NaN)和 typeof(Infinity)都返回 number 。</strong></p>
<p>NaN 参与任何数值计算的结构都是 NaN，而且 NaN !&#x3D; NaN 。Infinity &#x2F; Infinity &#x3D; NaN 。</p>
<p><strong>String</strong>:字符串类型，面向人类的理性事物，而不是机器信号。人机信息沟通，代码据此理解人的意图等等，都靠它了。</p>
<p><strong>2.引用数据类型</strong>：<strong>Object、Array、Function</strong></p>
<p>判断数据类型的几种方法 1、typeof2、prototype3、instanceof4、constructor5、Object.prototype.toString.call(a)注意 ： typeof null &#x3D;&#x3D;&#x3D; Object</p>
</li>
<li><p>引用数据类型：Object、Array、Function</p>
</li>
</ul>
<h1 id="get-和-post-请求的区别"><a href="#get-和-post-请求的区别" class="headerlink" title="get 和 post 请求的区别"></a>get 和 post 请求的区别</h1><p>GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE</p>
<p><strong>get 和 post 请求的区别</strong></p>
<ul>
<li>get 一般用于获取数据</li>
<li>get 请求如果需要传递参数，那么会默认将参数拼接到 url 的后面；然后发送给服务器；</li>
<li>get 请求传递参数大小是有限制的；是浏览器的地址栏有大小限制；</li>
<li>get 安全性较低</li>
<li>get 一般会走缓存，为了防止走缓存，给 url 后面每次拼的参数不同；放在?后面，一般用个时间戳</li>
<li>post 一般用于发送数据</li>
<li>post 传递参数，需要把参数放进请求体中，发送给服务器；</li>
<li>post 请求参数放进了请求体中，对大小没有要求；</li>
<li>post 安全性比较高；</li>
<li>post 请求不会走缓存；</li>
<li><a target="_blank" rel="noopener" href="https://note.youdao.com/md/preview.html?file=/yws/api/personal/file/5CE015FFBB1447F09775F7D4456A34AE?method=download&read=true&shareKey=98f75a98417ef7f926f2562864f1c678#666">回到顶部</a></li>
</ul>
<h1 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h1><ul>
<li>HTTP 的 URL 由 http:&#x2F;&#x2F;起始且默认使用端口 80，而 HTTPS 的 URL 由 https:&#x2F;&#x2F;起始且默认使用端口 443</li>
<li>HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议</li>
<li>HTTP 的连接很简单，是无状态的，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全</li>
</ul>
<h1 id="在浏览器地址栏键入-URL，按下回车之后会经历以下流程"><a href="#在浏览器地址栏键入-URL，按下回车之后会经历以下流程" class="headerlink" title="在浏览器地址栏键入 URL，按下回车之后会经历以下流程"></a>在浏览器地址栏键入 URL，按下回车之后会经历以下流程</h1><ul>
<li>DNS 解析（浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址）</li>
<li>建立 TCP 连接 (三次握手）</li>
<li>发送请求，分析 url，设置请求报文(头，主体)</li>
<li>服务器返回请求的文件 (html)</li>
<li>释放 TCP 连接（四次挥手）</li>
<li>浏览器渲染 html 文本并显示内容</li>
</ul>
<h1 id="数据类型判断"><a href="#数据类型判断" class="headerlink" title="数据类型判断"></a>数据类型判断</h1><ul>
<li><p>typeof ：typeof 返回一个表示数据类型的字符串，返回结果包括：Number、Boolean、String、Symbol、Object、undefined、Function 等 7 种数据类型，但不能判断 Null、Array 等</p>
</li>
<li><p>instanceof ：instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性，但它不能检测 Null 和 undefined</p>
</li>
<li><p>Object.prototype.toString.call() ：是最准确最常用的方式。</p>
</li>
<li><p>4、constructor</p>
</li>
<li><p>2、prototype</p>
</li>
<li><p><strong>注意 ： typeof null &#x3D;&#x3D;&#x3D; Object</strong></p>
</li>
<li><p><strong>Object 对象</strong></p>
<p>JavaScript 中所有的对象都继承自 Object</p>
<p>constructor 属性是保存当前对象的构造函数，前面的例子中，constructor 保存的就是 Object 方法。</p>
<p>hasOwnProperty 方法接收一个字符串参数，该参数表示属性名称，用来判断该属性是否在当前对象实例中，而不是在对象的原型链中。</p>
<p>isPrototype 方法接收一个对象，用来判断当前对象是否在传入的参数对象的原型链上</p>
</li>
<li><p>NaN，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。</p>
<blockquote>
<p>NaN 不等于任何值，包括它本身。<br>NaN 与任何数（包括它自己）的运算，得到的都是 NaN。<br>NaN 在布尔运算时被当作 false。<br>判断是否是 NaN 的方法，isNaN(),isNaN 只对数值有效，如果传入其他值，会被转为数值</p>
</blockquote>
<h1 id="正无穷-Infinity-和负无穷-Infinity"><a href="#正无穷-Infinity-和负无穷-Infinity" class="headerlink" title="正无穷 Infinity 和负无穷-Infinity"></a>正无穷 Infinity 和负无穷-Infinity</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">1024</span>) <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">0</span> / <span class="number">0</span> <span class="comment">//Nan</span></span><br><span class="line"><span class="number">1</span> / <span class="number">0</span> <span class="comment">//Infinity</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Infinity 大于一切数值（除了 NaN），-Infinity 小于一切数值（除了 NaN）<br>Infinity 与 NaN 比较，总是返回 false。</p>
</blockquote>
</li>
</ul>
<h1 id="call-apply-bind-的区别"><a href="#call-apply-bind-的区别" class="headerlink" title="call, apply, bind 的区别"></a>call, apply, bind 的区别</h1><ul>
<li>相同点:主要功能都是用来改变 this 指向</li>
<li>不同点:call 和 apply 在改变函数 this 指向的同时调用了函数，bind 并没有调用函数，生成一个新的函数。同时 call 调用函数传参是逐个传参，apply 是以数组的形式进行传参</li>
<li><code>call</code>和<code>apply</code>更多的会用于做一些反柯里化的实现</li>
</ul>
<h1 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h1><p>被称为部分计算函数，也就是会固定一部分参数，然后返回一个接收剩余参数的函数。目的是为了缩小适用范围，创建一个针对性更强的函数。</p>
<p>一个柯里化函数的简单应用，我们有一个进行三个参数求和的函数。<br>我们可以调用<code>currying</code>传入<code>sum</code>获得<code>sum1</code>，一个固定了第一个参数为<code>10</code>的求和函数<br>然后我们又调用<code>currying</code>传入<code>sum1</code>获得<code>sum2</code>，在原有的固定了一个参数的基础上，再次固定一个参数<code>20</code></p>
<p>这时我们调用<code>sum2</code>时仅需传入一个参数即可完成三个参数的求和：<code>10 + 20 + n</code></p>
<p>使用柯里化还有一种好处，就是可以帮助我们明确调用函数的参数。</p>
<h1 id="反柯里化"><a href="#反柯里化" class="headerlink" title="反柯里化"></a>反柯里化</h1><p>正好与之相反，我们是要扩大一个函数的适用范围，比如将<code>Array</code>独有的<code>push</code>应用到一个<code>Object</code>上去。</p>
<p>虽说名字叫反柯里化。。但是我觉得也只是部分理念上相反，而不是向<code>Math.max</code>和<code>Math.min</code>，又或者<code>[].pop</code>和<code>[].push</code>这样的完全相反。<br>就像柯里化是缩小了适用范围，所以反柯里化所做的就是扩大适用范围。</p>
<h1 id="this-指向问题"><a href="#this-指向问题" class="headerlink" title="this 指向问题"></a>this 指向问题</h1><p><strong>this 解析</strong></p>
<p>this 是 javascript 中的关键字，在任何一个函数的作用域中都存在 this 对象。对 this 认识不清楚，代码实际执行时可能会报错或不符合预期 在函数被调用时，会创建一个执行上下文，这个上下文记录了函数的调用栈、被谁调用、所传参数等，也记录了 this。 也就是说，在函数调用时，发生了 this 绑定，函数执行时 this 到底指向哪里，取决于调用位置(通过调用栈可以查找)。调用栈可以通过调试工具很方便的找到。</p>
<ul>
<li><p>对于直接调用 函数 来说，不管函数被放在了什么地方，this 指向是 window</p>
</li>
<li><p>对于 obj.函数() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 函数中的 this 就是 obj 对象</p>
</li>
<li><p>在构造函数模式中，类中(函数体中)出现的 this.xxx&#x3D;xxx 中的 this 是当前类的一个实例</p>
</li>
<li><p>call、apply 和 bind：this 是第一个参数</p>
</li>
<li><p>箭头函数 this 指向:箭头函数没有自己的 this，看其外层的是否有函数，如果有，外层函数的 this 就是内部箭头函数的 this，如果没有，则 this 是 window。</p>
<h1 id="this-如何绑定"><a href="#this-如何绑定" class="headerlink" title="this 如何绑定"></a>this 如何绑定</h1><p>this 绑定到哪个对象，先要找到调用位置(调用栈)，看函数的调用方式。</p>
<p><strong>默认绑定</strong></p>
<p>如果是独立的函数调用，在函数被调用时会对 this 做默认绑定，即把 this 绑定到全局对象。</p>
<p><strong>对象绑定</strong></p>
<p>如果函数调用位置有上下文对象，会对 this 做对象绑定</p>
<p><strong>强制绑定</strong></p>
<p>对象绑定必须在一个对象内部包含一个指向函数的属性，通过这个属性间接引用函数，从而把 this 绑定到这个对象上。 如果不希望对象内部包含对函数的引用，可以使用强制绑定。 一般会使用 call、apply 和 bind 这三个函数做强制绑定。</p>
<p><strong>new 绑定</strong></p>
<p>ret 包括内置函数在内的所有函数，都可以被 new 操作符调用</p>
</li>
</ul>
<h1 id="原型-x2F-构造函数-x2F-实例"><a href="#原型-x2F-构造函数-x2F-实例" class="headerlink" title="原型 &#x2F; 构造函数 &#x2F; 实例"></a>原型 &#x2F; 构造函数 &#x2F; 实例</h1><ul>
<li>原型(prototype): 一个简单的对象，用于实现对象的属性继承。可以简单的理解成对象的爹。每个 JavaScript 对象中都包含一个–proto– (非标准)的属性指向它爹(该对象的原型)，可 obj.–proto–进行访问。</li>
<li>构造函数: 本质上是一个普通的函数，只是可以通过 new 来 新建一个对象的函数。</li>
<li>实例: 通过构造函数和 new 创建出来的对象，便是实例。 实例通过<strong>proto</strong>指向原型，通过 constructor 指向构造函数。</li>
</ul>
<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>属性查找机制: 当查找对象的属性时，如果实例对象本身不存在该属性，则沿着–proto–往自身的原型上查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象 Object.prototype，如还是没找到，js 规定 Object.prototype.–proto 指向 null，查找结束</p>
<p>对象： 1 、 函数对象： 由 function 创造出来的函数，比如 function a(){ } ; 系统内置的函数对象： Function , Object , Array , String , Number</p>
<p>2、 普通对象： 除开函数对象之外的对象，都是普通对象</p>
<p>每个普通对象的<strong>proto</strong>属性，都指向 Object（）.prototype ，</p>
<p>var obj &#x3D; { } 就等于 var obj &#x3D; new Object ( ) ; 即普通对象是 构造函数( Object ) 的一个实例</p>
<p>所以 obj. <strong>proto</strong> &#x3D;&#x3D;&#x3D; Object.prototype ( 但是老高说的，Object 的原型还是 object 对象, )</p>
<p>obj. constructor &#x3D;&#x3D;&#x3D; Object</p>
<p>凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。</p>
<p>注：所有对象都有 <strong>proto</strong> 属性只有函数对象才有 prototype 属性 ！！！！！！！！！！！</p>
<p>原型对象： prototype 属性也叫原型对象，主要是为了实现继承；</p>
<p>指针 <strong>proto</strong> : js 中，万物皆对象！所有的对象 obj 都具有 proto 属性（null 和 undefined 除外 )，而且指向创造 obj 对象的函数对象（生成实例的构造函数）的 prototype 属性 。</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><ul>
<li><p>闭包是指有权访问另一个函数作用域中的变量的函数</p>
</li>
<li><p>作用：1.使用闭包可以访问函数中的变量。2.可以使变量长期保存在内存中，生命周期比较长。</p>
</li>
<li><p>缺点：闭包不能滥用，否则会导致内存泄露，影响网页的性能。</p>
</li>
<li><p>应用场景：1.函数作为参数传递。2.函数作为返回值</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">        var n = 123;</span><br><span class="line">        function f2()&#123;    //f2是一个闭包</span><br><span class="line">            alert(n)</span><br><span class="line">        &#125;</span><br><span class="line">        return f2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//原生的setTimeout传递的第一个函数不能带参数</span><br><span class="line">    setTimeout(function(param)&#123;</span><br><span class="line">        alert(param)</span><br><span class="line">    &#125;,1000)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //通过闭包可以实现传参效果</span><br><span class="line">    function func(param)&#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            alert(param)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var f1 = func(1);</span><br><span class="line">    setTimeout(f1,1000);</span><br></pre></td></tr></table></figure>

<h1 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h1><p>浅拷贝和深拷贝只是针对于引用数据类型而言</p>
<p>浅拷贝：</p>
<p>概念：浅拷贝只是复制指向某个对象的指针，而不复制对象本身，新旧对象其实还是同一个对象。修改时原对象也会受到影响。</p>
<p>方法：</p>
<ul>
<li>利用 &#x3D; 赋值操作符实现浅拷贝。</li>
<li>使用 slice、concat 是数组的浅拷贝。</li>
<li>对象浅拷贝 - Object.assign()。</li>
<li>对象浅拷贝 - 扩展运算符</li>
</ul>
<p>深拷贝：</p>
<p>概念：深拷贝就是在拷贝数据的时候，将数据的所有引用结构都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又相互独立的数据，将引用型类型进行复制，而不是只复制其引用关系。修改时原对象不再受到任何影响。</p>
<p>方法：</p>
<ul>
<li><p>利用 JSON 对象中的 parse 和 stringify—如果对象某个属性值是函数的话，这个函数的值不能被深拷贝</p>
</li>
<li><p>利用递归来实现每一层都重新创建对象并赋值。</p>
</li>
<li><p>lodash</p>
</li>
</ul>
<h1 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h1><p>防抖与节流函数是一种最常用的 高频触发<strong>优化方式</strong>，能对性能有较大的帮助。</p>
<ul>
<li>防抖 (debounce): 将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function debounce(fn, wait, immediate) &#123;</span><br><span class="line">    let timer = null</span><br><span class="line"></span><br><span class="line">    return function() &#123;</span><br><span class="line">        let args = arguments</span><br><span class="line">        let context = this</span><br><span class="line"></span><br><span class="line">        if (immediate &amp;&amp; !timer) &#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (timer) clearTimeout(timer)</span><br><span class="line">        timer = setTimeout(() =&gt; &#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>节流(throttle): 每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms 执行一次即可。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fn, wait, immediate) &#123;</span><br><span class="line">    let timer = null</span><br><span class="line">    let callNow = immediate</span><br><span class="line"></span><br><span class="line">    return function() &#123;</span><br><span class="line">        let context = this,</span><br><span class="line">            args = arguments</span><br><span class="line"></span><br><span class="line">        if (callNow) &#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">            callNow = false</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!timer) &#123;</span><br><span class="line">            timer = setTimeout(() =&gt; &#123;</span><br><span class="line">                fn.apply(context, args)</span><br><span class="line">                timer = null</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ES6-x2F-ES7-常用属性及方法"><a href="#ES6-x2F-ES7-常用属性及方法" class="headerlink" title="ES6&#x2F;ES7 常用属性及方法"></a>ES6&#x2F;ES7 常用属性及方法</h1><p>声明：</p>
<ul>
<li><p>let: 声明变量，块级作用域、不存在变量提升、暂时性死区、不允许重复声明</p>
</li>
<li><p>const: 声明常量，只读无法修改</p>
</li>
<li><p>解构赋值 —-数组，对象</p>
</li>
<li><p>–数组—-字符串–的拓展方法</p>
</li>
<li><p>箭头函数 —-没有自己的 this，不能当做构造函数，没有 arguments</p>
</li>
<li><p>class 类—-继承</p>
</li>
<li><p>模块化—-import export</p>
</li>
<li><p>rest —–解构剩余参数—-部分情况可取代 arguments</p>
</li>
<li><p>promise，async，await，迭代器—*号函数 Generator</p>
</li>
<li><p>proxy ——访问某一个数据的时候，创建一个代言人，先经过一定的拦截，再去达到对象—是 vue3 响应式原理的核心方法—–取代了 object.defineProperty,</p>
<p>—-它提供了丰富的拦截方法—13 种；—能够记住几种就更好了;</p>
<p>它还可以直接监控数组的变化；</p>
</li>
</ul>
<p><strong>Set 结构</strong></p>
<p>Set 是 ES6 给开发者带来的一种新的数据结构，你可以理解为值的集合。我们平时见到的数组 Array 也是一种数据结构，但是 Set 跟其他数据结构不同的地方就在于：它的值不会有重复项。</p>
<p><strong>基本用法</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、创建出一个Set结构</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line"><span class="comment">//打印结果：Set &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、创建含内容的Set结构</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line"><span class="comment">//打印结果：Set &#123;1, 2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、创建出一个Set结构</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"><span class="comment">//使用add方法添加成员</span></span><br><span class="line">s.<span class="title function_">add</span>(<span class="number">1</span>)</span><br><span class="line">s.<span class="title function_">add</span>(<span class="number">2</span>)</span><br><span class="line">s.<span class="title function_">add</span>(<span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line"><span class="comment">//打印结果：Set &#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>成员值唯一</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Set();</span><br><span class="line">    s.<span class="keyword">add</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="keyword">add</span>(<span class="number">1</span>);</span><br><span class="line">    console.log(s);</span><br><span class="line">    <span class="comment">//打印结果： Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>Set 的用途之一</strong></p>
<p>再也不用怕数组去重问题鸟</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标数组arr，要求去重</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>(arr)</span><br><span class="line"><span class="comment">//结果：Set &#123;1,2,3,4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newArr = <span class="title class_">Array</span>.<span class="title function_">from</span>(s)</span><br><span class="line"><span class="comment">//结果：[1,2,3,4],完成去重</span></span><br></pre></td></tr></table></figure>

<p><strong>WeakSet 结构</strong></p>
<p>Set 和 WeakSet 两者名字就很像，WeakSet 结构同样不会存储重复的值，不同的是，它的成员必须是对象类型的值。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个WeakSet对象</span></span><br><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>([&#123; <span class="attr">age</span>: <span class="number">18</span> &#125;])</span><br><span class="line"><span class="comment">//结果：WeakSet &#123;Object &#123;age: 18&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>初始化一个 WeakSet 对象，参数一个数组，数组的成员必须是对象类型的值{“age”:18}，否则就会报错。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个WeakSet对象</span></span><br><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment">//结果：报错</span></span><br></pre></td></tr></table></figure>

<p>以上的写法就会报错，因为数组的元素不是对象类型的，是数字 1,2。</p>
<p><strong>Symbol()方法</strong></p>
<p>表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
<p>Symbol 值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<h1 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a><strong>数组的方法</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">unshift() 　　　数组头部添加内容</span><br><span class="line"></span><br><span class="line">push() 　　　　　 数组尾部添加内容</span><br><span class="line"></span><br><span class="line">pop() 　　　　　  数组尾部删除内容</span><br><span class="line"></span><br><span class="line">shift() 　　　　　  数组头部删除内容</span><br><span class="line"></span><br><span class="line">sort()　　　　　   数组排序    a-b 升序 b-a 降序</span><br><span class="line"></span><br><span class="line">reverse()　　　　数组倒排序</span><br><span class="line"></span><br><span class="line">splice() 　　　　 修改数组</span><br><span class="line"></span><br><span class="line">slice() 　　　　　截取</span><br><span class="line"></span><br><span class="line">indexOf() 　　　  查找下标，找不到 返回-1。</span><br><span class="line"></span><br><span class="line">forEach（）      循环数组 三个参数（数组的每一项， 每一项的下标， 数组本身）</span><br><span class="line"></span><br><span class="line">map（） 　　　　映射数组：对数组的每一项进行操作，返回新的数组</span><br><span class="line"></span><br><span class="line">filter（） 　　　过滤数组，返回满足条件的数据，保存在新数组中</span><br><span class="line"></span><br><span class="line">Every  　　　　　判断数组每一项是否满足条件 全部满足返回真</span><br><span class="line"></span><br><span class="line">Some   　　　　  只要有一项满足条件就返回真</span><br><span class="line"></span><br><span class="line">Join   　　　　　 把数组用连接符连接成字符串</span><br><span class="line"></span><br><span class="line">Find  　　　　查找满足条件的元素 有就返回第一项 没有的话返undefined</span><br><span class="line"></span><br><span class="line">FindIndex 　　　 查找满足条件的下标</span><br><span class="line"></span><br><span class="line">Array.From  　　 把类数组转化为数组</span><br><span class="line"></span><br><span class="line">Array.of  　　   把参数转化为数组</span><br><span class="line"></span><br><span class="line">Fill    　　　　　填充 用一个元素替换数组的某一部分</span><br><span class="line"></span><br><span class="line">Copywithin 　　　用数组的某一部分替换数组的另外一部分</span><br><span class="line"></span><br><span class="line">keys() 　　　　　遍历键名。</span><br><span class="line"></span><br><span class="line">values() 　　　　遍历键值。</span><br><span class="line"></span><br><span class="line">includes() 　　　数组是否包含指定值。</span><br><span class="line"></span><br><span class="line">flat() 　　　　　多维数组转一维数组</span><br><span class="line"></span><br><span class="line">reduce()        遍历，处理上一项，下一项</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//扩展运算符(...)与rest参数的区别</span><br><span class="line">function add(...values)&#123;//...values rest参数</span><br><span class="line">    let sum = 0;</span><br><span class="line">    for(let val of values)&#123;</span><br><span class="line">        // console.log(val,&quot;val&quot;)</span><br><span class="line">        sum += val</span><br><span class="line">    &#125;</span><br><span class="line">    return sum</span><br><span class="line">&#125;</span><br><span class="line">console.log(add(1,2,3))</span><br><span class="line">let &#123;x,y,...z&#125; = &#123;x:1,y:2,a:3,b:4&#125; //... 扩展运算符</span><br><span class="line">//举例克隆数组：</span><br><span class="line">let arr1 = [1, 2];</span><br><span class="line">let arr2 = [...arr1];</span><br><span class="line">//举例合并数组：</span><br><span class="line">let arr1 = [&quot;a&quot;, &quot;b&quot;];</span><br><span class="line">let arr2 = [1, 2];</span><br><span class="line">let arr3 = [...arr1, ...arr2];</span><br><span class="line">//举例拼接数组：</span><br><span class="line">let arr = [&quot;a&quot;, &quot;b&quot;];</span><br><span class="line">let arr2 = [1, 2];</span><br><span class="line">arr.push(...arr2);</span><br></pre></td></tr></table></figure>

<p><strong>字符串的方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">match() 　　　　　　　匹配输入内容,返回内容</span><br><span class="line"></span><br><span class="line">search() 　　　　　　查找,输入内容,返回下标    -1   不能使用g</span><br><span class="line"></span><br><span class="line">indexOf() 　　　　　检索字符串(内容,下次开始找的位置)  -1</span><br><span class="line"></span><br><span class="line">lastindexOf() 　　　　　 倒序</span><br><span class="line"></span><br><span class="line">replace() 　　替换字符串 默认只能替换一个  i不区分大小写 g全局 m多行</span><br><span class="line"></span><br><span class="line">toUpperCase() 　　　　  转化为大写</span><br><span class="line"></span><br><span class="line">toLowerCase()　　　　   转化为小写</span><br><span class="line"></span><br><span class="line">slice() 　　　截取子字符串(开始下标,结束的下标-1) 能用于数组和字符串</span><br><span class="line"></span><br><span class="line">Substr  substring  　　  截取字符串</span><br><span class="line"></span><br><span class="line">split() 　　　分隔字符串(分隔,个数) 字符串转化为数组  原有字符串不变</span><br><span class="line"></span><br><span class="line">charCodeAt() 　　　　　unicode码</span><br><span class="line"></span><br><span class="line">charAt(index) 　　　　　通过下标获取内容</span><br><span class="line"></span><br><span class="line">fromCharCode() 　　　　   转码</span><br><span class="line"></span><br><span class="line">trim() 　　　　　　　　删除字符串首尾空格</span><br><span class="line"></span><br><span class="line">模板字符串 　　　　　　　用反引号 ``</span><br><span class="line"></span><br><span class="line">includes()　　　　　　判断是否含有某个字符</span><br><span class="line"></span><br><span class="line">startsWith() 　　　返回布尔值，判断参数字符串是否在原字符串的头部。</span><br><span class="line"></span><br><span class="line">endsWith() 　　　　返回布尔值，判断参数字符串是否在原字符串的尾部。</span><br><span class="line"></span><br><span class="line">repeat() 字符串重复   返回新的字符串，表示将字符串重复指定次数返回。</span><br><span class="line"></span><br><span class="line">padStart() 　　　字符串补全 返回新的字符串，从头部补全原字符串。</span><br><span class="line"></span><br><span class="line">padEnd() 　　　　字符串补全 返回新的字符串，从尾部补全原字符串。</span><br></pre></td></tr></table></figure>

<p><strong>Module</strong></p>
<ul>
<li><p>命令</p>
</li>
<li><ul>
<li><p><strong>export</strong>：规定模块对外接口 以’react’为例</p>
</li>
<li><ul>
<li><strong>默认导出</strong>：export default</li>
<li><strong>单独导出</strong>：export</li>
<li><strong>按需导出</strong>：export {home,login}</li>
<li><strong>改名导出</strong>：export {home as login}</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><p><strong>import</strong>：导入模块内部功能 以’react’为例</p>
</li>
<li><ul>
<li><strong>默认导入</strong>：import Person from ‘.&#x2F;‘</li>
<li><strong>整体导入</strong>：import * as React from ‘react’;</li>
<li><strong>按需导入</strong>：import {home,login} from ‘.&#x2F;‘;</li>
<li><strong>改名导入</strong>：import {home as login} from ‘.&#x2F;‘;</li>
<li><strong>复合导入</strong>：import React,{component} from ‘react’</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h1><ul>
<li>1xx: 接受，继续处理</li>
<li>200: 成功，并返回数据</li>
<li>301: 永久移动，重定向</li>
<li>304: 资源未修改，可使用缓存</li>
<li>305: 需代理访问</li>
<li>400: 请求语法错误</li>
<li>401: 要求身份认证</li>
<li>403: 拒绝请求</li>
<li>404: 资源不存在</li>
<li>500: 服务器错误</li>
</ul>
<h1 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h1><blockquote>
<p>概念：WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。它是一个 持久化的协议， 基于 http ， 服务端可以 主动 push</p>
</blockquote>
<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><blockquote>
<p>概念：跨域是指浏览器不能执行其他网站的脚本。它是由浏览器的<strong>同源策略</strong>（域名、协议、端口均为相同）造成的，是浏览器对 JavaScript 实施的安全限制。</p>
</blockquote>
<p><strong>解决方式</strong></p>
<ul>
<li><p>JSONP: 主要是操作 dom，在 vue 和 react 中一般不用，利用 script 标签不受跨域限制的特点， 回调函数和数据。回调函数 是当响应到来时，应该在页面中调用的函数。回调函数的名字，一般是在请求中指定的。而数据就是传入回调函数中的 JSON 数据。 缺点是只能支持 get 请求。</p>
</li>
<li><p>ajax 是异步的，jsonp 是同步的，所以它不是真正的 ajax</p>
</li>
<li><p>CORS: Access-Control-Allow-Origin：，后台来进行设置，一般是在线上环境的时候解决跨域问题的方式</p>
</li>
<li><p>通过 Node 启动一个服务转发请求，因为服务端没有跨域限制</p>
</li>
<li><p>在 vue 和 react 中通过配置 webpack 的 proxy 来处理</p>
</li>
<li><p>Nginx 反向代理—-解决线上跨域问题的;</p>
</li>
<li><p><strong>为什么有跨域问题？</strong></p>
<p>跨域不一定会有跨域问题。</p>
<p>因为跨域问题是浏览器对于 ajax 请求的一种安全限制：<strong>一个页面发起的 ajax 请求，只能是于当前页同域名的路径</strong>，这能有效的阻止跨站攻击。</p>
<p>因此：<strong>跨域问题 是针对 ajax 的一种限制</strong>。</p>
<p>但是这却给我们的开发带来了不变，而且在实际生成环境中，肯定会有很多台服务器之间交互，地址和端口都可能不同，</p>
<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）。</p>
<p>它允许浏览器向跨源服务器，发出<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html"><code>XMLHttpRequest</code></a>请求，从而克服了 AJAX 只能<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">同源</a>使用的限制。</p>
<p>CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。</p>
<ul>
<li><p>浏览器端：</p>
<p>目前，所有浏览器都支持该功能（IE10 以下不行）。整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。</p>
</li>
<li><p>服务端：</p>
<p>CORS 通信与 AJAX 没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否运行其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。</p>
</li>
</ul>
<p>Nginx（发音同 engine x）是一个 Web 服务器，也可以用作反向代理，负载平衡器和 HTTP 缓存</p>
<h1 id="cors-解决跨域"><a href="#cors-解决跨域" class="headerlink" title="cors 解决跨域"></a>cors 解决跨域</h1></li>
</ul>
<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p>所谓代理就是在我们和真实的服务器之间有一台代理服务器，我们所有的请求都是通过它来进行转接的。</p>
<p><strong>正向代理</strong></p>
<p>正向代理就是我们访问不了 Google，但是我在国外有一台 vps，它可以访问 Google，我访问它，叫它访问 Google 后，把数据传给我。</p>
<p><strong>反向代理</strong></p>
<blockquote>
<p>反向代理隐藏了真实的服务端，当我们请求 <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 的时候，就像拨打 10086 一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx 就是性能非常好的反向代理服务器，用来做负载均衡。</p>
<p><strong>总结</strong></p>
<ul>
<li><strong>正向代理隐藏了真实的客户端</strong>。</li>
<li><strong>反向代理隐藏了真实的服务器</strong>。</li>
</ul>
</blockquote>
<h1 id="浏览器存储-Cookie、-LocalStorage-与-SessionStorage"><a href="#浏览器存储-Cookie、-LocalStorage-与-SessionStorage" class="headerlink" title="浏览器存储 Cookie、 LocalStorage 与 SessionStorage"></a>浏览器存储 Cookie、 LocalStorage 与 SessionStorage</h1><p>Cookie：</p>
<ul>
<li>一般由服务器生成，可设置失效时间。如果在浏览器端生成 Cookie，默认是关闭浏览器后失效</li>
<li>大小限制为 4KB 左右</li>
<li>每次都会携带在 HTTP 头中，如果使用 cookie 保存过多数据会带来性能问题</li>
<li>需要程序员自己封装，源生的 Cookie 接口不友好</li>
</ul>
<p>LocalStorage：</p>
<ul>
<li>除非被清除，否则永久保存</li>
<li>一般为 5MB</li>
<li>仅在客户端（即浏览器）中保存，不参与和服务器的通信</li>
<li>原生接口可以接受，亦可再次封装来对 Object 和 Array 有更好的支持</li>
</ul>
<p>SessionStorage：</p>
<ul>
<li>仅在当前会话下有效，关闭页面或浏览器后被清除</li>
<li>一般为 5MB</li>
<li>仅在客户端（即浏览器）中保存，不参与和服务器的通信</li>
<li>原生接口可以接受，亦可再次封装来对 Object 和 Array 有更好的支持</li>
</ul>
<h1 id="安全-—了解即可"><a href="#安全-—了解即可" class="headerlink" title="安全 —了解即可"></a>安全 —了解即可</h1><ul>
<li>XSS 攻击: 注入恶意代码攻击。比如 input 框里面别人如果输入一段恶意的脚本代码直接解析，就有可能造成数据的不安全，vue 的双向数据绑定，react 的受控组件一定程度上能够解决（解决方法：1.cookie 设置 httpOnly; 2.转义页面上的输入内容和输出内容）</li>
<li>CSRF: 跨站点请求伪造。（解决办法：1.get 不修改数据；2.不被第三方网站访问到用户的 cookie； 3. 设置白名单，不被第三方网站请求；4.请求加校验）</li>
</ul>
<h1 id="单页面应用（SPA）较多页面应用（MPA）的区别及优缺点"><a href="#单页面应用（SPA）较多页面应用（MPA）的区别及优缺点" class="headerlink" title="单页面应用（SPA）较多页面应用（MPA）的区别及优缺点"></a>单页面应用（SPA）较多页面应用（MPA）的区别及优缺点</h1><p>单页面应用（<strong>SPA</strong>）： 就是说指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由<strong>路由</strong>程序动态载入，单页面的页面跳转，仅刷新局部资源。</p>
<p>多页面应用（MPA）： 就是指一个应用中有多个页面，页面跳转时是<strong>整页刷新</strong>。</p>
<p>单页面的优点：</p>
<ul>
<li>用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点 spa 对服务器压力较小。</li>
<li>前后端分离。</li>
<li>页面效果会比较炫酷（比如切换页面内容时的专场动画）。</li>
</ul>
<p>单页面缺点：</p>
<ul>
<li>不利于 seo。 —通过预渲染+动态生成 meta 标签来解决部分 seo 问题</li>
<li>初次加载时耗时多。—–骨架屏+路由懒加载+异步组件–写代码的时候注意一下性能—图片懒加载，长列表优化，雪碧图…</li>
<li>页面复杂度提高很多。</li>
</ul>
<h1 id="DOM-事件流和事件委托"><a href="#DOM-事件流和事件委托" class="headerlink" title="DOM 事件流和事件委托"></a>DOM 事件流和事件委托</h1><p>DOM 事件流分为三个阶段：</p>
<ol>
<li>捕获阶段</li>
<li>目标阶段</li>
<li>冒泡阶段</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a4a8b7b9ec247e6a73f24b4ea907110~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b4e8dfe2eae4ccba8a229fe526384bc~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<ul>
<li>捕获阶段：在事件冒泡的模型中，捕获阶段不会响应任何事件；</li>
<li>目标阶段：目标阶段就是指事件响应到触发事件的最底层元素上；</li>
<li>冒泡阶段：冒泡阶段就是事件的触发响应会从最底层目标一层层地向外到最外层（根节点），事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层</li>
</ul>
<p>事件流描述的是从页面中接受事件的顺序，IE 和网景推出了两个正好相反的概念，IE 推出的是冒泡流，从下到上，网景则是事件捕获流，从上到下。</p>
<p>首先通过<code>addEventListener</code>方法给元素添加点击事件，前两个参数分别是点击事件的名称和执行的回调，第三个参数就是是否开启捕获，确定事件发生的阶段，默认是 false，也就是冒泡流。</p>
<p>事件委托，一般来说，会把一个或一组元素的时间委托到它的父元素上或者更外层元素上，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。在一些场景下，可以让性能得到优化。 比如给所有的列表添加点击事件，如果采用冒泡流，那么我们需要给每个元素添加点击事件，而采用事件委托的话，只需要在 ul 上绑定一个事件即可。</p>
<h1 id="new-操作符都做了些什么"><a href="#new-操作符都做了些什么" class="headerlink" title="new 操作符都做了些什么"></a>new 操作符都做了些什么</h1><p>let obj &#x3D; new Person();</p>
<ol start="2">
<li>在内存中创建了一个空对象</li>
<li>将空对象的<em>proto</em>属性指向构造函数的原型</li>
<li>运行这个构造函数，并用 call 或 apply 来改变构造函数的 this 指向</li>
<li>检查构造函数运行后的返回值</li>
</ol>
<h1 id="js-执行机制-eventloop–轮询"><a href="#js-执行机制-eventloop–轮询" class="headerlink" title="js 执行机制-eventloop–轮询"></a>js 执行机制-eventloop–轮询</h1><p>什么是异步<br>1、为了避免 dom 渲染冲突，js 是单线程的，也就是同一时间只能做一件事。异步是 js 单线程的解决方案。让同步代码先执行，等一段时间再执行异步的内容<br>2、常见的异步操作<br>微任务：promise、process.nextTick、<br>宏任务：setTimeout、setInterval、setImediate、</p>
<p><strong>查看讲 event loop 笔记，其实 vue 中 nexttick 的原理也是借助于宏任务，微任务问道 vue 中 nextick 原理时候，把宏任务微任务说出来</strong></p>
<p>异步和 event-loop</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;1&#x27;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#x27;2&#x27;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.-[p0-[0plog(&#x27;3&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&#x27;4&#x27;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&#x27;5&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(function() &#123;</span><br><span class="line">    console.log(&#x27;6&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&#x27;7&#x27;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&#x27;8&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#x27;9&#x27;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&#x27;10&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&#x27;11&#x27;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&#x27;12&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">// 1，7，6，8，2，4，3，5，9，11，10，12复制代码</span><br></pre></td></tr></table></figure>

<p>1、事件轮询是是 js 异步的具体实现。同步代码放在主线程中，异步的进入 event-table 并注册函数，<br>2、当指定的事件完成时，event-table 会将这个函数移入 event-queue<br>3、主线程内的任务执行完毕，会去 event-queue 读取对应的函数，进入主线程执行<br>4、先执行微任务，再执行宏任务<br>5、上述过程不断重复，也就是常说的 event-loop</p>
<h1 id="BFC-—-讲一下"><a href="#BFC-—-讲一下" class="headerlink" title="BFC —-讲一下"></a>BFC —-讲一下</h1><p><strong>1、盒模型</strong></p>
<p>盒模型包括标准盒模型和 IE 盒模型<br>内容：content、padding、border、margin<br>区别：计算 width 和 height 方式不同，标准盒模型：content，IE 盒模型 content+padding+border<br>设置：标准盒模型：box-sizing:content-box，IE 盒模型：box-sizing:border-box</p>
<p>通过 box-sizing 属性来转换不同的盒模型模式</p>
<p><strong>2、BFC</strong></p>
<p>概念：块级格式化上下文，是一块渲染区域，满足下面声明的元素会生成 BFC</p>
<ul>
<li>float 不为 none</li>
<li>overflow 不为 visible</li>
<li>display 为 inline-block</li>
<li>position 为 absolute 或 fixed</li>
</ul>
<p>应用：</p>
<ul>
<li><p>解决边距重叠问题：两个兄弟元素，margin 边距会重叠，取较大者。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">#A &#123;</span><br><span class="line">     width: 100px;</span><br><span class="line">     height: 100px;</span><br><span class="line">     background: red;</span><br><span class="line">     margin-bottom: 100px;</span><br><span class="line">     &#125;</span><br><span class="line">#B &#123;</span><br><span class="line">     width: 100px;</span><br><span class="line">     height: 100px;</span><br><span class="line">     background: blue;</span><br><span class="line">     margin-top: 200px;</span><br><span class="line">     &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;A&quot;&gt;A&lt;/div&gt;</span><br><span class="line">    &lt;div style=&quot;overflow: hidden&quot;&gt;</span><br><span class="line">       &lt;div id=&quot;B&quot;&gt;B&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>解决方法：将两个元素放到不同 BFC 环境下就好了。如 A 在 body 环境下，margin-bottom:100,B 在 box 环境下，margin-top:200，给 box 加上 BFC</p>
</li>
<li><p>清除浮动：外面的 outer 并没有被内容撑开，原因是浮动脱离了文档流，与普通元素所处的流层不一样，不会被撑开</p>
<p>解决方法：在 outer 加上 bfc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> &lt;style&gt;</span><br><span class="line">       *&#123;</span><br><span class="line">           margin: 0;</span><br><span class="line">           padding: 0;</span><br><span class="line">       &#125;</span><br><span class="line">       .outer&#123;</span><br><span class="line">           border: 2px solid black;</span><br><span class="line">           margin:100px;</span><br><span class="line">           overflow: hidden;</span><br><span class="line">       &#125;</span><br><span class="line">       .inner&#123;</span><br><span class="line">           width: 100px;</span><br><span class="line">           height: 100px;</span><br><span class="line">           float: left;</span><br><span class="line">       &#125;</span><br><span class="line">       .red&#123;</span><br><span class="line">        background: red;</span><br><span class="line">       &#125;</span><br><span class="line">       .green&#123;</span><br><span class="line">        background: green;</span><br><span class="line">       &#125;</span><br><span class="line">       .blue&#123;</span><br><span class="line">        background: blue;</span><br><span class="line">       &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;inner red&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;inner green&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;inner blue&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="三栏布局-—-三段式"><a href="#三栏布局-—-三段式" class="headerlink" title="三栏布局 —-三段式"></a>三栏布局 —-三段式</h1><ul>
<li>浮动</li>
<li>绝对定位</li>
<li>flex 布局</li>
</ul>
<h1 id="flex-布局-—-属性"><a href="#flex-布局-—-属性" class="headerlink" title="flex 布局 —-属性"></a>flex 布局 —-属性</h1><p>一.父元素属性<br>1.display:flex;（定义了一个 flex 容器）</p>
<p>flex-direction（决定主轴的方向）row（默认值，水平从左到右）colunm（垂直从上到下）row-reverse（水平从右到左）column-reverse（垂直从下到上）</p>
<p>flex-wrap 定义如何换行 nowrap（默认值，不换行）wrap（换行）wrap-reverse（换行，且颠倒行顺序，第一行在下方）<br>flex-flow（属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap）</p>
<p>justify-content（设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式）</p>
<p>flex-start（ 默认值、弹性盒子元素将向行起始位置对齐）</p>
<p>flex-end（弹性盒子元素将向行结束位置对齐）</p>
<p>center（弹性盒子元素将向行中间位置对齐。该行的子元素将相互对齐并在行中居中对齐）</p>
<p>space-between（弹性盒子元素会平均地分布在行里）</p>
<p>space-around（弹性盒子元素会平均地分布在行里，两端保留子元素与子元素之间间距大小的一半）</p>
<p>align-items（设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式）</p>
<p>flex-start（弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界）</p>
<p>flex-end（弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界）</p>
<p>center（ 弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度)</p>
<p>baseline（如弹性盒子元素的行内轴与侧轴为同一条，则该值与 flex-start 等效。其它情况下，该值将参与基线对齐。）</p>
<p>stretch（如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min&#x2F;max-width&#x2F;height’属性的限制）</p>
<p>align-content（设置或检索弹性盒堆叠伸缩行的对齐方式）</p>
<p>flex-start（各行向弹性盒容器的起始位置堆叠。弹性盒容器中第一行的侧轴起始边界紧靠住该弹性盒容器的侧轴起始边界，之后的每一行都紧靠住前面一行）</p>
<p>flex-end（各行向弹性盒容器的结束位置堆叠。弹性盒容器中最后一行的侧轴起结束界紧靠住该弹性盒容器的侧轴结束边界，之后的每一行都紧靠住前面一行）</p>
<p>center（各行向弹性盒容器的中间位置堆叠。各行两两紧靠住同时在弹性盒容器中居中对齐，保持弹性盒容器的侧轴起始内容边界和第一行之间的距离与该容器的侧轴结束内容边界与第最后一 行之间的距离相等）</p>
<p>space-between（各行在弹性盒容器中平均分布。第一行的侧轴起始边界紧靠住弹性盒容器的侧轴起始内容边界，最后一行的侧轴结束边界紧靠住弹性盒容器的侧轴结束内容边界，剩余的行则 按一定方式在弹性盒窗口中排列，以保持两两之间的空间相等）</p>
<p>space-around（ 各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。各行会按一定方式在弹性盒容器中排列，以保持两两之间的空间相等，同时第一行前面及最后 一行后面的空间是其他空间的一半）</p>
<p>stretch（各行将会伸展以占用剩余的空间。剩余空间被所有行平分，以扩大它们的侧轴尺寸）<br>二.子元素上属性<br>1.order（默认情况下 flex order 会按照书写顺训呈现，可以通过 order 属性改变，数值小的在前面，还可以是负数）</p>
<p>2.flex-grow（设置或检索弹性盒的扩展比率,根据弹性盒子元素所设置的扩展因子作为比率来分配剩余空间）</p>
<p>3**.**flex-shrink（设置或检索弹性盒的收缩比率,根据弹性盒子元素所设置的收缩因子作为比率来收缩空间）</p>
<p>4.flex-basis(设置或检索弹性盒伸缩基准值，如果所有子元素的基准值之和大于剩余空间，则会根据每项设置的基准值，按比率伸缩剩余空间)</p>
<p>5.flex (flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选)</p>
<p>6.align-self(设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式，可以覆盖父容器 align-items 的设置)</p>
<h1 id="webpack-配置"><a href="#webpack-配置" class="headerlink" title="webpack 配置"></a>webpack 配置</h1><ul>
<li><p>webpack 定义<br>webpack 是一个模块打包工具，用来管理项目中的模块依赖，并编译输出模块所需的静态文件。它可以很好地管理、打包开发中所用到的 HTML、CSS、JS 和静态文件等，让开发更高效</p>
</li>
<li><p>webpack 基本功能和工作原理<br>1、代码转换：TypeScript 编译成 js、scss 编译成 css 等<br>2、文件优化：压缩 js、css、HTML 代码，压缩合并图片等<br>3、代码分割：提取多个页面的公共代码，提取首屏不需要执行部分的代码，让其异步加载<br>4、模块合并：某个模块引用其他的模块和文件，需要构建功能，把模块合并成一个文件<br>5、热更新：监听本地原代码变化，自动构建，更新内容</p>
</li>
<li><p>webpack 配置结构</p>
<p>1、mode: ‘development’ &#x2F;&#x2F; production</p>
<p>2、entry：打包文件入口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  page1: &#x27;./page1.js&#x27;,</span><br><span class="line">  page2: &#x27;./page2.js&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、output：指定打包后资源位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname__, &#x27;./dist&#x27;),</span><br><span class="line">  filename: &#x27;[name].[hash].js&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、module: {rules: []}： 配置各种 loader</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [&#123;</span><br><span class="line">    test: /\.(jpg|png|jpeg|svg)$/,</span><br><span class="line">    use: &#123;</span><br><span class="line">      loader: &#x27;url-loader&#x27;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        name: &#x27;[name]_[hash].[ext]&#x27;,</span><br><span class="line">        outputPath: &#x27;./imgs&#x27;,</span><br><span class="line">        limit: 2048</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、plugins: []</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins: [new HtmlWepackPlugin(&#123;template: &#x27;./index.html&#x27;&#125;)]</span><br></pre></td></tr></table></figure>

<p>6、devServer: {port: ,hot: true, proxy: ‘&#x2F;api’:{target: ‘’}}</p>
<p>7、optimization：代码分割等配置</p>
</li>
<li><p>使用过哪些 loader</p>
<p>1、file-loader： 打包文件</p>
<p>2、url-loader： 打包文件，与 file-loader 不同在于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.(png|jpg|jpeg|svg)$/,</span><br><span class="line">  use: &#123;</span><br><span class="line">    loader: &#x27;url-loader&#x27;,</span><br><span class="line">    options: &#123;</span><br><span class="line">      limit: 1000,  //小于1000的文件打包出base64格式写入js，减少http请求</span><br><span class="line">      outputPath: &#x27;./imgs&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、css-loader</p>
<p>4、style-loader： 打包代码加入 style 标签中</p>
<p>5、scss-loader</p>
<p>6、postcss-loader：加上厂商前缀</p>
<p>7、babel-loader：处理 es6&#x2F;7，jsx，typescript 等转译</p>
</li>
<li><p>使用过哪些 plugin</p>
<p>1、html-webpack-plugin：指定 html 模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(&#123;template: &#x27;./index.html&#x27;&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>2、clean-webpack-plugin：打包时先清理源目录文件</p>
<p>3、mini-css-extract-plugin：</p>
<p>4、webpack.HotModuleReplacePlugin：热更新，使得代码修改后不用刷新浏览器就自动更新</p>
</li>
<li><p>什么是 tree-shaking?<br>tree-shaking，摇树，是指在打包过程中，把没用到的代码除去，提高代码利用率，提高性能</p>
</li>
<li><p>区分环境合并配置文件：webpack-merge</p>
</li>
<li><p>代码分割：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    async: &#x27;all&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>webpack 构建过程<br>1、从 entry 里面配置的入口文件递归解析所有依赖的 module<br>2、根据配置的 loader 去找相应的转换规则<br>3、以 entry 为单位，一个 entry 和其所有依赖的 module 打包成一个 chunk<br>4、把 chunk 转换成文件输出<br>5、在整个过程中，webpack 会在恰当时机执行 plugin 里面定义的逻辑</p>
</li>
<li><p>手写一个 loader<br>loader 就是一个函数，接收原代码 source，然后处理原代码，最后 return source 即可。不能用箭头函数，因为 this 由 webpack 填充，可以访问一些方法和属性</p>
</li>
<li><p>手写一个 plugin<br>1、定义一个 js 函数<br>2、在函数原型上挂一个 apply 方法<br>3、指定一个 compile 钩子<br>4、处理完执行回调函数</p>
</li>
</ul>
<h1 id="vuex-中-muation-为什么不能有异步操作，如果要异步要怎么做？"><a href="#vuex-中-muation-为什么不能有异步操作，如果要异步要怎么做？" class="headerlink" title="vuex 中 muation 为什么不能有异步操作，如果要异步要怎么做？"></a>vuex 中 muation 为什么不能有异步操作，如果要异步要怎么做？</h1><p>每个 mutation 执行完成后都会对应到一个新的状态变更，这样 devtools 就可以打个快照存下来，然后就可以实现 time-travel 了。如果 mutation 支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</p>
<p>Action：可以异步，但不能直接操作 State。</p>
<h1 id="Vue-设置响应式数据除了-set-还有什么方法？"><a href="#Vue-设置响应式数据除了-set-还有什么方法？" class="headerlink" title="Vue 设置响应式数据除了 set 还有什么方法？"></a>Vue 设置响应式数据除了 set 还有什么方法？</h1><p>对象添加属性还可以使用 Object.assign({},obj1,obj2)返回获取的新对象替换原有对象</p>
<p>使用 JavaScript 的数组操作函数，这些方法都会返回一个新数组，也是数组替换原理（或者内部重写了相关的方法，让变化能够被检测）</p>
<h1 id="Vue-Loader-是什么？"><a href="#Vue-Loader-是什么？" class="headerlink" title="Vue Loader 是什么？"></a>Vue Loader 是什么？</h1><p>Vue Loader 是一个 <code>webpack</code> 的 <code>loader</code>，它允许你以一种名为单文件组件 <code>(SFCs)</code>的格式撰写 <code>Vue</code> 组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;example&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#x27;Hello world!&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.example &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>Vue Loader 还提供了很多酷炫的特性：</p>
<ul>
<li>允许为 Vue 组件的每个部分使用其它的 webpack loader，例如在 的部分使用 Sass 和在 <template> 的部分使用 Pug；</li>
<li>允许在一个 .vue 文件中使用自定义块，并对其运用自定义的 loader 链；</li>
<li>使用 webpack loader 将 和 <template> 中引用的资源当作模块依赖来处理；</li>
<li>为每个组件模拟出 scoped CSS；</li>
<li>在开发过程中使用热重载来保持状态。</li>
</ul>
<h1 id="vue-父子组件的生命周期"><a href="#vue-父子组件的生命周期" class="headerlink" title="vue 父子组件的生命周期"></a>vue 父子组件的生命周期</h1><ul>
<li><p>加载渲染过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>子组件更新过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>父组件更新过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父beforeUpdate-&gt;父updated</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>销毁过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="理解单向数据流"><a href="#理解单向数据流" class="headerlink" title="理解单向数据流"></a>理解单向数据流</h1><p>所有的 <code>prop</code> 都使得其父子 <code>prop</code> 之间形成了一个单向下行绑定：父级 <code>prop</code> 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<p>额外的，每次父级组件发生更新时，子组件中所有的 <code>prop</code> 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 <code>prop</code>。</p>
<p>总体来说，所谓单向数据流就是父级 prop 的更新会向下流动到子组件中，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值</p>
<h1 id="项目部分面试题"><a href="#项目部分面试题" class="headerlink" title="项目部分面试题"></a><strong>项目部分面试题</strong></h1><h1 id="项目上线和测试–开发流程"><a href="#项目上线和测试–开发流程" class="headerlink" title="项目上线和测试–开发流程"></a>项目上线和测试–开发流程</h1><p>首先是产品来给我们谈需求，我们在讨论一下能具体实现到哪种程度。然后 ui 把设计图发给我们，组长带我们分配一下任务，敲就完了。</p>
<h1 id="项目中有没有难点？"><a href="#项目中有没有难点？" class="headerlink" title="项目中有没有难点？"></a>项目中有没有难点？</h1><p>有，最大的问题还是兼容性的问题。之前做小程序开发的时候，遇到过一个问题。就是微信 pc 端，它一直有各种故障。<br>所以当时我就到处查了查，了解了一下.<br>原来微信自带用的是 QQ 浏览器 X5 内核。X5 内核基于 Webkit，它使用的 webkit 版本较低。<br>不支持 es6，无法识别 URLSearchParams。安装了 babel，还有一些额外的依赖，最后能运行了。</p>
<p>其次是监听同源其他窗口，这个当时一时之间没有思路。后来主要是利用 addEventListener(‘storage’）和 storageChange 实现了监听效果</p>
<p>还有就是一次从后台接口拿的数据特别大，页面一打开就快崩溃了。 用通常处理方法（分页，懒加载好了一点，依然卡的要死，<br>最后让后台直接生成文件，前端这边用 nginx 请求文件，读取就非常快</p>
<h1 id="开发环境和生产环境的区别？"><a href="#开发环境和生产环境的区别？" class="headerlink" title="开发环境和生产环境的区别？"></a>开发环境和生产环境的区别？</h1><p>开发环境：开发环境是我们专门用于开发的服务器，配置可以比较随意， 为了开发调试方便，一般打开全部错误报告。<br>测试环境：一般是克隆一份生产环境的配置，一个程序在测试环境工作不正常，那么肯定不能把它发布到生产机上。<br>生产环境：也就是通常说的真实环境。是正式提供对外服务的，一般会关掉错误报告，打开错误日志。</p>
<h1 id="脚手架里没有的组件怎么办？你怎么解决？"><a href="#脚手架里没有的组件怎么办？你怎么解决？" class="headerlink" title="脚手架里没有的组件怎么办？你怎么解决？"></a>脚手架里没有的组件怎么办？你怎么解决？</h1><p>自己封装</p>
<h1 id="实现交互的时候如果数据太大放不下，怎么办呢？"><a href="#实现交互的时候如果数据太大放不下，怎么办呢？" class="headerlink" title="实现交互的时候如果数据太大放不下，怎么办呢？"></a>实现交互的时候如果数据太大放不下，怎么办呢？</h1><p>分页，懒加载，<br>关键还是数据的切分.<br>如果是极端情况，可以让后台生成文件返回前端，得到文件路径，前端直接通过 nginx 请求文件，读取非常快</p>
<h1 id="使用-cookie-的？"><a href="#使用-cookie-的？" class="headerlink" title="使用 cookie 的？"></a>使用 cookie 的？</h1><p>前端有三种本地存储方式，sessionStorage、localStorage、cookie。<hr>要使用 cookie，页面必须在服务器中运行，cookie 最大是 4kb，也就是 4096 字节。通常我们用 cookie 来保持用户信息</p>
<h1 id="本地环境相关的配置"><a href="#本地环境相关的配置" class="headerlink" title="本地环境相关的配置"></a>本地环境相关的配置</h1><p>现在一般我们构建页面都是需要使用 npm + webpack 的，可以利用 webpack 提供给我的 devServer 这个参数进行配置。<br>然后是利用服务器为我们本地开发提供模板引擎的调用。如果我们的后端是 php、java、python 等等的后端语言，我们在电脑中不可能就去安装他们这个语言的运行环境。就算你装了，数据库的权限也不一定提供给你。就算提供，我们的电脑已经跑了 webpack，也不太可能跑得动后端服务了。所以我们必须和后端做一些约定，来实现我在本地能使用测试环境的服务器来实现模板引擎的渲染。之后的话呢，就是静态资源和接口的配置，</p>
<p>因为我们启动 webpack 的构建，在不借用任何修改 host 或者自己启动 dns 服务等操作的情况下，一般我们通过前面搭建出来的页面，在加载完 js 之后，请求接口都会形成一个跨域的问题。所以我们就可以利用 webpack 提供给我们的 devServer 功能，做一个反向代理的功能。就是利用 setup&#x2F;before 中配置路由的方式配置一个我们的 ajax 路径的反向代理规则。</p>
<p>简单来说就是匹配你页面中请求的路径，因为 host 和端口不一样导致跨域，所以用 node 这层来做一个反向代理，设定好 host 和端口，来帮你从 node 这一层去模拟浏览器发出的请求，欺骗服务器以为你是浏览器发送过来的（其实就像爬虫一样）。从而实现跨域的请求方式，来解决我本地开发中的 ajax 跨域问题。</p>
<p>总结一下，本地开发的方式有很多种，有的公司已经提供了一套完善的机制，docker 环境或者服务器开发等一系列方式，例如 BAT。但是很多时候可能并不具备这样的条件，所以我们可以用 webpack 提供给我们的功能来实现本地开发。<br>以上的方式也只是我在公司项目中的做法，可能需要根据实际的情况做一些调整，但是这个比较关键的是思路。<br>相比自己搭建环境，使用 webpack 去做反向代理的方式其实会更加简单，快捷并且对于你用来开发的电脑的负担也会相对来说小一点，能有更多内存来提供更流畅的开发体验。<br>一般这一套方案都是跟着 git 或者 svn 的仓库一起提交的，理论上每个人基本都是可以复用的，无需重复搭建环境，直接跑起来开发，更加方便。<br>如果像我自己再公司的项目那样，我们就是利用这样的方案，让整个电商的项目可以在 webpack 的 devServer 中完成的从首页到下单的本地开发，非常方便的开发那种需要跨几个页面维度的需求。（通过 webpack 中配置路由规则）</p>
<h1 id="不同浏览器的适配你有哪些方案？"><a href="#不同浏览器的适配你有哪些方案？" class="headerlink" title="不同浏览器的适配你有哪些方案？"></a>不同浏览器的适配你有哪些方案？</h1><p>首先是要兼容主流的浏览器，再使用优雅降级的方法兼容低版本的浏览器。<br>不同的浏览器之间为了适配，基本上一开始先来一个样式初始化。<br>通配符星号，先把 margin padding 什么的先调整为 0；<br>然后设置 rem 来统一 font-size，a 标签啊，li 标签的默认样式改成 none；<br>添加不同类型的浏览器内核前缀。<br>还有就是 JS 的兼容性。ES6 语法之类的，使用 Babel 进行转换，<br>现在基本也不怎么考虑老版 IE 的问题了，如果真的遇到这个开发的问题，基本上也就查一查也都能查到。</p>
<h1 id="10-前端怎么解决性能问题？"><a href="#10-前端怎么解决性能问题？" class="headerlink" title="10.前端怎么解决性能问题？"></a>10.前端怎么解决性能问题？</h1><p><strong>内容部分</strong>:</p>
<p><strong>尽量减少 HTTP 请求数</strong></p>
<p><strong>减少 DNS 查找</strong></p>
<p><strong>避免重定向</strong></p>
<p><strong>让 Ajax 可缓存</strong></p>
<p><strong>延迟加载组件</strong></p>
<p><strong>预加载组件</strong></p>
<p><strong>减少 DOM 元素的数量</strong></p>
<p><strong>跨域分离组件</strong></p>
<p><strong>尽量少用 iframe</strong></p>
<p><strong>杜绝 404</strong></p>
<p><strong>Css 部分</strong>:</p>
<p><strong>避免使用 CSS 表达式</strong></p>
<p><strong>选择<link>舍弃@import</strong></p>
<p><strong>避免使用滤镜</strong></p>
<p><strong>把样式表放在顶部</strong></p>
<p><strong>JS 部分</strong>:</p>
<p><strong>去除重复脚本</strong></p>
<p><strong>尽量减少 DOM 访问</strong></p>
<p><strong>用智能的事件处理器</strong></p>
<p><strong>把脚本放在底部</strong></p>
<p><strong>把 JavaScript 和 CSS 放到外面</strong></p>
<p><strong>压缩 JavaScript 和 CSS</strong></p>
<p><strong>图片</strong>:</p>
<p><strong>优化图片</strong></p>
<p><strong>优化 CSS Sprite</strong></p>
<p><strong>不要用 HTML 缩放图片</strong></p>
<p><strong>用小的可缓存的 favicon.ico（P.S. 收藏夹图标）</strong></p>
<p><strong>cookie</strong>:</p>
<p><strong>把组件放在不含 cookie 的域下</strong></p>
<p>**移动端 **:</p>
<p><strong>保证所有组件都小于 25K</strong></p>
<p><strong>把组件打包到一个复合文档里</strong></p>
<h1 id="标准盒模型和怪"><a href="#标准盒模型和怪" class="headerlink" title="标准盒模型和怪"></a>标准盒模型和怪</h1><p><strong>异盒模型</strong></p>
<p>在 HTML 中，可以把元素看做盒子，盒子包括：content、 padding、border、margin<br>标准盒模型（W3C 盒子模型），设置的 width 或 height 是对 实际内容（content）的 width 或 height 进行设置，内容周围的 border 和 padding 另外设置，<br>即盒子模型的 width（height）&#x3D;设置的 content 的宽高+padding+border+margin</p>
<p>怪异盒模型（IE 盒子模型），<br>设置的 width 或 height 是对 content+padding+border 之和的 width 和 height 进行设置的，<br>其盒模型的 width（height）&#x3D;设置的 width（height）+外边距 margin</p>
<p>box-sizing 属性允许以特定的方式定义匹配某个区域的特定元素。（个人认为可以理解为指定盒模型的类型，即上述两种类型）<br>box-sizing 值为 content-box 时：宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框。（即 标准盒模型）<br>box-sizing 值为 border-box 时：为元素设定的宽度和高度决定了元素的边框盒，就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制，通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。（即 怪异盒模型）<br>box-sizing 值为 inherit 时：规定应从父元素继承 box-sizing 属性的值。</p>
<h1 id="谈谈-async-await-和-promise"><a href="#谈谈-async-await-和-promise" class="headerlink" title="谈谈 async await 和 promise"></a>谈谈 async await 和 promise</h1><p>Promise,简单来说就是一个对象，里面保存一个异步操作的结果。<br>Promise 对象特点，一是对象的状态永远不受外部的影响，二是一旦状态改变，就会凝固，不会再次变化。<br>它有三个状态，分别是 pending resolve reject</p>
<p>Async-Await 是 es7 加入的新语法<br>他是 promise 和 generator 的语法糖，写法看起来完全是同步编程。<br>async 用于申明一个 function 是异步的，而 await 可以认为是 async wait 的简写，等待一个异步方法执行完成。</p>
<h1 id="redux-用过哪些中间件"><a href="#redux-用过哪些中间件" class="headerlink" title="redux 用过哪些中间件"></a>redux 用过哪些中间件</h1><p>thunk 是最典型的一个 redux 中间件，<br>应用它之后，我们可以 dispatch 一个方法，而不仅限于一个纯的 action 对象。</p>
<h1 id="react-项目遇到过哪些难题吗？"><a href="#react-项目遇到过哪些难题吗？" class="headerlink" title="react 项目遇到过哪些难题吗？"></a>react 项目遇到过哪些难题吗？</h1><p>有遇到过很多。但是基本上都是 js 的问题，通常和 react 本身没什么关系</p>
<h1 id="使用过-nodejs-吗？"><a href="#使用过-nodejs-吗？" class="headerlink" title="使用过 nodejs 吗？"></a>使用过 nodejs 吗？</h1><p>使用过，对于 http，fs 之类的原生用法都使用的非常熟悉，对于 express、koa、egg 来做服务器中间层也比较熟练。长期使用 npm 生态圈的各种开发工具，基本上都还是很熟练的。</p>
<h1 id="后端的接口怎么进行联调？"><a href="#后端的接口怎么进行联调？" class="headerlink" title="后端的接口怎么进行联调？"></a>后端的接口怎么进行联调？</h1><p>我们基本上是主要使用 postman 这个软件来实现联调，根据后端提供的这个接口进行测试，然后反馈给他们后端人员就行了</p>
<h1 id="怎么打包？打出来是什么样子呢？"><a href="#怎么打包？打出来是什么样子呢？" class="headerlink" title="怎么打包？打出来是什么样子呢？"></a>怎么打包？打出来是什么样子呢？</h1><p>前端的话，我们一般使用 webpack 来做打包。通常来说自己对 webpack 进行配置，打出来一个 dist 文件，html，css，js 文件都是相互独立出来的。</p>
<h1 id="配置-webpack-的-plugin，列举一些"><a href="#配置-webpack-的-plugin，列举一些" class="headerlink" title="配置 webpack 的 plugin，列举一些"></a>配置 webpack 的 plugin，列举一些</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 导入处理路径的模块</span><br><span class="line">    var path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">    // 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理</span><br><span class="line">    module.exports = &#123;</span><br><span class="line">    	//配置打包模式为开发模式</span><br><span class="line">   		 mode: &#x27;development&#x27;,</span><br><span class="line">        entry: path.resolve(__dirname, &#x27;src/index.js&#x27;), // 项目入口文件</span><br><span class="line">        output: &#123; // 配置输出选项</span><br><span class="line">            path: path.resolve(__dirname, &#x27;dist&#x27;), // 配置输出的路径</span><br><span class="line">            filename: &#x27;main.js&#x27; // 配置输出的文件名</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="redux-里的-action-怎么用的"><a href="#redux-里的-action-怎么用的" class="headerlink" title="redux 里的 action 怎么用的"></a>redux 里的 action 怎么用的</h1><p>我们想要改变 store 仓库里面的数据，就用 dispatch 方法把 action 传递给 reducer，reducer 会根据 action 的类型来修改出来一个新的 state 取代原先的 store</p>
<h1 id="react-不用-redux-跨组件传递数据"><a href="#react-不用-redux-跨组件传递数据" class="headerlink" title="react 不用 redux 跨组件传递数据"></a>react 不用 redux 跨组件传递数据</h1><p>首先最笨的方法是透传，一层层传下去。如果说中间的组件也需要这个值的话，其实也是可以用这个写法的。如果中间的组件根本不需要这个值，而且层数太多了的话，类组件里面的话可以用 context 来传值。在外层组件定义 context.provider，子组件用 consumer 就可以接收到了。hooks 函数组件里面用 useContext 也可以，还是很方便的，写法和类组件差不多</p>
<h1 id="ajax-x2F-axios-你进行过封装吗？"><a href="#ajax-x2F-axios-你进行过封装吗？" class="headerlink" title="ajax&#x2F;axios 你进行过封装吗？"></a>ajax&#x2F;axios 你进行过封装吗？</h1><p>封装过 ajax，但是现在有点记不清了。现在开发项目的话基本用 axios 就行了。axios 可以用 interceptors 拦截器来封装，添加一些错误处理，token，还有权限的判断。</p>
<h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>Axios 是一个基于 promise 的 HTTP 库，用于浏览器和 node.js 等 http 客户端，主要用来向后台发送各种业务请求和特殊处理，由于 axios 支持后台数据交互、拦截请求和响应、取消请求、超时设定、转换 json、防御 XSRF 攻击等特性，Vue 官方已经不再维护 vue-resource 并且推荐使用 axios。</p>
<h1 id="CSRF-x2F-XSRF-攻击和-XSS-攻击"><a href="#CSRF-x2F-XSRF-攻击和-XSS-攻击" class="headerlink" title="CSRF&#x2F;XSRF 攻击和 XSS 攻击"></a>CSRF&#x2F;XSRF 攻击和 XSS 攻击</h1><p>XSS(Cross Site Scripting 跨站<strong>脚本</strong>)。XSS 定义的主语是“脚本”，是一种跨站执行的脚本，也就是 javascript 脚本，指的是在网站上注入我们的 javascript 脚本，执行非法操作。</p>
<p>CSRF（Cross-site request forgery 跨站<strong>请求</strong>伪造，也被称为“One Click Attack”或者 Session Riding，通常缩写为 CSRF 或者 XSRF，是一种对网站的恶意利用。CSRF 定义的主语是”请求“，是一种跨站的伪造的请求，指的是跨站伪造用户的请求，模拟用户的操作.</p>
<p><strong>XSS 攻击</strong>发生的条件是可以执行 javascript 脚本，一般在站点中总会有发表文章、留言等信息的表单，这种表单一般是写入到数据库中，然后在某个页面进行展示。我们可以在这些表单中直接编写 javascript 代码（<code>alert(&quot;哈哈哈哈，你被攻击了!&quot;);</code>）进行测试，看是否可以执行。如果在信息展示页面 js 代码可以执行，XSS 攻击就成功了。</p>
<p><strong>CSRF 攻击</strong>能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对</p>
<h1 id="为什么要二次封装-axios"><a href="#为什么要二次封装-axios" class="headerlink" title="为什么要二次封装 axios"></a>为什么要二次封装 axios</h1><p>api 统一管理,不管接口有多少,所有的接口都可以非常清晰,容易维护.</p>
<p>通常我们的项目会越做越大,页面也会越来越多,如果页面非常的少,直接用 axios 也没有什么大的影响,那页面组件多了起来,上百个接口呢,这个时候后端改了接口,多加了一个参数什么的呢?那就只有找到那个页面,进去修改.整个过程很繁琐不易于项目的维护和迭代.</p>
<p>这个时候如果我们统一的区管理接口,需要修改某一个接口的时候直接在 api 里修改对应的请求是不是很方便呢?因为我们用的最多的还是 get post 请求.我们就可以针对封装.</p>
<h1 id="你是怎么做移动端的优化？"><a href="#你是怎么做移动端的优化？" class="headerlink" title="你是怎么做移动端的优化？"></a>你是怎么做移动端的优化？</h1><p>在开发页面时，必须考虑用户打开页面的时间长度，针对不同的用户终端设计出兼容性强的页面，想要提升手机网站打开速度，也需要注意不要使用 Flash 之类的插件，虽然是移动端，但是依旧会影响用户体验，一定程度上减少百度索引的抓取。导致运行困难。 　　一般来说，移动站点的页面下载速度要比 PC 网站慢得多，因此在优化移动网站时，需要将页面大小和体积控制在较低的水平。考虑到现在用户时间都是碎片化，用户浏览网页的时间基本上是零散的，因此我们必须尽量简化手机网站的设计</p>
<h1 id="你可以实现图片懒加载吗？"><a href="#你可以实现图片懒加载吗？" class="headerlink" title="你可以实现图片懒加载吗？"></a>你可以实现图片懒加载吗？</h1><p>先将 img 标签的 src 链接设为同一张图片（比如空白图片），然后给 img 标签设置自定义属性（比如 data-src）,然后将真正的图片地址存储在 data-src 中，当 JS 监听到该图片元素进入可视窗口时，将自定义属性中的地址存储到 src 属性中。达到懒加载的效果。</p>
<p>这样做能防止页面一次性向服务器发送大量请求，导致服务器响应面，页面卡顿崩溃等。</p>
<h1 id="localStorage-的使用场景，最大的存储量多大？做过限制存储量的操作吗"><a href="#localStorage-的使用场景，最大的存储量多大？做过限制存储量的操作吗" class="headerlink" title="localStorage 的使用场景，最大的存储量多大？做过限制存储量的操作吗"></a>localStorage 的使用场景，最大的存储量多大？做过限制存储量的操作吗</h1><p>5MB 在较旧版本的 IE 小于 8 里面的 userData（模拟本地存储）页面限制为 128kb</p>
<h1 id="如何优化首屏启动速度？"><a href="#如何优化首屏启动速度？" class="headerlink" title="如何优化首屏启动速度？"></a>如何优化首屏启动速度？</h1><p>减少代码冗余，同样实现一个效果的能用 css 就尽量不用 js，减少资源载入，图片使用懒加载，视频或音频禁止自动播放，使用 CDN 加速静态资源。<br>提升页面渲染速度将 CSS 样式写在头部样式表中，减少由 CSS 文件网络请求造成的渲染阻塞。<br>将 JavaScript 放到文档末尾，或使用 async 方式加载，避免 JS 执行阻塞渲染。<br>对非文字元素（如图片，视频）指定宽高，避免浏览器重排重绘。<br>服务器本身的速度优化，还有前端代码打包</p>
<h1 id="特殊的-loading-效果做过吗"><a href="#特殊的-loading-效果做过吗" class="headerlink" title="特殊的 loading 效果做过吗"></a>特殊的 loading 效果做过吗</h1><p>做过，react 方面可以借助 react-loadable 实现这个效果。<br>react 新版本也自带了 lazy-load，都可以直接拿来用。</p>
<p>vue 的话自己封装一个 loading 组件，在 vuex 里定义它的开关。<br>在什么地方使用都可以调用就可以了</p>
<h1 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h1><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。 具体而言，<strong>高阶组件是参数为组件，返回值为新组件的函数。</strong> 高阶组件是将组件转换为另一个组件。</p>
<h1 id="高阶组件用在哪些地方？"><a href="#高阶组件用在哪些地方？" class="headerlink" title="高阶组件用在哪些地方？"></a>高阶组件用在哪些地方？</h1><p>代码复用，逻辑抽象，抽离底层准备（bootstrap）代码<br>渲染劫持<br>State 抽象和更改<br>Props 更改</p>
<h1 id="px-em-rem-的区别"><a href="#px-em-rem-的区别" class="headerlink" title="px em rem 的区别"></a>px em rem 的区别</h1><p><strong>px 像素，绝对单位。像素 px 是相对于显示器屏幕分辨率而言的，是一个虚拟的长度单位，是计算机系统的数字化图像长度单位，如果 px 要换算成物理长度单位，需要指定精度 DPI。</strong></p>
<p><strong>em 是相对长度单位，相当于当前对象内文本的字体尺寸，如果当前对行内文本的字体尺寸未被人设置，则是相对于浏览器默认字体尺寸。他会继承父级元素的字体大小，因此不是一个固定的值。</strong></p>
<p><strong>rem 是 css3 新增的一个相对长度单位，使用 rem 为元素设定字体大小时，相对于的是 HTML 根元素。</strong></p>
<p><strong>区别</strong></p>
<p>IE 无法调整那些使用 px 作为单位的字体大小，em 和 rem 可以缩放，rem 相对的只是 HTML 根元素。这个单位可谓集相对大小和绝对大小的优点与一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应，目前除了 IE8 及更早版本外，左右浏览器均以支持 rem。</p>
<h1 id="Set、Map、WeakSet-和-WeakMap-的区别？"><a href="#Set、Map、WeakSet-和-WeakMap-的区别？" class="headerlink" title="Set、Map、WeakSet 和 WeakMap 的区别？"></a>Set、Map、WeakSet 和 WeakMap 的区别？</h1><p>**1.Set **</p>
<p>本身是一种构造函数，用来生成 Set 数据结构。</p>
<p>Set 集合数据类型我们通常拿来做数组去重</p>
<p>(1) 成员不能重复元素<br>(2)只有键值对，没有键名，有点类似数组。<br>(3)可以遍历，方法有 add, delete,has.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 去重数组的重复对象</span><br><span class="line">let arr = [1, 2, 3, 2, 1, 1]</span><br><span class="line">[... new Set(arr)]	// [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>咋们如果打印 console.log(“数据类型”),就会发现他丰富的 api 和特性</p>
<p>最重要的</p>
<p>内嵌[[Entries]]私有特性,包含一个维护自身顺序的集合</p>
<p>add 方法用来增加元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setData = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">setData.<span class="title function_">add</span>(<span class="number">4</span>).<span class="title function_">add</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://pic1.zhimg.com/80/v2-82a4441f6fab0bfbf737e731bf35e8f4_720w.png" alt="img"></p>
<p>size 以及 has 用来查询数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setData = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">setData.<span class="title function_">add</span>(<span class="number">4</span>).<span class="title function_">add</span>(<span class="number">5</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Set的size===&gt;&#x27;</span>, setData.<span class="property">size</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Set的has方法===&gt;&#x27;</span>, setData.<span class="title function_">has</span>(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p><img src="https://pic4.zhimg.com/80/v2-c9c617c61dfe2f08012da96b35edad93_720w.jpg" alt="img"></p>
<p>clear 以及 delete 方法用于删除元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setData.<span class="title function_">delete</span>(<span class="number">5</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Set删除delete方法===&gt;&#x27;</span>, setData)</span><br><span class="line">setData.<span class="title function_">clear</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Set清空clear方法===&gt;&#x27;</span>, setData)</span><br></pre></td></tr></table></figure>

<p><img src="https://pic3.zhimg.com/80/v2-0b250b0c928d1f206222cf3018a228de_720w.png" alt="img"></p>
<p>自带一个以 values 方法为默认迭代的迭代器</p>
<p>既然有了迭代器,那么自然支持诸如 values,keys,entries 等方法</p>
<p>这些方法分别返回一个迭代器</p>
<p>可以用于 forof, 拓展运算符, Set, Map 等初始化</p>
<p>其中拓展运算符最常用,可以用来做去重</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrSet = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;利用Set去重数组==&gt;&#x27;</span>, [...<span class="keyword">new</span> <span class="title class_">Set</span>(arrSet)])</span><br></pre></td></tr></table></figure>

<p><img src="https://pic1.zhimg.com/80/v2-e22a10a23d17c29d0f0de8217656fde4_720w.png" alt="img"></p>
<hr>
<p>集合在日常开发中非常好用</p>
<p>不过还是很难满足我们对于操作对比数据时的要求</p>
<p>我们可以以 Set 为超类,继承 Set 已完善的属性和方法</p>
<p>在通过新增一下原型方法来拓展 Set 的功能</p>
<p>例如:</p>
<blockquote>
<p><strong>交集,并集,差集,对称差集等</strong></p>
</blockquote>
<p>**Map **</p>
<p>(1)成员都是对象<br>(2)成员都是弱引用，随时可以消失。可以用来保存 DOM 节点，不容易造成内存泄漏<br>(3)不能遍历，方法有 add, delete,has</p>
<ol>
<li>Set 和 Map 主要的应用场景在于 数据重组 和 数据储存<br>2.Set 是一种叫做集合的数据结构，Map 是一种叫做字典的数据结构</li>
</ol>
<p>**weakSet **</p>
<p>(1) 本质上是键值对的集合，类似集合<br>(2)可以遍历，方法很多，可以干跟各种数据格式转换</p>
<p>**weakMap **</p>
<p>(1)直接受对象作为键名（null 除外），不接受其他类型的值作为键名<br>(2)键名所指向的对象，不计入垃圾回收机制<br>(3)不能遍历，方法同 get,set,has,delete</p>
<h1 id="Vue-的发布订阅模式具体怎么实现？"><a href="#Vue-的发布订阅模式具体怎么实现？" class="headerlink" title="Vue 的发布订阅模式具体怎么实现？"></a>Vue 的发布订阅模式具体怎么实现？</h1><p>发布-订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都将得到通知。</p>
<h1 id="两个对象是否全等，为什么？"><a href="#两个对象是否全等，为什么？" class="headerlink" title="两个对象是否全等，为什么？"></a>两个对象是否全等，为什么？</h1><p>不全等，因为引用数据类型是被保存在堆内存中的，<br>即使值完全相等，他们在内存中的地址也是不同的。直接对比的话其实对比的是他们两个指向内存地址的指针，当然不同。</p>
<p><strong>如何判断两个对象是否值相等？</strong></p>
<p>判断对象相等的步骤：</p>
<p>先判断俩者是不是对象<br>是对象后俩者长度是否一致<br>判断俩个对象的所有 key 值是否相等相同<br>判断俩个对象的相应的 key 对应的值是否相同<br>来一个递归判断里面的对象循环 1-4 步骤<br>其实还有一种比较简单的对象是否相等的判断方式–JSON.stringify</p>
<h1 id="用户长时间不操作，token-过期怎么处理"><a href="#用户长时间不操作，token-过期怎么处理" class="headerlink" title="用户长时间不操作，token 过期怎么处理"></a>用户长时间不操作，token 过期怎么处理</h1><p>首先后端生成的 token 是有时限的,在一段时间后不管前端用户是否进行了访问后端的操作,后端的 token 都会过期,在拦截器阶段就会返回错误的请求:token 过期,从而拿不到想要的请求数据.</p>
<p>解决思路: 每隔一段时间的后端请求中都将 token 传送过去获取新的 token 并返回前端放入 cookies 中并记录 cookie 的存储失控,达到更新 cookie 中 token 的效果;而长时间不做操作的话我们就可以让他的 token 失效退出系统</p>
<h1 id="jsonp-的底层原理"><a href="#jsonp-的底层原理" class="headerlink" title="jsonp 的底层原理"></a>jsonp 的底层原理</h1><p>Jsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。</p>
<p>为什么我们从不同的域（网站）访问数据需要一个特殊的技术( JSONP )呢？这是因为同源策略。</p>
<p>同源策略，它是由 Netscape 提出的一个著名的安全策略，现在所有支持 JavaScript 的浏览器都会使用这个策略。</p>
<h1 id="React-面试题"><a href="#React-面试题" class="headerlink" title="React 面试题"></a>React 面试题</h1><h1 id="什么是-React"><a href="#什么是-React" class="headerlink" title="什么是 React"></a>什么是 React</h1><p>React 是一个简单的 javascript UI 库，用于构建高效、快速的用户界面。它是一个轻量级库，因此很受欢迎。它遵循组件设计模式、声明式编程范式和函数式编程概念，以使前端应用程序更高效。它使用虚拟 DOM 来有效地操作 DOM。它遵循从高阶组件到低阶组件的单向数据流。</p>
<h1 id="react-的生命周期"><a href="#react-的生命周期" class="headerlink" title="react 的生命周期"></a>react 的生命周期</h1><ol>
<li>挂载卸载过程<br>1.1.constructor()</li>
</ol>
<p>constructor()中完成了 React 数据的初始化，它接受两个参数：props 和 context，当想在函数内部使用这两个参数时，需使用 super()传入这两个参数。<br>注意：只要使用了 constructor()就必须写 super(),否则会导致 this 指向错误。</p>
<p>1.2.componentWillMount()<br>componentWillMount()一般用的比较少，它更多的是在服务端渲染时使用。它代表的过程是组件已经经历了 constructor()初始化数据后，但是还未渲染 DOM 时。</p>
<p>1.3.componentDidMount()<br>组件第一次渲染完成，此时 dom 节点已经生成，可以在这里调用 ajax 请求，返回数据 setState 后组件会重新渲染</p>
<p>1.4.componentWillUnmount ()<br>在此处完成组件的卸载和数据的销毁。</p>
<p>clear 你在组建中所有的 setTimeout,setInterval 移除所有组建中的监听 removeEventListener</p>
<ol start="2">
<li>更新过程</li>
</ol>
<p>2.1. componentWillReceiveProps (nextProps)<br>在接受父组件改变后的 props 需要重新渲染组件时用到的比较多<br>接受一个参数 nextProps<br>通过对比 nextProps 和 this.props，将 nextProps 的 state 为当前组件的 state，从而重新渲染组件</p>
<p>2.2.shouldComponentUpdate(nextProps,nextState)<br>主要用于性能优化(部分更新)<br>唯一用于控制组件重新渲染的生命周期，由于在 react 中，setState 以后，state 发生变化，组件会进入重新渲染的流程，在这里 return false 可以阻止组件的更新<br>因为 react 父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要所有子组件都跟着重新渲染的，因此需要在子组件的该生命周期中做判断</p>
<p>2.3.componentWillUpdate (nextProps,nextState)<br>shouldComponentUpdate 返回 true 以后，组件进入重新渲染的流程，进入 componentWillUpdate,这里同样可以拿到 nextProps 和 nextState。</p>
<p>2.4.componentDidUpdate(prevProps,prevState)<br>组件更新完毕后，react 只会在第一次初始化成功会进入 componentDidmount,之后每次重新渲染后都会进入这个生命周期，这里可以拿到 prevProps 和 prevState，即更新前的 props 和 state。</p>
<p>2.5.render()<br>render 函数会插入 jsx 生成的 dom 结构，react 会生成一份虚拟 dom 树，在每一次组件更新时，在此 react 会通过其 diff 算法比较更新前后的新旧 DOM 树，比较以后，找到最小的有差异的 DOM 节点，并重新渲染。</p>
<p>React 新增的生命周期</p>
<p>3.1. getDerivedStateFromProps(nextProps, prevState)<br>代替 componentWillReceiveProps()。<br>老版本中的 componentWillReceiveProps()方法判断前后两个 props 是否相同，如果不同再将新的 props 更新到相应的 state 上去。这样做一来会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。</p>
<p>这两者最大的不同就是在:<br>componentWillReceiveProps 中，我们一般会做以下两件事，一是根据 props 来更新 state，二是触发一些回调，如动画或页面跳转</p>
<p>3.2. getSnapshotBeforeUpdate(prevProps, prevState)<br>代替 componentWillUpdate。<br>常见的 componentWillUpdate 的用例是在组件更新前，读取当前某个 DOM 元素的状态，并在 componentDidUpdate 中进行相应的处理。</p>
<p>这两者的区别在于：<br>在 React 开启异步渲染模式后，在 render 阶段读取到的 DOM 元素状态并不总是和 commit 阶段相同,这就导致在<br>componentDidUpdate 中使用 componentWillUpdate 中读取到的 DOM 元素状态是不安全的,因为这时的值很有可能已经失效了。<br>getSnapshotBeforeUpdate 会在最终的 render 之前被调用，也就是说在 getSnapshotBeforeUpdate 中读取到的 DOM 元素状态是可以保证与 componentDidUpdate 中一致的。<br>此生命周期返回的任何值都将作为参数传递给 componentDidUpdate（）。</p>
<h1 id="react-中组件传值"><a href="#react-中组件传值" class="headerlink" title="react 中组件传值"></a>react 中组件传值</h1><p>父传子（组件嵌套浅）：父组件定义一个属性，子组件通过 this.props 接收。<br>可以使用 prop-types 来验证 props 的类型，设置默认值;</p>
<p>子传父：父组件定义一个属性，并将一个回调函数赋值给定义的属性，然后子组件进行调用传过来的函数， 并将参数传进去，在父组件的回调函数中即可获得子组件传过来的值。</p>
<p>兄弟组件传值: 1.通过状态提升原则，把状态定义到共同的父级组件里面，再通过子传父，父传子的形式来进行 2.通过发布订阅模式 封装类似于 vue 里面 bus 方式，$on,$emit 方法来进行传递跨级组件传值利用 context</p>
<h1 id="调用-setState-之后发生了什么？"><a href="#调用-setState-之后发生了什么？" class="headerlink" title="调用 setState 之后发生了什么？"></a>调用 setState 之后发生了什么？</h1><p>在代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程。</p>
<h1 id="React-中-keys-的作用是什么？"><a href="#React-中-keys-的作用是什么？" class="headerlink" title="React 中 keys 的作用是什么？"></a>React 中 keys 的作用是什么？</h1><p>react 为了提升渲染性能，在内部维持了一个虚拟 dom，当渲染结构有所变化的时候，会在虚拟 dom 中先用 diff 算法先进行一次对比，将所有的差异化解决之后，再一次性根据虚拟 dom 的变化，渲染到真实的 dom 结构中。</p>
<h1 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h1><p>声明式编程是一种编程范式，它关注的是你<strong>要做什么</strong>，而不是<strong>如何做</strong>。它表达逻辑而不显式地定义步骤。这意味着我们需要根据逻辑的计算来声明要显示的组件。它没有描述控制流步骤。声明式编程的例子有 HTML、SQL 等</p>
<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>函数式编程是声明式编程的一部分。javascript 中的函数是第一类公民，这意味着函数是数据，你可以像保存变量一样在应用程序中保存、检索和传递这些函数。</p>
<p>函数式编程有些核心的概念，如下：</p>
<ul>
<li>不可变性(Immutability)</li>
<li>纯函数(Pure Functions)</li>
<li>数据转换(Data Transformations)</li>
<li>高阶函数 (Higher-Order Functions)</li>
<li>递归</li>
<li>组合</li>
</ul>
<h1 id="不可变性-Immutability"><a href="#不可变性-Immutability" class="headerlink" title="不可变性(Immutability)"></a>不可变性(Immutability)</h1><p>不可变性意味着不可改变。 在函数式编程中，你无法更改数据，也不能更改。 如果要改变或更改数据，则必须复制数据副本来更改。</p>
<h1 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h1><p>纯函数是始终接受一个或多个参数并计算参数并返回数据或函数的函数。 它没有副作用，例如设置全局状态，更改应用程序状态，它总是将参数视为不可变数据。</p>
<p>我想使用 <strong>appendAddress</strong> 的函数向<code>student</code>对象添加一个地址。 如果使用非纯函数，它没有参数，直接更改 <code>student</code> 对象来更改全局状态。</p>
<p>使用纯函数，它接受参数，基于参数计算，返回一个新对象而不修改参数。</p>
<h1 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h1><p>我们讲了很多关于不可变性的内容，如果数据是不可变的，我们如何改变数据。如上所述，我们总是生成原始数据的转换副本，而不是直接更改原始数据。</p>
<p>再介绍一些 javascript 内置函数，当然还有很多其他的函数，这里有一些例子。所有这些函数都不改变现有的数据，而是返回新的数组或对象。</p>
<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>高阶函数是将函数作为参数或返回函数的函数，或者有时它们都有。 这些高阶函数可以操纵其他函数。</p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归是一种函数在满足一定条件之前调用自身的技术。只要可能，最好使用递归而不是循环。浏览器不能处理太多递归和抛出错误。</p>
<h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><p>在 React 中，我们将功能划分为小型可重用的纯函数，我们必须将所有这些可重用的函数放在一起，最终使其成为产品。 将所有较小的函数组合成更大的函数，最终，得到一个应用程序，这称为<strong>组合</strong>。</p>
<p>实现组合有许多不同方法。 我们从 Javascript 中了解到的一种常见方法是链接。 链接是一种使用<strong>点</strong>表示法调用前一个函数的返回值的函数的方法。</p>
<h1 id="React-与-Angular-有何不同？"><a href="#React-与-Angular-有何不同？" class="headerlink" title="React 与 Angular 有何不同？"></a>React 与 Angular 有何不同？</h1><p>Angular 是一个成熟的 MVC 框架，带有很多特定的特性，比如服务、指令、模板、模块、解析器等等。React 是一个非常轻量级的库，它只关注 MVC 的视图部分。</p>
<p>Angular 遵循两个方向的数据流，而 React 遵循从上到下的单向数据流。React 在开发特性时给了开发人员很大的自由，例如，调用 API 的方式、路由等等。我们不需要包括路由器库，除非我们需要它在我们的项目</p>
<h1 id="Virtual-DOM-及其工作原理"><a href="#Virtual-DOM-及其工作原理" class="headerlink" title="Virtual DOM 及其工作原理"></a>Virtual DOM 及其工作原理</h1><p>React 使用 Virtual DOM 来更新真正的 DOM，从而提高效率和速度, 浏览器遵循 HTML 指令来构造文档对象模型(DOM)。当浏览器加载 HTML 并呈现用户界面时，HTML 文档中的所有元素都变成 DOM 元素。</p>
<h1 id="虚拟-DOM-是如何工作的"><a href="#虚拟-DOM-是如何工作的" class="headerlink" title="虚拟 DOM 是如何工作的"></a>虚拟 DOM 是如何工作的</h1><p>虚拟 DOM 只不过是真实 DOM 的 javascript 对象表示。 与更新真实 DOM 相比，更新 javascript 对象更容易，更快捷。</p>
<p>React 将整个 DOM 副本保存为虚拟 DOM ,每当有更新时，它都会维护两个虚拟 DOM，以比较之前的状态和当前状态，并确定哪些对象已被更改。 它通过比较两个虚拟 DOM 差异，并将这些变化更新到实际 DOM , 一旦真正的 DOM 更新，它也会更新 UI</p>
<h1 id="什么是-JSX"><a href="#什么是-JSX" class="headerlink" title="什么是 JSX"></a><strong>什么是 JSX</strong></h1><p>JSX 是 javascript 的语法扩展。它就像一个拥有 javascript 全部功能的模板语言。它生成 React 元素，这些元素将在 DOM 中呈现。React 建议在组件使用 JSX。在 JSX 中，我们结合了 javascript 和 HTML，并生成了可以在 DOM 中呈现的 react 元素。</p>
<h1 id="组件和不同类型"><a href="#组件和不同类型" class="headerlink" title="组件和不同类型"></a>组件和不同类型</h1><p>React 中一切都是组件。 我们通常将应用程序的整个逻辑分解为小的单个部分。 我们将每个单独的部分称为组件。 通常，组件是一个 javascript 函数，它接受输入，处理它并返回在 UI 中呈现的 React 元素。</p>
<p><strong>函数&#x2F;无状态&#x2F;展示组件</strong></p>
<p>函数或无状态组件是一个纯函数，它可接受接受参数，并返回 react 元素。这些都是没有任何副作用的纯函数。这些组件没有状态或生命周期方法，</p>
<p><strong>类&#x2F;有状态组件</strong></p>
<p>类或有状态组件具有状态和生命周期方可能通过<code>setState()</code>方法更改组件的状态。类组件是通过扩展 React 创建的。它在构造函数中初始化，也可能有子组件,</p>
<p><strong>受控组件</strong></p>
<p>受控组件是在 React 中处理输入表单的一种技术。表单元素通常维护它们自己的状态，而 react 则在组件的状态属性中维护状态。我们可以将两者结合起来控制输入表单。这称为受控组件。因此，在受控组件表单中，数据由 React 组件处理。</p>
<p><strong>非受控组件</strong></p>
<p>大多数情况下，建议使用受控组件。有一种称为非受控组件的方法可以通过使用<code>Ref</code>来处理表单数据。在非受控组件中，<code>Ref</code>用于直接从<code>DOM</code>访问表单值，而不是事件处理程序。</p>
<p><strong>容器组件</strong></p>
<p>容器组件是处理获取数据、订阅 redux 存储等的组件。它们包含展示组件和其他容器组件，但是里面从来没有 html。</p>
<p><strong>高阶组件</strong></p>
<p>高阶组件是将组件作为参数并生成另一个组件的组件。 Redux <code>connect</code>是高阶组件的示例。 这是一种用于生成可重用组件的强大技术。</p>
<h1 id="Props-和-State"><a href="#Props-和-State" class="headerlink" title="Props 和 State"></a>Props 和 State</h1><p><strong>Props</strong> 是只读属性，传递给组件以呈现 UI 和状态，我们可以随时间更改组件的输出。</p>
<p>在构造函数中定义了**<code>props**</code>和<code>**state**</code>，每当使用<code>this.setState()</code>修改状态时，将再次调用<code>render( )</code> 函数来更改 UI 中组件的输出。</p>
<h1 id="什么是-PropTypes"><a href="#什么是-PropTypes" class="headerlink" title="什么是 PropTypes"></a>什么是 PropTypes</h1><p>随着时间的推移，应用程序会变得越来越大，因此类型检查非常重要。<code>PropTypes</code>为组件提供类型检查，并为其他开发人员提供很好的文档。如果 react 项目不使用 Typescript，建议为组件添加 <code>PropTypes</code>。</p>
<p>如果组件没有收到任何 props，我们还可以为每个组件定义要显示的默认 props。这里有一个例子。<code>UserDisplay</code>有三个 prop:<code>name</code>、<code>address</code>和<code>age</code>，我们正在为它们定义默认的 props 和 prop 类型。</p>
<h1 id="如何更新状态以及如何不更新"><a href="#如何更新状态以及如何不更新" class="headerlink" title="如何更新状态以及如何不更新"></a>如何更新状态以及如何不更新</h1><p>可以在构造函数中定义状态值。直接使用状态不会触发重新渲染。React 使用<code>this.setState()</code>时合并状态。</p>
<h1 id="如何在-React-中应用样式"><a href="#如何在-React-中应用样式" class="headerlink" title="如何在 React 中应用样式"></a>如何在 React 中应用样式</h1><p><strong>外部样式表</strong></p>
<p><strong>内联样式</strong></p>
<p><strong>定义样式对象并使用它</strong>:</p>
<p>将 javascript 对象传递给<code>style</code>属性，所以我们可以在组件中定义一个<code>style</code>对象并使用它</p>
<h1 id="Redux-及其工作原理"><a href="#Redux-及其工作原理" class="headerlink" title="Redux 及其工作原理"></a>Redux 及其工作原理</h1><p>Redux 是 React 的一个状态管理库，它基于 flux。 Redux 简化了 React 中的单向数据流。 Redux 将状态管理完全从 React 中抽象出来。</p>
<p>在 React 中，组件连接到 redux ，如果要访问 redux，需要派出一个包含 <code>id</code>和负载(payload) 的 <code>action</code>。action 中的 <code>payload</code> 是可选的，action 将其转发给 Reducer。</p>
<p>当<code>reducer</code>收到<code>action</code>时，通过 <code>switch...case</code> 语法比较 <code>action</code> 中<code>type</code>。 匹配时，更新对应的内容返回新的 <code>state</code>。</p>
<p>当<code>Redux</code>状态更改时，连接到<code>Redux</code>的组件将接收新的状态作为<code>props</code>。当组件接收到这些<code>props</code>时，它将进入更新阶段并重新渲染 UI。</p>
<p><strong>Action</strong>: Action 只是一个简单的 json 对象，<strong>type</strong> 和有<strong>payload</strong>作为键。<strong>type</strong> 是必须要有的，<strong>payload</strong>是可选的</p>
<p><strong>Action Creators</strong>：这些是创建<code>Actions</code>的函数，因此我们在派发<code>action</code>时不必在组件中手动编写每个 <code>action</code></p>
<p><strong>Reducers</strong>：Reducers 是纯函数，它将 <code>action</code>和当前 <code>state</code> 作为参数,计算必要的逻辑并返回一个新的<code>state</code>。 这些 Reducers 没有任何副作用。 它不会改变 <code>state</code> 而是总是返回 <code>state</code> 。</p>
<h1 id="使用-redux-对详情页面进行数据管理"><a href="#使用-redux-对详情页面进行数据管理" class="headerlink" title="使用 redux 对详情页面进行数据管理"></a>使用 redux 对详情页面进行数据管理</h1><p>需要使用 store 进行数据管理</p>
<p>创建文件夹</p>
<p>引入文件导出</p>
<p>在 redcuer 中，我们定义一些数据</p>
<p>然后我们需要在总的 src 目录下的 reducer 中，我们需要加入 detail 目录下的 reducer</p>
<p>在 detail 目录下的 index 中，我们需要发送请求修改数据，并且接收 store 进行处理的数据</p>
<ul>
<li>首先我们需要使用 react-redux 这个中间件</li>
<li>然后我们使用 mapState 这个方法接收从 reducer 中传递过来的数据</li>
<li>在我们的自定义标签中使用接收到的数据进行页面的渲染</li>
</ul>
<h1 id="组件如何与-redux-进行连接"><a href="#组件如何与-redux-进行连接" class="headerlink" title="组件如何与 redux 进行连接"></a>组件如何与 redux 进行连接</h1><p><strong>mapStateToProps</strong>：此函数将<code>state</code>映射到 <code>props</code> 上，因此只要<code>state</code>发生变化，新 state 会重新映射到 <code>props</code>。 这是订阅<code>store</code>的方式。</p>
<p><strong>mapDispatchToProps</strong>：此函数用于将 <code>action creators</code> 绑定到你的<code>props</code> 。</p>
<p><strong>connect</strong><code>和</code><strong>bindActionCreators</strong>来自 redux。 前者用于连接 store ， 后者用于将 action creators 绑定到你的 <code>props</code></p>
<h1 id="什么是-React-Router-Dom-及其工作原理"><a href="#什么是-React-Router-Dom-及其工作原理" class="headerlink" title="什么是 React Router Dom 及其工作原理"></a>什么是 React Router Dom 及其工作原理</h1><p><code>react-router-dom</code>是应用程序中路由的库。 React 库中没有路由功能，需要单独安装<code>react-router-dom</code>。</p>
<p>react-router-dom 提供两个路由器<code>BrowserRouter</code>和<code>HashRoauter</code>。前者基于 url 的 pathname 段，后者基于 hash 段。</p>
<p><strong>react-router-dom 组件</strong></p>
<ul>
<li><code>BrowserRouter</code> 和 <code>HashRouter</code> 是路由器。</li>
<li><code>Route</code> 用于路由匹配。</li>
<li><code>Link</code> 组件用于在应用程序中创建链接。 它将在 HTML 中渲染为锚标记。</li>
<li><code>NavLink</code>是突出显示当前活动链接的特殊链接。</li>
<li><code>Switch</code> 不是必需的，但在组合路由时很有用。</li>
<li><code>Redirect</code> 用于强制路由重定向</li>
</ul>
<h1 id="什么是错误边界"><a href="#什么是错误边界" class="headerlink" title="什么是错误边界"></a>什么是错误边界</h1><p>在 React 中，我们通常有一个组件树。如果任何一个组件发生错误，它将破坏整个组件树。没有办法捕捉这些错误，我们可以用错误边界优雅地处理这些错误。</p>
<p>错误边界有两个作用</p>
<ul>
<li>如果发生错误，显示回退 UI</li>
<li>记录错误</li>
</ul>
<h1 id="什么是-Fragments"><a href="#什么是-Fragments" class="headerlink" title="什么是 Fragments"></a>什么是 Fragments</h1><p>在 React 中，我们需要有一个父元素，同时从组件返回 React 元素。有时在 DOM 中添加额外的节点会很烦人。使用 <strong>Fragments</strong>，我们不需要在 DOM 中添加额外的节点。我们只需要用 <code>React.Fragment</code> 或才简写 <code>&lt;&gt;</code> 来包裹内容就行了</p>
<h1 id="什么是传送门-Portals"><a href="#什么是传送门-Portals" class="headerlink" title="什么是传送门(Portals)"></a>什么是传送门(Portals)</h1><p>默认情况下，所有子组件都在 UI 上呈现，具体取决于组件层次结构。Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。</p>
<h1 id="什么是上下文"><a href="#什么是上下文" class="headerlink" title="什么是上下文"></a>什么是上下文</h1><p>有时我们必须将<code>props</code> 传递给组件树，即使所有中间组件都不需要这些<code>props</code> 。上下文是一种传递<code>props</code> 的方法，而不用在每一层传递组件树。</p>
<h1 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h1><p>Hooks 是 React 版本 16.8 中的新功能。我们不能在函数组件中使用<code>state</code> ，因为它们不是类组件。Hooks 让我们在函数组件中可以使用 state 和其他功能。</p>
<p>Hook 为 React 提供了更直接的 API：props， state，context，refs 以及 componentDitMount 和 componentDidUpdate 等生命周期方法。Hooks 不会替换类,他们只是一个你可以使用的工具</p>
<p><strong>Hooks 的基本规则</strong></p>
<ul>
<li>Hooks 应该在外层使用，不应该在循环，条件或嵌套函数中使用</li>
<li>Hooks 应该只在函数组件中使用。</li>
</ul>
<p><strong>useState</strong><code> useState是react自带的一个hooknnn函数，它的作用就是用来声明状态变量。 返回两个项，一个是</code>user<code>，另一个是</code>setUser<code>函数。 </code>user<code>是一个可以在没有</code>this&#96;关键字的情况下直接使用的对象，</p>
<p><strong>useEffect</strong>: useEffect 用于处理大多数副作用，其中的回调函数会在 render 执行之后在调用，确保不会阻止浏览器的渲染，这跟 componentDidMount 和 componentDidUpdate 是不一样的，他们会在渲染之后同步执行。为什么第二个参数是空数组，相当于 componentDidMount ？</p>
<p><strong>因为依赖一直不变化，callback 不会二次执行。</strong></p>
<p><strong>useLayoutEffect</strong>: 在大多数情况下，我们都可以使用 useEffect 处理副作用，但是，如果副作用是跟 DOM 相关的，就需要使用 useLayoutEffect。useLayoutEffect 中的副作用会在 DOM 更新之后同步执行</p>
<p><strong>useReducer</strong>: 用来简单替代 redux 做状态管理， 接收两个参数，一个是 reducer 函数，跟 redux 中的 reducer 是一样的；另外一个是初始的状态值。返回的是一个数组，数组中的第一个元素是状态值，第二个元素是 dispatch 函数，你可以调用 dispatch 函数，来触发 state 的更新。</p>
<p>**useRef:**使用 class 组件，其中一个很重要的点事有时候我们需要获取某个组件或 DOM 节点的引用，借助 useRef，我们可以在函数组件中获取组件或 DOM 节点的引用：</p>
<p><strong>useContext()</strong>:配合<code>React.createContext(&#123;&#125;)</code>使用，在组件间的共享状态</p>
<p><strong>effectHooks</strong>:让我们可以在函数组件内使用生命周期方法，我们可以在这里更新 DOM，获取数据等具有’副作用’的行为。effect Hook 会在组件每次 render 后执行,ruturn 的函数会在组件卸载时执行，若要让 effect hook 只在组件首次加载时执行，可以传入一个空数组作为第二个参数,也可以在数组中指定依赖项，只有依赖项改变时，effectHooks 才会执行。</p>
<p><strong>Custom Hooks</strong>:自定义 Hook 是一个以’use’开头的 javascript 函数，可以调用其他的 Hooks，从而进行逻辑封装，复用代码。</p>
<p><strong>Hooks 的使用有两个原则</strong>：</p>
<ol>
<li>不要在循环，条件判断，函数嵌套中使用 hooks</li>
<li>只能在函数组件中使用 hooks</li>
</ol>
<p>react 的核心思想就是，将一个页面拆成一堆独立的，可复用的组件，并且用自上而下的单向数据流的形式将这些组件串联起来。</p>
<h1 id="如何提高性能"><a href="#如何提高性能" class="headerlink" title="如何提高性能"></a>如何提高性能</h1><p>我们可以通过多种方式提高应用性能，以下这些比较重要：</p>
<ul>
<li>适当地使用<code>shouldComponentUpdate</code>生命周期方法。 它避免了子组件的不必要的渲染。 如果树中有 100 个组件，则不重新渲染整个组件树来提高应用程序性能。</li>
<li>使用<code>create-react-app</code>来构建项目，这会创建整个项目结构，并进行大量优化。</li>
<li>不可变性是提高性能的关键。不要对数据进行修改，而是始终在现有集合的基础上创建新的集合，以保持尽可能少的复制，从而提高性能。</li>
<li>在显示列表或表格时始终使用 <code>Keys</code>，这会让 React 的更新速度更快</li>
<li>代码分离是将代码插入到单独的文件中，只加载模块或部分所需的文件的技术。</li>
</ul>
<h1 id="如何在重新加载页面时保留数据"><a href="#如何在重新加载页面时保留数据" class="headerlink" title="如何在重新加载页面时保留数据"></a>如何在重新加载页面时保留数据</h1><p>单页应用程序首先在 DOM 中加载<code>index.html</code>，然后在用户浏览页面时加载内容，或者从同一<code>index.html</code>中的后端 API 获取任何数据。</p>
<p>如果通过点击浏览器中的重新加载按钮重新加载页面<code>index.html</code>，整个 React 应用程序将重新加载，我们将丢失应用程序的状态。 如何保留应用状态？</p>
<p>每当重新加载应用程序时，我们使用浏览器<code>localstorage</code>来保存应用程序的状态。我们将整个存储数据保存在<code>localstorage</code>中，每当有页面刷新或重新加载时，我们从<code>localstorage</code>加载状态。</p>
<h1 id="如何在-React-进行-API-调用"><a href="#如何在-React-进行-API-调用" class="headerlink" title="如何在 React 进行 API 调用"></a>如何在 React 进行 API 调用</h1><p>我们使用<code>redux-thunk</code>在 React 中调用 API。因为<code>reduce</code>是纯函数，所以没有副作用，比如调用 API。</p>
<p>因此，我们必须使用<code>redux-thunk</code>从 action creators 那里进行 API 调用。Action creator 派发一个 action，将来自 API 的数据放入 action 的 <code>payload</code> 中。Reducers 接收我们在上面的<code>redux</code>循环中讨论的数据，其余的过程也是相同的。 redux-thunk 是一个中间件。一旦它被引入到项目中，每次派发一个<code>action</code>时，都会通过<code>thunk</code>传递。如果它是一个函数，它只是等待函数处理并返回响应。如果它不是一个函数，它只是正常处理。</p>
<h1 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h1><p><code>npm install--save redux-saga</code></p>
<p>redux-saga 是一个用于管理应用程序 Side Effect（副作用，例如异步获取数据，访问浏览器缓存等）的 library，它的目标是让副作用管理更容易，执行更高效，测试更简单，在处理故障时更容易。 redux-saga 通过创建 <em>Sagas</em> 将所有的异步操作逻辑收集在一个地方集中处理，可以用来代替 <code>redux-thunk</code> 中间件。</p>
<p>Sagas 是通过 Generator 函数来创建的 , es6 Generator,解决地狱回调问题，通过 yield 关键字，可以让函数的执行流挂起</p>
<p>Sagas 不同于 Thunks，Thunks 是在 action 被创建时调用，而 Sagas 只会在应用启动时调用。<br>Sagas 可以被看作是在后台运行的进程。Sagas 监听发起的 action，然后决定基于这个 action 来做什么：是发起一个异步调用（比如一个 Ajax 请求），还是发起其他的 action 到 Store，甚至是调用其他的 Sagas。</p>
<p>在 <code>redux-saga</code> 的世界里，所有的任务都通用 yield <strong>Effects</strong> 来完成。Effects 都是简单的 Javascript 对象，包含了要被 Saga middleware 执行的信息<br><code>redux-saga</code> 为各项任务提供了各种 Effect 创建器，比如调用一个异步函数，发起一个 action 到 Store，启动一个后台任务或者等待一个满足某些条件的未来的 action。</p>
<p>因为使用了 Generator，<code>redux-saga</code> 让你可以用同步的方式写异步代码。就像你可以使用 <code>async/await</code> 函数所能做的一样。但 Generator 可以让你做一些 <code>async</code> 函数做不到的事情。</p>
<p>事实上 Sagas yield 普通对象的方式让你能容易地测试 Generator 里所有的业务逻辑，可以通过简单地迭代 yield 过的对象进行简单的单元测试。</p>
<p>此外，<code>redux-saga</code> 启动的任务可以在任何时候通过手动取消，也可以把任务和其他的 Effects 放到 race 方法里以自动取消。</p>
<p><strong>区别 yield*和 yield</strong></p>
<p>yield***<strong>是委托提取器。yield 是你给什么他就提取什么,但是 yield</strong>***会继续向下请求,直到没有提取的为止</p>
<p><strong>简单理解 ‘redux-saga&#x2F;effects’ 中的几个关键字：fork，call， put，takeEvery，takeLatest，all</strong></p>
<p>1、fork:创建一个新的进程或者线程,并发送请求</p>
<p>2、call:发送 api 请求</p>
<p>3、put:发送对应的 dispatch,触发对应的 action</p>
<p>4、takeEvery:</p>
<ul>
<li>监听对应的 action；</li>
<li>每一次 dispatch 都会触发；例如：点击一个新增的按钮，2s 后触发新增动作，在 2s 内不断点击按钮，这时候，每一次点击，都是有效的。</li>
</ul>
<p>5、takeLatest:</p>
<ul>
<li>监听对应的 action；</li>
<li>只会触发最后一次 dispatch；例如：点击一个新增的按钮，2s 后触发新增动作，在 2s 内不断点击按钮，这时候，只有最后一次点击是有效的。</li>
</ul>
<p>6、 all:跟 fork 一样，同时并发多个 action，没有顺序。</p>
<h1 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h1><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同</p>
<p><strong>yield 语句</strong></p>
<p>Generator 函数返回的遍历器对象，yield 语句暂停，调用 next 方法恢复执行，如果没遇到新的 yeild，一直运行到 return 语句为止，return 后面表达式的值作为返回对象的 value 值，如果没有 return 语句，一直运行到结束，返回对象的 value 为 undefined.</p>
<h1 id="dva"><a href="#dva" class="headerlink" title="dva"></a>dva</h1><p><code>npm install dva-cli -g</code></p>
<p>dva 首先是一个基于 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/reduxjs/redux">redux</a> 和 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/redux-saga/redux-saga">redux-saga</a> 的数据流方案，然后为了简化开发体验，dva 还额外内置了 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/ReactTraining/react-router">react-router</a> 和 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/github/fetch">fetch</a>，所以也可以理解为一个轻量级的应用框架</p>
<p><code>dva</code> 通过 <code>model</code> 的概念把一个领域的模型管理起来，包含同步更新 <code>state</code> 的 <code>reducers</code>，处理异步逻辑的 <code>effects</code>，订阅数据源的 <code>subscriptions</code></p>
<ul>
<li><p>namespace: 表示在全局 state 上的 key</p>
</li>
<li><p>state: 初始值，这里设置为空数组</p>
</li>
<li><p>reducers: 等同于 redux 里的 reducer，接收 action，同步更新 state</p>
<p><strong>为什么要使用 dva 库, 说说我的看法: dva 库集成了大部分 react 开发中经常会使用到的一些库方法，通过 dva 进行一层浅封装，使得我们可以不用去安装很多的第三方库，统一从 dva 中进行导出使用，dva 进行统一管理，开发体验会更好</strong>。</p>
</li>
</ul>
<h1 id="umi-乌米"><a href="#umi-乌米" class="headerlink" title="umi(乌米)"></a>umi(乌米)</h1><p>umi 是蚂蚁金服的底层前端框架， 是一个可插拔的企业级 react 应用框架。umi 以路由为基础的，支持<a target="_blank" rel="noopener" href="https://umijs.org/zh/guide/router.html">类 next.js 的约定式路由</a>，以及各种进阶的路由功能，并以此进行功能扩展，比如<a target="_blank" rel="noopener" href="https://umijs.org/zh/plugin/umi-plugin-react.html#dynamicimport">支持路由级的按需加载</a>。</p>
<p><strong>特性</strong></p>
<ul>
<li><strong>开箱即用</strong>，内置 react、react-router 等</li>
<li><strong>类 next.js 且<a target="_blank" rel="noopener" href="https://umijs.org/zh/guide/router.html">功能完备</a>的路由约定</strong>，同时支持配置的路由方式</li>
<li><strong>完善的插件体系</strong>，覆盖从源码到构建产物的每个生命周期</li>
<li><strong>高性能</strong>，通过插件支持 PWA、以路由为单元的 code splitting 等</li>
<li><strong>支持静态页面导出</strong>，适配各种环境，比如中台业务、无线业务、<a target="_blank" rel="noopener" href="https://github.com/eggjs/egg">egg</a>、支付宝钱包、云凤蝶等</li>
<li><strong>开发启动快</strong>，支持一键开启 <a target="_blank" rel="noopener" href="https://umijs.org/zh/plugin/umi-plugin-react.html#dll">dll</a> 等</li>
<li><strong>一键兼容到 IE9</strong>，基于 <a target="_blank" rel="noopener" href="https://umijs.org/zh/plugin/umi-plugin-react.html#polyfills">umi-plugin-polyfills</a></li>
<li><strong>完善的 TypeScript 支持</strong>，包括 d.ts 定义和 umi test</li>
<li><strong>与 <a target="_blank" rel="noopener" href="https://dvajs.com/">dva</a> 数据流的深入融合</strong>，支持 duck directory、model 的自动加载、code splitting 等等</li>
</ul>
<p><strong>他和 dva、roadhog 是什么关系？</strong></p>
<p>简单来说，</p>
<ul>
<li>roadhog 是基于 webpack 的封装工具，目的是简化 webpack 的配置</li>
<li>umi 可以简单地理解为 roadhog + 路由，思路类似 next.js&#x2F;nuxt.js，辅以一套插件机制，目的是通过框架的方式简化 React 开发</li>
<li>dva 目前是纯粹的数据流，和 umi 以及 roadhog 之间并没有相互的依赖关系，可以分开使用也可以一起使用，个人觉得 <a target="_blank" rel="noopener" href="https://github.com/sorrycc/blog/issues/66">umi + dva 是比较搭的</a></li>
</ul>
<p><strong>next.js</strong></p>
<p>next.js 的功能相对比较简单，比如他的路由配置并不支持一些高级的用法，比如布局、嵌套路由、权限路由等等，而这些在企业级的应用中是很常见的。相比 next.js，umi 在约定式路由的功能层面会更像 nuxt.js 一些。</p>
<p><strong>roadhog</strong></p>
<p>roadhog 是比较纯粹的 webpack 封装工具，作为一个工具，他能做的就比较有限（限于 webpack 层）。而 umi 则等于 roadhog + 路由 + HTML 生成 + 完善的插件机制，所以能在提升开发者效率方面发挥出更大的价值。</p>
<h1 id="H5-新特性"><a href="#H5-新特性" class="headerlink" title="H5 新特性"></a>H5 新特性</h1><ol>
<li>语义化标签：header、footer、section、nav、aside、article</li>
<li>增强型表单：input 的多个 type</li>
<li>新增表单元素：datalist、keygen、output</li>
<li>新增表单属性：placehoder、required、min 和 max</li>
<li>音频视频：audio、video</li>
<li>canvas</li>
<li>地理定位</li>
<li>拖拽</li>
<li>本地存储：localStorage - 没有时间限制的数据存储；sessionStorage - 针对一个 session 的数据存储，当用户关闭浏览器窗口后，数据会被删除</li>
<li>新事件：onresize、ondrag、onscroll、onmousewheel、onerror、onplay、onpause</li>
<li>WebSocket：单个 TCP 连接上进行全双工通讯的协议</li>
</ol>
<p><strong>语义化标签</strong></p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>header</td>
<td>定义了文档的头部区域</td>
</tr>
<tr>
<td>footer</td>
<td>定义了文档的尾部区域</td>
</tr>
<tr>
<td>nav</td>
<td>定义文档的导航</td>
</tr>
<tr>
<td>section</td>
<td>定义文档中的节（section、区段）</td>
</tr>
<tr>
<td>article</td>
<td>定义页面独立的内容区域</td>
</tr>
<tr>
<td>aside</td>
<td>定义页面的侧边栏内容</td>
</tr>
<tr>
<td>detailes</td>
<td>用于描述文档或文档某个部分的细节</td>
</tr>
<tr>
<td>summary</td>
<td>标签包含 details 元素的标题</td>
</tr>
<tr>
<td>dialog</td>
<td>定义对话框，比如提示框</td>
</tr>
</tbody></table>
<p><strong>增强型表单</strong></p>
<p>HTML5 拥有多个新的表单 Input 输入类型。这些新特性提供了更好的输入控制和验证</p>
<table>
<thead>
<tr>
<th>input 的 type</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>主要用于选取颜色</td>
</tr>
<tr>
<td>date</td>
<td>从一个日期选择器选择一个日期</td>
</tr>
<tr>
<td>datetime</td>
<td>选择一个日期（UTC 时间）</td>
</tr>
<tr>
<td>email</td>
<td>包含 e-mail 地址的输入域</td>
</tr>
<tr>
<td>month</td>
<td>选择一个月份</td>
</tr>
<tr>
<td>number</td>
<td>数值的输入域</td>
</tr>
<tr>
<td>range</td>
<td>一定范围内数字值的输入域</td>
</tr>
<tr>
<td>search</td>
<td>用于搜索域</td>
</tr>
<tr>
<td>tel</td>
<td>定义输入电话号码字段</td>
</tr>
<tr>
<td>time</td>
<td>选择一个时间</td>
</tr>
<tr>
<td>url</td>
<td>URL 地址的输入域</td>
</tr>
<tr>
<td>week</td>
<td>选择周和年</td>
</tr>
</tbody></table>
<p><strong>html5 也新增以下表单元素</strong></p>
<table>
<thead>
<tr>
<th>表单元素</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>datalist</td>
<td>元素规定输入域的选项列表，使用 input 元素的 list 属性与 datalist 元素的 id 绑定</td>
</tr>
<tr>
<td>keygen</td>
<td>提供一种验证用户的可靠方法，标签规定用于表单的密钥对生成器字段</td>
</tr>
<tr>
<td>output</td>
<td>用于不同类型的输出，比如计算或脚本输出</td>
</tr>
</tbody></table>
<p><strong>html5 新增的表单属性</strong></p>
<table>
<thead>
<tr>
<th>表单属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>placehoder</td>
<td>简短的提示在用户输入值前会显示在输入域上。即我们常见的输入框默认提示，在用户输入后消失</td>
</tr>
<tr>
<td>required</td>
<td>是一个 boolean 属性。要求填写的输入域不能为空</td>
</tr>
<tr>
<td>pattern</td>
<td>描述了一个正则表达式用于验证 input 元素的值</td>
</tr>
<tr>
<td>min 和 max</td>
<td>设置元素最小值与最大值</td>
</tr>
<tr>
<td>step</td>
<td>为输入域规定合法的数字间隔</td>
</tr>
<tr>
<td>height 和 width</td>
<td>用于 image 类型的 input 标签的图像高度和宽度</td>
</tr>
<tr>
<td>autofocus</td>
<td>是一个 boolean 属性。规定在页面加载时，域自动地获得焦点</td>
</tr>
<tr>
<td>multiple</td>
<td>是一个 boolean 属性。规定 input 元素中可选择多个值</td>
</tr>
</tbody></table>
<p><strong>html5 新事件</strong></p>
<table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>onresize</td>
<td>当调整窗口大小时运行脚本</td>
</tr>
<tr>
<td>ondrag</td>
<td>当拖动元素时运行脚本</td>
</tr>
<tr>
<td>onscroll</td>
<td>当滚动元素滚动元素的滚动条时运行脚本</td>
</tr>
<tr>
<td>onmousewheel</td>
<td>当转动鼠标滚轮时运行脚本</td>
</tr>
<tr>
<td>onerror</td>
<td>当错误发生时运行脚本</td>
</tr>
<tr>
<td>onplay</td>
<td>当媒介数据将要开始播放时运行脚本</td>
</tr>
<tr>
<td>onpause</td>
<td>当媒介数据暂停时运行脚本</td>
</tr>
</tbody></table>
<ul>
<li>块级元素<br>div、p、h1~h6、ul、ol、dl、li、dd、table、hr、blockquote、address、table、menu、pre，HTML5 新增的 header、section、aside、footer 等</li>
<li>行内元素<br>pan、img、a、lable、input、abbr（缩写）、em（强调）、big、cite（引用）、i（斜体）、q（短引用）、textarea、select、small、sub、sup，strong、u（下划线）、button</li>
</ul>
<h1 id="CSS3-新特性"><a href="#CSS3-新特性" class="headerlink" title="CSS3 新特性"></a>CSS3 新特性</h1><ol>
<li>选择器</li>
<li>背景和边框</li>
<li>文本效果</li>
<li>2D&#x2F;3D 转换</li>
<li>动画、过渡</li>
<li>多列布局</li>
<li>用户界面</li>
</ol>
<p><strong>选择器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">:last-child /* 选择元素最后一个孩子 */</span><br><span class="line">:first-child /* 选择元素第一个孩子 */</span><br><span class="line">:nth-child(1) /* 按照第几个孩子给它设置样式 */</span><br><span class="line">:nth-child(even) /* 按照偶数 */</span><br><span class="line">:nth-child(odd)  /* 按照奇数 */</span><br><span class="line">:disabled /* 选择每个禁用的E元素 */</span><br><span class="line">:checked /* 选择每个被选中的E元素 */</span><br><span class="line">:not(selector) /* 选择非 selector 元素的每个元素 */</span><br><span class="line">::selection /* 选择被用户选取的元素部分 */</span><br></pre></td></tr></table></figure>

<p><strong>伪类和伪元素：</strong></p>
<blockquote>
<p>根本区别在于它们是否创造了新的元素（抽象）</p>
</blockquote>
<ul>
<li>伪类：用于向某些选择器添加特殊的效果（没有创建新元素）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:last-child /* 选择元素最后一个孩子 */</span><br><span class="line">:first-child /* 选择元素第一个孩子 */</span><br><span class="line">:nth-child(1) /* 按照第几个孩子给它设置样式 */</span><br><span class="line">a:link &#123;color: #FF0000&#125; /* 未访问的链接 */</span><br><span class="line">a:visited &#123;color: #00FF00&#125; /* 已访问的链接 */</span><br><span class="line">a:hover &#123;color: #FF00FF&#125; /* 鼠标移动到链接上 */</span><br><span class="line">a:active &#123;color: #0000FF&#125; /* 选定的链接 */</span><br></pre></td></tr></table></figure>

<ul>
<li>伪元素：创建了 html 中不存在的元素，用于将特殊的效果添加到某些选择器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">::before &#123;&#125; /* 选择器在被选元素的前面插入内容和定义css，使用 content 属性来指定要插入的内容。 */</span><br><span class="line">::after &#123;&#125; /* 选择器在被选元素的后面插入内容和定义css，使用 content 属性来指定要插入的内容。 */</span><br><span class="line">:first-letter /* 选择该元素内容的首字母 */</span><br><span class="line">:first-line /* 选择该元素内容的首行 */</span><br><span class="line">::selection /* 选择被用户选取的元素部分 */</span><br></pre></td></tr></table></figure>

<p><strong>背景和边框</strong></p>
<ul>
<li><p>背景：<br>background-size：规定背景图片的尺寸（cover：填充；100% 100%：拉伸）<br>background-origin：规定背景图片的定位区域<br>对于 background-origin 属性，有如下属性<br>背景图片可以放置于 content-box、padding-box 或 border-box 区域</p>
</li>
<li><p>边框：<br>border-radius：圆角<br>box-shadow &#x2F; text-shadow：阴影<br>border-image：边框图片</p>
</li>
</ul>
<p><strong>文本效果</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>text-shadow</td>
<td>向文本添加阴影</td>
</tr>
<tr>
<td>text-justify</td>
<td>规定当 text-align 设置为 “justify” 时所使用的对齐方法</td>
</tr>
<tr>
<td>text-emphasis</td>
<td>向元素的文本应用重点标记以及重点标记的前景色</td>
</tr>
<tr>
<td>text-outline</td>
<td>规定文本的轮廓</td>
</tr>
<tr>
<td>text-overflow</td>
<td>规定当文本溢出包含元素时发生的事情</td>
</tr>
<tr>
<td>text-wrap</td>
<td>规定文本的换行规则</td>
</tr>
<tr>
<td>word-break</td>
<td>规定非中日韩文本的换行规则</td>
</tr>
<tr>
<td>word-wrap</td>
<td>允许对长的不可分割的单词进行分割并换行到下一行</td>
</tr>
<tr>
<td>text-decoration</td>
<td>文本修饰符：overline、line-through、underline 分别是上划线、中划线、下划线</td>
</tr>
</tbody></table>
<ul>
<li>@font-face 自定义字体</li>
</ul>
<h1 id="动画、过渡"><a href="#动画、过渡" class="headerlink" title="动画、过渡"></a>动画、过渡</h1><ul>
<li>过渡效果（transition），使页面变化更平滑，以下参数可直接写在 transition 后面</li>
<li>transition-translate:动画位置</li>
</ul>
<ol>
<li>transition-property ：执行动画对应的属性，例如 color，background 等，可以使用 all 来指定所有的属性。</li>
<li>transition-duration：过渡动画的一个持续时间。</li>
<li>transition-timing-function：在延续时间段，动画变化的速率，常见的有：ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier</li>
<li>transition-delay：延迟多久后开始动画</li>
</ol>
<ul>
<li>动画（animation）<br>先定义 @keyframes 规则（0%，100% | from，to）<br>然后定义 animation，以下参数可直接写在 animation 后面</li>
</ul>
<ol>
<li>animation-name: 定义动画名称</li>
<li>animation-duration: 指定元素播放动画所持续的时间长</li>
<li>animation-timing-function: ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(, , , )： 指元素根据时间的推进来改变属性值的变换速率，即动画的播放方式</li>
<li>animation-delay: 指定元素动画开始时间</li>
<li>animation-iteration-count: infinite | number：指定元素播放动画的循环次数</li>
<li>animation-direction: normal | alternate： 指定元素动画播放的方向，其只有两个值，默认值为 normal，如果设置为 normal 时，动画的每次循环都是向前播放；另一个值是 alternate，规定动画在下一周期逆向地播放（来去播放）</li>
<li>animation-play-state: running | paused ：控制元素动画的播放状态</li>
</ol>
<h1 id="JS-原生实现动画"><a href="#JS-原生实现动画" class="headerlink" title="JS 原生实现动画"></a>JS 原生实现动画</h1><p>借助 jQuery 提供的 animate 方法，我们可以很容易实现一些常见的 js 动画效果</p>
<h1 id="CSS-兼容内核"><a href="#CSS-兼容内核" class="headerlink" title="CSS 兼容内核"></a>CSS 兼容内核</h1><p>-moz-：代表 FireFox 浏览器私有属性<br>-ms-：代表 IE 浏览器私有属性<br>-webkit-：代表 safari、chrome 浏览器私有属性<br>-o-：代表 opera 浏览器私有属性</p>
<h1 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h1><p>前端的权限校验主要的目的是过滤不该有的请求和操作，减少服务端压力。</p>
<p><strong>接口权限</strong></p>
<p>接口权限最简单，目前一般采用 jwt 的形式来验证，没有通过的话一般返回 401 Authentication Required, <code>返回登录页重新登录</code><br>登录完拿到<code>Token</code>,将 token 存起来（cookie 或者 ssessionStorage），每次登录的时候头部携带 token 就行了（axios 请求拦截器实现）。</p>
<p><strong>按钮权限</strong></p>
<p>一个页面会有新增，删除，编辑等等按钮。不同用户应该是有不同操作权限的。<br>我们不妨定义权限码 0：不可见 1:不可编辑 2:可编辑<br>我们提前和后端约定好按钮的名字，后端会返回一个按钮权限列表。然后我们根据权限列表使用 v-if 指令或者 绑定 disabled 属性达到相应权限效果。<br>当然更好的最好是自己写一个自定义权限指令，实质就是根据相应权限操作 dom</p>
<p><strong>页面权限（菜单权限）</strong></p>
<p>个人认为页面权限实际上就是菜单权限，如果说我们没有去某个页面的导航菜单，实际上就是没有去那个页面的权限了，所以说页面权限的实际就是菜单权限。</p>
<p>一句话，<code>获取菜单权限列表，动态递归生成菜单</code><br>这个菜单权限列表可以是后台直接返回你的，也可以是你注册路由的时候写在 meta 里面的菜单信息，后台返回路由权限，你根据 meta 信息动态算出的菜单权限。<br>至于菜单肯定是根据菜单权限递归生成的</p>
<p><strong>路由权限</strong></p>
<p>上面的菜单权限虽然做到能看不见菜单，但是我可以通过直接输入 url 的方式去没有权限的页面呀，这种情况需要靠我们的<code>路由权限</code>来阻止。<br><strong>第一种</strong>，也是我上个项目用的，先注册好所有的路由，然后获取有资格访问的路由权限列表，最后直接通过 Router.beforeEach 来判断，每次跳路由的时候判断是否在权限列表里，在的话就放行，<code>不在就提示权限不够</code><br>优点：简单暴力，<code>不会跳到404页面（因为去的路由能在路由规则里找到）</code><br>缺点：由于初始化了所有路由，运行的时候会挂载不必要的路由（？有待考究）<br><strong>第二种</strong>，先只注册基本路由，然后获取路由权限列表，然后借助 route.add() API 根据权限列表将有权限的路由动态注册到路由规则上<br>优缺点与第一种正好相反</p>
<p><strong>权限缓存</strong></p>
<p>获取的个人信息（包括权限列表）该不该缓存到 ssessionStorage 里面？我看很多人的文章都是只缓存 token,每次刷新都是重新拉取信息。<br>个人认为这样做意义不大，缓存的目的就是为了减少请求，优化交互。存在当前页签基本能保证同一时间你就是你</p>
<h1 id="JWT-token-过期自动续期解决方案"><a href="#JWT-token-过期自动续期解决方案" class="headerlink" title="JWT token 过期自动续期解决方案"></a>JWT token 过期自动续期解决方案</h1><p><strong>JWT</strong></p>
<p>JWT 全称 JSON Web Token，由三部分组成 header（头部，用于描述关于该 JWT 的最基本的信息，例如其类型以及签名所用的算法等）、payload（载荷，就是存放有效信息的地方，在这一部分中存放过期时间）和 signature（签证，签证信息）。</p>
<p><strong>token</strong></p>
<p>token 就是后端生成的 JWT 字符串值，在前后端分离中，token 是前端访问后端接口的合法身份、权限的凭证。ssww</p>
<p><strong>token 过期刷新方案</strong></p>
<p>1、单点登录<br>用户登录，后端验证用户成功之后生成两个 token，这两个 token 分别是 access_token（访问接口使用的 token）、refresh_token（access_token 过期后用于刷续期的 token，注意设置 refresh_token 的过期时间需比 access_token 的过期时间长），后端将用户信息和这两个 token 存放到 redis 中并返回给前端。<br>前端在获取到登录成功返回的两个 token 之后，将之存放到 localStorage 本地存储中。<br>2、接口请求<br>前端封装统一接口请求函数、token 刷新函数，在请求成功之后对返回结果进行校验，如果 token 过期，则调用 token 刷新函数请求新的 token.<br>后端在接收到 token 刷新请求之后通过结合 redis 中存放的用户信息、token 和 refresh_token 对请求参数进行验证，验证通过之后生成新的 token 和 refresh_token 存放到 redis 中并返回给前端。至此完成 token 刷新。<br>3、多请求应对<br>所谓多请求，就是指在短时间内同时发生多个请求，如果此时 token 已经过期，那么这些请求都会出现 token 过期请求失败的情况。<br>为了避免反复刷新 token，需要设置一个刷新 token 的开关 isRefresh，当一个请求出现 token 过期的时候，这个时候会调用 token 刷新函数，与此同时关闭开关将 isRefresh 的值设置为 false，避免后续请求去调用 token 刷新函数。<br>当发现 token 过期时，咱们将请求延缓到 token 刷新之后再重新执行请求，这里采用 Promise 函数，把每一个 token 失效的请求都存到一个 Promise 函数集合里面，当 token 刷新之后打开开关将 isRefresh 的值设置为 true，然后批量执行 Promise 函数集合里面的 Promise 函数，返回请求结果。</p>
<h1 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h1><p><strong>DOM 结构</strong></p>
<p>1.样式表放在头部，防止白屏和闪屏</p>
<p>2.JS 脚本放在底部或异步获取，防止阻塞资源加载</p>
<p>3.使用语义化标签，优化精简 DOM 结构</p>
<p>4.减少 DOM 操作频率</p>
<p>5.减少重绘与回流</p>
<p><strong>JS 脚本</strong></p>
<p>1.优化脚本结构，移除重复的脚本</p>
<p>2.模块就近加载（CMD）</p>
<p>3.按需加载加载组件和路由</p>
<p>4.图片懒加载，列表分页</p>
<p>5.使用节流与防抖减少事件触发频率</p>
<p>6.尽量使用 CSS 动画代替 js 动画，开启硬件加速</p>
<p><strong>资源打包上线</strong></p>
<p>1.使用打包构建工具（webpack）清除注释，压缩页面资源，js、css、html、图片、字体等等</p>
<p>2.混淆 js 代码</p>
<p>3.分离非业务逻辑相关 vendor 依赖，使用长缓存缓存和 CDN 分发网络</p>
<p>**服务器优化 **</p>
<p>1.减少 Http 请求，合并页面资源，js，css 单一入口。js 特殊可以分为两个文件，一个业务逻辑，一个非业务逻辑</p>
<p>2.把小图标合成雪碧图，不太适用经常更新的移动端开发</p>
<p>3.把小的图片，字体等资源 base64 化</p>
<p>4.开启 GZip 压缩，减少资源传输大小</p>
<p>5.使用强缓存和协商缓存，减少资源重复请求</p>
<p>**Vue 中可以优化的点 **</p>
<p>1.Vue 库 dist 里面的 Runtime-only 比 Runtime+Compiler 小 30%</p>
<p>2.Vue 的计算属性会根据依赖的 data 进行缓存</p>
<p>3.keep-alive 可以缓存常用组件</p>
<p>4.Vuex 中的 getter 也会根据依赖的 state 进行缓存</p>
<p>5.v-for 中唯一 key 的使用</p>
<p>6.Vue 全局错误处理 errorHandle</p>
<p>7.Vue 路由懒加载</p>
<p>8.Vue 组件动态加载</p>
<p><strong>React 中可以优化的点</strong></p>
<p>1.在 constructor 改变 this 指向代替箭头函数和 render 内绑定 this，避免函数作为 props 带来不必要的 rerender</p>
<p>2.shouldComponentUpdate，减少不不必要的 rerender</p>
<p>3.PureComponent 高性能组件只响应引用数据的深拷贝</p>
<p>4.使用唯一 key 优化 list diff</p>
<p>5.合并 setState 操作，减少虚拟 dom 对比频率</p>
<p>6.React 路由动态加载 react-loadable</p>
<h1 id="什么是虚拟列表"><a href="#什么是虚拟列表" class="headerlink" title="什么是虚拟列表"></a>什么是虚拟列表</h1><p>虚拟列表是按需显示的一种技术，可以根据用户的滚动，不必渲染所有列表项，而只是渲染可视区域内的一部分列表元素的技术。</p>
<p>最好是使用一些现成的虚拟列表组件来对长列表进行优化，比较常见的有  react-virtualized  和  react-tiny-virtual-list  这两个组件，使用他们可以有效地对你的长列表进行优化。</p>
<h1 id="清除浮动的最常用的方法，以及优缺点"><a href="#清除浮动的最常用的方法，以及优缺点" class="headerlink" title="清除浮动的最常用的方法，以及优缺点"></a>清除浮动的最常用的方法，以及优缺点</h1><p>为什么要清除浮动？</p>
<p><strong>清除浮动主要是为了解决，父元素因为子级元素浮动引起的内部高度为 0 的问题</strong>,大意就是当父元素不给高度的时候,内部元素不浮动时会撑开,而浮动的时候，父元素变成一条线</p>
<p><strong>1:给浮动的元素的祖先元素加上高度</strong></p>
<p><strong>2:clear:both;</strong></p>
<p>这是最简单的清除浮动的方法，就是给盒子增加 clear:both；表示自己的内部元素，不受其他盒子的影响</p>
<p><strong>3:隔墙法与内墙法</strong></p>
<p>隔墙法 该方法通过 div.cl h16 这堵墙将两个父类分隔,弥补了 clear:both 方法中 margin 无效的情况,可以通过设置墙的高度来控制间隙 <code>弊端:网页渲染后,两个分隔的父类不会有高度</code></p>
<p><strong>4:overflow:hidden;</strong></p>
<p>overflow:hidden;的本意是将超出父类的部分隐藏</p>
<h1 id="forEach-和-map-的区别和理解"><a href="#forEach-和-map-的区别和理解" class="headerlink" title="forEach()和 map()的区别和理解"></a>forEach()和 map()的区别和理解</h1><p>关于 forEach()</p>
<p>敲黑板：<strong>没有返回值！！！！</strong></p>
<ul>
<li>参数：value 数组中的当前项，index 当前项的索引，array 原始数组；</li>
<li>数组中有几项，那么传递进去的匿名回调函数就需要执行几次</li>
<li>理论上这个方式是没有返回值的，只是遍历数组中的每一项，不对原来数组进行修改，但是可以自己通过数组的索引来修改原来的数组</li>
</ul>
<p>关于 map()</p>
<p>敲黑板：<strong>有返回值，可以 return 出来！！！！</strong></p>
<ul>
<li>参数：value 数组中的当前项，index 当前项的索引，array 原始数组</li>
<li>区别：map 的回调函数中支持 return 返回值，return 的是什么，相当于把数组中的这一项变为什么（并不影响原来的数组，只是相当于把原数组克隆了一份，把克隆这一份的数组中的对应项改变了 ）；</li>
</ul>
<p><strong>$.each()</strong></p>
<p>敲黑板：<strong>没有返回值，里面的匿名函数支持两个参数：当前项的索引 i，数组中的当前项 v，如果遍历的是对象，k 是键，v 是值</strong></p>
<p><strong>$.map()</strong></p>
<p><strong>敲黑板：</strong></p>
<p><strong>有返回值，可以 return 出来，里面的匿名函数支持 2 个参数和$.each()里的参数位置想发，数组中的当前项 v，当前项的索引 i。如果遍历的是对象，k 是键，v 是值.</strong></p>
<p><strong>特殊情况：</strong></p>
<p><strong>$(“span”).map()形式 ，参数顺序和 each 的是一样的</strong></p>
<h1 id="forEach-跳出循环跟终止循环"><a href="#forEach-跳出循环跟终止循环" class="headerlink" title="forEach 跳出循环跟终止循环"></a>forEach 跳出循环跟终止循环</h1><p>跳出本次循环继续执行下次循环，或者满足某个条件的时候，终止 foreach()循环，分别会用到：continue 与 break</p>
<h1 id="JS-事件队列"><a href="#JS-事件队列" class="headerlink" title="JS 事件队列"></a>JS 事件队列</h1><p>1.js 的执行是单线程的。</p>
<p>2.而当它遇到了 window 的 setTimeout 和 setInterval 这样的异步任务，js 都默默地先不执行这些回调，而是继续向下执行其他 js 脚本，等到所有 js 脚本都解析执行完了，再执行回调。</p>
<p>3.那么有多个回调的时候执行顺序是怎么样的呢？</p>
<p>浏览器是多线程的，js 执行线程只是它多个线程中的一个。</p>
<p>当 js 的执行线程看到了 setTimeout，浏览器马上会调用<strong>其他线程</strong>把这个函数中的回调扔到浏览器的事件队列中，事件队列是先入先出的队列。</p>
<p>那么在 js 执行线程执行完所有脚本空闲的时候，事件队列中的事件回调，会一个一个被拿出来执行。</p>
<p>浏览器有一个内部大消息循环 Event Loop（事件循环），会轮询事件队列并处理事件。</p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是遵循先进先出原则的一组有序的项,与栈不同的是,栈不管是入栈还是出栈操作都是在栈顶操作.队列则是在队尾添加元素,队顶移除,</p>
<p><strong>队列的创建</strong></p>
<p>与栈的创建类似,首先创建一个表示队列的函数,然后定义一个数组用来保存队列里的元素</p>
<p>创建队列后需要为其定义一些方法:</p>
<p>enqueue(element):向队的尾部添加一个新的项</p>
<p>dequeue():移除队列第一项,并返回被移除的元素</p>
<p>front():返回队列第一项,队列不做任何变动</p>
<p>isEmpty():如果队列中没有任何元素返回 true,否则返回 false</p>
<p>size():返回队列包含的元素个数</p>
<p><strong>es6 实现 Queue</strong></p>
<p>实现 Stack 类一样,也可以用 es6 的 class 语法实现 Queue 类,用 WeakMap 保存使用属性 items,并用闭包返回 Queue 类</p>
<p><strong>优先队列</strong></p>
<p>优先队列就是:队列中的每个元素都会各自的优先级,在插入的时候会根据优先级的高低顺序进行插入操作,和前面队列实现有点不太一样的地方,队列中的元素多了优先级的属性,</p>
<p><strong>循环队列</strong></p>
<p>循环队列顾名思义就是:给定一个数,然后迭代队列,从队列开头移除一项,然后再将其加入到队列末尾,当循环到给定数字时跳出循环,从队列移除一项,直至剩余一个元素</p>
<h1 id="下拉刷新跟上拉加载的原理"><a href="#下拉刷新跟上拉加载的原理" class="headerlink" title="下拉刷新跟上拉加载的原理"></a>下拉刷新跟上拉加载的原理</h1><p>上拉刷新的实现主要依靠的是<code>touch</code>事件的三个阶段，以及借助 CSS3 动画效果；下拉加载主要依靠页面的<code>onscroll</code>事件，需要注意的是页面滚动时可能要考虑函数节流。</p>
<p><strong>下拉刷新</strong></p>
<p>实现下拉刷新主要分为三步：</p>
<ul>
<li>监听原生<code>touchstart</code>事件，记录其初始位置的值，<code>e.touches[0].pageY</code>；</li>
<li>监听原生<code>touchmove</code>事件，记录并计算当前滑动的位置值与初始位置值的差值，大于<code>0</code>表示向下拉动，并借助 CSS3 的<code>translateY</code>属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；</li>
<li>监听原生<code>touchend</code>事件，若此时元素滑动达到最大值，则触发<code>callback</code>，同时将<code>translateY</code>重设为<code>0</code>，元素回到初始位置。</li>
</ul>
<p>在下拉到松手的过程中，经历了三个状态：</p>
<ul>
<li>当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作；</li>
<li>下拉到一定值时，显示松手释放后的操作提示；</li>
<li>下拉到达设定最大值松手时，执行回调，提示正在进行更新操作。</li>
</ul>
<p><strong>上拉加载</strong></p>
<p>上拉加载更多数据是在页面滚动时触发的动作，一般是页面滚动到底部时触发，也可以选择在滚动到一定位置的时候触发。</p>
<p>以滚动到页面底部为例。实现原理是分别获得当前滚动条的<code>scrollTop</code>值、当前可视范围的高度值<code>clientHeight</code>以及文档的总高度<code>scrollHeight</code>。当<code>scrollTop</code>和<code>clientHeight</code>的值之和大于等于<code>scrollHeight</code>时，触发<code>callback</code>。</p>
<p>页面绑定<code>onscroll</code>事件时加入了节流函数，其作用就是忽略滚动条 300 毫秒内的连续多次触发。</p>
<h1 id="发送多个请求"><a href="#发送多个请求" class="headerlink" title="发送多个请求"></a>发送多个请求</h1><p>promise.all</p>
<h1 id="三次握手-四次挥手"><a href="#三次握手-四次挥手" class="headerlink" title="三次握手,四次挥手"></a>三次握手,四次挥手</h1><p><strong>三次握手</strong> <strong>（three-way handshaking）</strong></p>
<p>1.背景：TCP 位于传输层，作用是提供可靠的字节流服务，为了准确无误地将数据送达目的地，TCP 协议采纳三次握手策略。</p>
<p>2.原理：</p>
<p>1）发送端首先发送一个带有 SYN（synchronize）标志地数据包给接收方。</p>
<p>2）接收方接收后，回传一个带有 SYN&#x2F;ACK 标志的数据包传递确认信息，表示我收到了。</p>
<p>3）最后，发送方再回传一个带有 ACK 标志的数据包，代表我知道了，表示’握手‘结束。</p>
<p><strong>四次挥手（Four-Way-Wavehand）</strong></p>
<p>1.意义：当被动方收到主动方的 FIN 报文通知时，它仅仅表示主动方没有数据再发送给被动方了。但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭 SOCKET,它可能还需要发送一些数据给主动方后，再发送 FIN 报文给主动方，告诉主动方同意关闭连接，所以这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的。</p>
<p>2.原理：</p>
<p>1）第一次挥手：Client 发送一个 FIN，用来关闭 Client 到 Server 的数据传送，Client 进入 FIN_WAIT_1 状态。</p>
<p>2）第二次挥手：Server 收到 FIN 后，发送一个 ACK 给 Client，确认序号为收到序号+1（与 SYN 相同，一个 FIN 占用一个序号），Server 进入 CLOSE_WAIT 状态。</p>
<p>3）第三次挥手：Server 发送一个 FIN，用来关闭 Server 到 Client 的数据传送，Server 进入 LAST_ACK 状态。</p>
<p>4）第四次挥手：Client 收到 FIN 后，Client 进入 TIME_WAIT 状态，接着发送一个 ACK 给 Server，确认序号为收到序号+1，Server 进入 CLOSED 状态，完成四次挥手</p>
<h1 id="为什么建立连接是三次握手，而断开连接是四次挥手呢"><a href="#为什么建立连接是三次握手，而断开连接是四次挥手呢" class="headerlink" title="为什么建立连接是三次握手，而断开连接是四次挥手呢?"></a>为什么建立连接是三次握手，而断开连接是四次挥手呢?</h1><p>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</p>
<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><p><strong>同源策略是什么</strong></p>
<p>同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源 如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的<strong>源</strong>。</p>
<h1 id="微信小程序生命周期"><a href="#微信小程序生命周期" class="headerlink" title="微信小程序生命周期"></a>微信小程序生命周期</h1><p>**各个生命周期方法作用和描述 **</p>
<p>onLaunch 生命周期函数–监听小程序初始化 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）</p>
<p>onShow 生命周期函数–监听小程序显示 当小程序启动，或从后台进入前台显示，会触发 onShow</p>
<p>onHide 生命周期函数–监听小程序隐藏 当小程序从前台进入后台，会触发 onHide</p>
<p>onError 错误监听函数 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息</p>
<p>其他 Any 开发者可以添加任意的函数或数据到 Object 参数中，用 this 可以访问</p>
<p><strong>在 page 页面中定义的生命周期方法</strong></p>
<p>onLoad 生命周期函数–监听页面加载</p>
<p>onReady 生命周期函数–监听页面初次渲染完成</p>
<p>onShow 生命周期函数–监听页面显示</p>
<p>onHide 生命周期函数–监听页面隐藏</p>
<p>onUnload 生命周期函数–监听页面卸载</p>
<p><strong>其中，打开小程序后会依次执行 onLoad，onReady 和 onShow 方法</strong></p>
<p>前后台切换会分别执行 onHide 和 onShow 方法，</p>
<p>当小程序页面销毁时会执行 onUnload 方法</p>
<p>例如，我们在 details.js 中定义 onUnload 方法</p>
<p><strong>注意：</strong><br>App() 必须在 app.js 中注册，且不能注册多个。<br>不要在定义于 App() 内的函数中调用 getApp() ，使用 this 就可以拿到 app 实例。<br>不要在 onLaunch 的时候调用 getCurrentPages()，此时 page 还没有生成。<br>通过 getApp() 获取实例之后，不要私自调用生命周期函数。</p>
<h1 id="小程序的传值方式"><a href="#小程序的传值方式" class="headerlink" title="小程序的传值方式"></a>小程序的传值方式</h1><p><strong>1.全局变量</strong></p>
<p><strong>app.js 里</strong></p>
<p><strong>App({</strong></p>
<p><strong>&#x2F;&#x2F;全局变量</strong></p>
<p><strong>globalData: {</strong></p>
<p><strong>userInfo: null,</strong></p>
<p><strong>host: ‘<a target="_blank" rel="noopener" href="http://localhost:8080/data.json">http://localhost:8080/data.json</a>‘</strong></p>
<p><strong>}</strong></p>
<p><strong>在其他 js 页面取值：</strong></p>
<p><strong>const app &#x3D; getApp() &#x2F;&#x2F;获取应用实例 必须有这个才能获取到 app.js 里的东西</strong></p>
<p><strong>在需要获取值得地方赋值如：</strong></p>
<p><strong>url:app.globalData.host</strong></p>
<p><strong>2.本地缓存（最多存 10M 的数据）</strong></p>
<p><strong>设值：wx.setStorageSync(‘title’, title)</strong></p>
<p><strong>取值：var title&#x3D;wx.getStorageSync(‘title’)</strong></p>
<p><strong>3.URL 传值</strong></p>
<p><strong>wx.navigateTo({</strong></p>
<p><strong>url: ‘&#x2F;pages&#x2F;detail&#x2F;detail?title&#x3D;’+title,</strong></p>
<p><strong>})</strong></p>
<p><strong>在’&#x2F;pages&#x2F;detail&#x2F;detail 的 detail.js 里面</strong></p>
<p><strong>获取值:</strong></p>
<p><strong>onLoad: function (options) {</strong></p>
<p><strong>console.log(options) &#x2F;&#x2F; 打印结果为：{title:”abc”}</strong></p>
<p><strong>},</strong></p>
<h1 id="Ts"><a href="#Ts" class="headerlink" title="Ts"></a>Ts</h1><p>其实 <code>Typescript</code> 作为一门 强类型编程语言，最具特色的就是他的类型表达能力，</p>
<p><code>Typescript</code> 中类型系统中的的函数被称作 <code>泛型操作符</code>，其定义的简单的方式就是使用 <code>type</code> 关键字</p>
<p>Typescript 的类型是支持定义 “函数定义” 的</p>
<p>Typescript 的类型是支持 “条件判断” 的</p>
<p>Typescript 的类型是支持 “数据结构” 的</p>
<p>Typescript 的类型是支持 “作用域” 的</p>
<p>Typescript 的类型是支持 “递归” 的</p>
<h1 id="长列表优化"><a href="#长列表优化" class="headerlink" title="长列表优化"></a>长列表优化</h1><p>在我们的日常工作中，会越到各种各样的列表，比如，我们通常采用分页的方式进行内容的逐渐获取，但是不可否认的是，当我们列表内容过多的时候，就会出现页面滑动卡顿、数据渲染较慢的问题，</p>
<p>分页</p>
<p>虚拟列表: 虚拟列表是按需显示的一种技术，可以根据用户的滚动，不必渲染所有列表项，而只是渲染可视区域内的一部分列表元素的技术。</p>
<p>上拉加载</p>
<h1 id="JS-的作用域"><a href="#JS-的作用域" class="headerlink" title="JS 的作用域"></a>JS 的作用域</h1><p>在 Javascript 中，作用域分为 <strong>全局作用域</strong> 和 <strong>函数作用域</strong></p>
<p><strong>全局作用域：</strong></p>
<p>代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。</p>
<p><strong>函数作用域：</strong></p>
<p>在固定的代码片段才能被访问</p>
<p>作用域有上下级关系，上下级关系的确定就看函数是在哪个作用域下创建的。</p>
<p>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</p>
<p>变量取值：<strong>到创建 这个变量 的函数的作用域中取值</strong></p>
<h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p><strong>一般情况下，变量取值到 创建 这个变量 的函数的作用域中取值。</strong></p>
<p><strong>但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。</strong></p>
<h1 id="React-中函数组件和类组件的区别"><a href="#React-中函数组件和类组件的区别" class="headerlink" title="React 中函数组件和类组件的区别"></a>React 中函数组件和类组件的区别</h1><p>定义组件有两个要求：</p>
<ol>
<li>组件名称必须以大写字母开头</li>
<li>组件的返回值只能有一个根元素</li>
</ol>
<p><strong>函数组件：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">&quot;react&quot;</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line">函数组件接收一个单一的props对象并返回了一个<span class="title class_">React</span>元素</span><br></pre></td></tr></table></figure>

<p><strong>类组件</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Welcome</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">&quot;react&quot;</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>无论是使用函数或是类来声明一个组件，它决不能修改它自己的 <code>props</code>。</p>
<p>所有 React 组件都必须是纯函数，并禁止修改其自身 <code>props</code> 。</p>
<p>React 是单项数据流，父组件改变了属性，那么子组件视图会更新。</p>
<p>属性 <code>props</code> 是外界传递过来的，状态 <code>state</code> 是组件本身的，状态可以在组件中任意修改</p>
<p>组件的属性和状态改变都会更新视图。</p>
<p><strong>区别：</strong></p>
<p>函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高，</p>
<p>因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。</p>
<p>为了提高性能，尽量使用函数组件。</p>
<p>函数组件没有 this,没有生命周期，没有状态 state,</p>
<p>类组件有 this,有生命周期，有状态 state。</p>
<h1 id="重绘和回流-重排-的区别"><a href="#重绘和回流-重排-的区别" class="headerlink" title="重绘和回流(重排)的区别"></a>重绘和回流(重排)的区别</h1><p>重绘：改变页面样式的时候，不会影响其他元素在页面的配置。</p>
<ul>
<li>页面渲染初始化(无法避免)</li>
<li>添加或删除可见的 DOM 元素</li>
<li>元素位置的改变，或者使用动画</li>
<li>元素尺寸的改变——大小，外边距，边框</li>
<li>浏览器窗口尺寸的变化</li>
<li>填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变</li>
</ul>
<p>回流必定会引发重绘，但重绘不一定会引发回流。</p>
<h1 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h1><p>解析 HTML 和 css 将其转成 js 语言进行渲染 dom 树，使用流式布局渲染成浏览器文档。</p>
<ul>
<li>构建 DOM 树（parse）：渲染引擎解析 HTML 文档，首先将标签转换成 DOM 树中的 DOM node</li>
<li>构建渲染树（construct）：解析对应的 CSS 样式文件信息</li>
<li>布局渲染树（reflow&#x2F;layout）：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标；</li>
<li>绘制渲染树（paint&#x2F;repaint）：遍历渲染树，使用 UI 后端层来绘制每个节点。</li>
</ul>
<h1 id="react-渲染机制"><a href="#react-渲染机制" class="headerlink" title="react 渲染机制"></a>react 渲染机制</h1><p>1、React 整个的渲染机制就是 React 会调用 render()函数构建一棵 Dom 树，<br>2、在 state&#x2F;props 发生改变的时候，render()函数会被再次调用渲染出另外一棵树，重新渲染所有的节点，构造出新的虚拟 Dom tree 跟原来的 Dom tree 用 Diff 算法进行比较，找到需要更新的地方批量改动，再渲染到真实的 DOM 上，由于这样做就减少了对 Dom 的频繁操作，从而提升的性能。</p>
<p>**React.render() **</p>
<p>在使用 React 进行构建应用时，我们总会有一个步骤将组建或者虚拟 DOM 元素渲染到真实的 DOM 上，将任务交给浏览器，进而进行<strong>layout 和 paint</strong>等步骤，这个函数就是 React.render()</p>
<p>接收 2-3 个参数，并返回 ReactComponent 类型的对象，当组件被添加到 DOM 中后，执行回调。在这里涉及到了两个 React 类型–ReactComponent 和 ReactElement</p>
<p><strong>进入页面 render()执行了几次</strong><br>render 在 componentWillMount 后会执行一次，会在 props 及 state 改变时执行。</p>
<h1 id="缓存的理解-x2F-http-缓存机制"><a href="#缓存的理解-x2F-http-缓存机制" class="headerlink" title="缓存的理解&#x2F;http 缓存机制"></a>缓存的理解&#x2F;http 缓存机制</h1><p>缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的状态码是 304。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商.</p>
<p>强缓存 所请求的数据在缓存数据库中尚未过期时，不与服务器进行交互，直接使用缓存数据库中的数据。</p>
<p>Expires<br>cache-control</p>
<p>协商缓存<br>     当强缓存过期未命中或者响应报文 Cache-Control 中有 must-revalidate 标识必须每次请求验证资源的状态时，便使用协商缓存的方式去处理缓存文件.<br>     从缓存数据库中取出缓存的标识，然后向浏览器发送请求验证请求的数据是否已经更新，如果已更新则返回新的数据，若未更新则使用缓存数据库中的缓存数据 Last-Modified 和 If-Modified-Since Etag 和 If-None-Match</p>
<p>http 缓存机制</p>
<p>在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。</p>
<h1 id="Three-js"><a href="#Three-js" class="headerlink" title="Three.js"></a>Three.js</h1><p>Three.js 是基于原生 WebGL 封装运行的三维引擎，在所有 WebGL 引擎中，Three.js 是国内文资料最多、使用最广泛的三维引擎。</p>
<p><strong>数据可视化</strong></p>
<p>与 webgl 相关的数据可视化主要是两方面，一方面是海量超大数据的可视化，另一方面是与 3D 相关的数据可视化。对于超大的海量数据而言，基于 canvas、svg 等方式进行 web 可视化，没有基于 WebGL 技术实现性能更好，对于 3D 相关的数据可视化基于 WebGL 技术，借助 3D 引擎 Threejs 可以很好的实现。</p>
<p><strong>H5&#x2F;微信小游戏</strong></p>
<p>非常火的微信小游戏跳一跳就是使用 Three.js 引擎开发的。 开发 3D 类的 H5 小游戏或者微信小游戏，Three.js 引擎是非常好的选择。</p>
<p>通过 Threejs 开发的小游戏，可以直接部署在微信小程序或者 web 端，无需下载，方便传播，目前的生态非常和小游戏开发。</p>
<h1 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h1><p>当多组功能相同的对象,有不同的表现形式，即功能一样，但是不同的表现形式，比如弹窗，功能都是显示弹出层，但是弹出的位置、弹框的宽高不一样，这就是不同的表现形式，像上述这种情况就可以用组件开发，不必为同样功能的不同的状态都去写一套代码，这样可以节省代码。所以组件化开发也是代码复用的一种形式。 组件是面向对象的深入应用，将配置参数、方法、事件三者进行分离。组件开发则是复用代码的一种形式，可以用同一套代码来满足不同的需求。</p>
<h1 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h1><p>自定义事件 主要是跟函数有关系,就是让函数能够具备事件的某些特性，</p>
<h1 id="echarts-特性"><a href="#echarts-特性" class="headerlink" title="echarts 特性"></a>echarts 特性</h1><p>ECharts 包含了以下特性：</p>
<ul>
<li><strong>丰富的可视化类型</strong>: 提供了常规的折线图、柱状图、散点图、饼图、K 线图，用于统计的盒形图，用于地理数据可视化的地图、热力图、线图，用于关系数据可视化的关系图、treemap、旭日图，多维数据可视化的平行坐标，还有用于 BI 的漏斗图，仪表盘，并且支持图与图之间的混搭。</li>
<li><strong>多种数据格式无需转换直接使用</strong>: 内置的 dataset 属性（4.0+）支持直接传入包括二维表，key-value 等多种格式的数据源，此外还支持输入 TypedArray 格式的数据。</li>
<li><strong>千万数据的前端展现</strong>: 通过增量渲染技术（4.0+），配合各种细致的优化，ECharts 能够展现千万级的数据量。</li>
<li><strong>移动端优化</strong>: 针对移动端交互做了细致的优化，例如移动端小屏上适于用手指在坐标系中进行缩放、平移。 PC 端也可以用鼠标在图中进行缩放（用鼠标滚轮）、平移等。</li>
<li><strong>多渲染方案，跨平台使用</strong>: 支持以 Canvas、SVG（4.0+）、VML 的形式渲染图表。</li>
<li><strong>深度的交互式数据探索</strong>: 提供了 图例、视觉映射、数据区域缩放、tooltip、数据刷选等开箱即用的交互组件，可以对数据进行多维度数据筛取、视图缩放、展示细节等交互操作。</li>
<li><strong>多维数据的支持以及丰富的视觉编码手段</strong>: 对于传统的散点图等，传入的数据也可以是多个维度的。</li>
<li><strong>动态数据</strong>: 数据的改变驱动图表展现的改变。</li>
<li><strong>绚丽的特效</strong>: 针对线数据，点数据等地理数据的可视化提供了吸引眼球的特效。</li>
<li><strong>通过 GL 实现更多更强大绚丽的三维可视化</strong>: 在 VR，大屏场景里实现三维的可视化效果。</li>
</ul>
<h1 id="Canvas-画布"><a href="#Canvas-画布" class="headerlink" title="Canvas(画布)"></a>Canvas(画布)</h1><p><strong>Canvas 动画原理</strong></p>
<p>快速切换的静态画面。 Canvas 优点：提供的功能原始，适合像素处理，动态渲染和大数据量绘制。</p>
<p><strong>基本步骤</strong></p>
<p>绘制 - 清空 - 绘制 - 清空 - 绘制</p>
<p><strong>控制函数</strong></p>
<ul>
<li>setTimeout</li>
<li>setInterval</li>
<li>requestAnimationFrame</li>
</ul>
<p><strong>四种运动</strong></p>
<p>线性运动: 从左到右匀速运动</p>
<p>变速运动: 从上到下模拟自由落体运动</p>
<p>函数运动（正弦）:倾斜上下</p>
<p>环形运动:就是转圈</p>
<ul>
<li><code>strokeRect(x,y,width,height)</code>:绘制无填充矩形</li>
<li><code>arc(x,y,r,sAngle,eAngle,counterclockwise)</code>:绘制圆</li>
<li><code>fillStyle=color|gradient|pattern</code>:填充绘画的颜色、渐变或模式</li>
<li><code>moveTo(x,y)</code>:把路径移动到画布中的指定点，不创建线条</li>
<li><code>lineTo(x,y)</code>:添加一个新点</li>
<li><code>stroke()</code>:绘制已定义的路径，即线条绘制</li>
<li><code>fill()</code>:填充当前绘图（主要是颜色填充）</li>
<li><code>drawImage(img,x,y,width,height)</code>:绘制图像</li>
<li><code>scale(scalewidth,scaleheight)</code>:缩放当前绘图</li>
<li><code>save()</code>:保存当前环境的状态。 该方法的使用是将之前绘图的属性进行缓存，使之后的绘图能够独立出来</li>
<li><code>restore()</code>:返回之前保存过的路径状态和属性。 即是消除<code>save()</code>的影响，让绘图回到原先的状态</li>
<li><code>beginPath()</code>: 开始一条新的路径，该方法将消除方法调用前的绘图影响。 通常我们在一个新的绘图前都会使用该方法，目的是杜绝之后的<code>stroke</code>或<code>fill</code>填充当前图形。</li>
<li><code>closePath()</code>:创建当前点到开始点的路径，即闭合路径，常用在三角形的第 3 边绘制。</li>
<li><code>isPointInPath(x,y)</code>:判断指定的点是否在当前路径上。</li>
<li><code>clearRect(x,y,width,height)</code>：清除画布指定区域的绘图。该方法很重要，在 canvas 中只有该方法可以清除绘图，在重绘时常常用到。</li>
<li>初始化画布: const canvas &#x3D; document.getElementById(this.props.canvasId);</li>
</ul>
<h1 id="js-函数封装为什么最后要加-return"><a href="#js-函数封装为什么最后要加-return" class="headerlink" title="js 函数封装为什么最后要加 return"></a>js 函数封装为什么最后要加 return</h1><p>return 主要是为了返回数据， 的变量是独立存储空间，是一种深拷贝呗，防止变量污染 ; 有 return 的函数不一定没有副作用，没有 return 的必然有某种副作用。 终止函数执行，或者可以抛出值，供外界使用</p>
<h1 id="ES6-公用立体轮播组件的封装及使用"><a href="#ES6-公用立体轮播组件的封装及使用" class="headerlink" title="ES6 公用立体轮播组件的封装及使用"></a>ES6 公用立体轮播组件的封装及使用</h1><p><strong>容易产生 bug 的点</strong></p>
<p>当前图片需要一个背景框，如上图所见白色框，白色框为漂浮于当前轮播图片上方；轮播图可以点击跳转到其他网页，但是由于存在层级关系，白色款会挡住轮播图，导致无法跳转</p>
<p><strong>解决思路</strong></p>
<p>将白色框设置为 a 链接，当图片滚动的时候设置 a 链接跳转链接为当前轮播图应该跳转的链接，如头图。</p>
<h1 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h1><p>1.for … in 循环遍历对象自身的和继承的可枚举属性(循环遍历对象自身的和继承的可枚举属性(不含 Symbol 属性).).</p>
<p>2、使用 Object.keys()遍历 (返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含 Symbol 属性).).</p>
<p>3.Object.getOwnPropertyNames(obj),返回一个数组,包含对象自身的所有属性(不含 Symbol 属性,但是包括不可枚举属性).</p>
<p>4、使用 Reflect.ownKeys(obj)遍历</p>
<p>返回一个数组,包含对象自身的所有属性,不管属性名是 Symbol 或字符串,也不管是否可枚举.</p>
<h1 id="for-遍历数组"><a href="#for-遍历数组" class="headerlink" title="for 遍历数组"></a>for 遍历数组</h1><p>使用 forEach 遍历</p>
<p>使用 for..in..遍历 : 可枚举性决定了这个属性能否被 for in 遍历到。 遍历的得到的 index 并不是一个数字,而是一个 string,可能无意进行字符串计算</p>
<p>使用 for-of 遍历 :不仅支持数组，还支持大多数类数组对象，例如 DOM NodeList 对象.</p>
<p>也支持字符串遍历，它将字符串视为一系列的 Unicode 字符来进行遍历.</p>
<h1 id="交集-并集-差集"><a href="#交集-并集-差集" class="headerlink" title="交集,并集,差集"></a>交集,并集,差集</h1><p>假设有两个数集 A 和 B，A 包含 1、2、3，B 包含 3、4、5，这两个数集中很好发现，都有数字 3，那么如图所示，A 和 B 交在一起的部分 3，就是 A 和 B 的<strong>交集</strong>。</p>
<p>A 和 B 交集外的 1、2 还有 4、5，这一部分就是交集外的部分，我们称他们为 A 和 B 的<strong>差集</strong>。</p>
<p><strong>并集</strong>字面意思就比较好理解了，并在一起，那么就是两组数集放在一起， 并集没有重复数字出现</p>
<h1 id="双飞翼布局和圣杯布局"><a href="#双飞翼布局和圣杯布局" class="headerlink" title="双飞翼布局和圣杯布局"></a>双飞翼布局和圣杯布局</h1><p>两者的功能相同，都是为了实现一个两侧宽度固定，中间宽度自适应的三栏布局。（中间先加载渲染）</p>
<p>主要的不同之处就是在解决中间部分被挡住的问题时，采取的解决办法不一样，圣杯布局是在父元素上设置了 padding-left 和 padding-right，在给左右两边的内容设置 position 为 relative，通过左移和右移来使得左右两边的内容得以很好的展现，而双飞翼则是在 center 这个 div 中再加了一个 div 来放置内容，在给这个新的 div 设置 margin-left 和 margin-right 。</p>
<p><strong>圣杯布局</strong><br>使用<code>float</code>布局框架 ， 用<code>margin</code>为负值 ， <code>position: relative</code>定位</p>
<p>( 1）兼容性好，兼容若有主流浏览器，包括万恶的 IE6<br>（2）可以实现主要内容的优先加载</p>
<p>个人还是推荐使用双飞翼布局</p>
<h1 id="js-调用本地-json-文件"><a href="#js-调用本地-json-文件" class="headerlink" title="js 调用本地 json 文件"></a>js 调用本地 json 文件</h1><p>使用浏览器访问本地文件时，一般地址是<code>file://</code>开头的本地文件地址。</p>
<p>而访问远程文件时，一般地址是<code>http://</code>或者<code>https://</code>开头的地址，表示这个文件通过 http &#x2F;https 协议访问的。</p>
<p>由于浏览器的同源策略保护，导致通过 ajax 请求本地文件时会出现<strong>跨域问题</strong></p>
<p><strong>解决方法</strong></p>
<p>2.1 JSONP 方式</p>
<p>利用 script&#x2F;img&#x2F;iframe 标签的 src 不受同源策略影响的特性</p>
<p>将 json 文件的内容作为参数放入 getJson 函数中</p>
<p>2.2 运行本地 Web 服务器</p>
<ul>
<li>默认情况下，在本地 Web 服务器上的端口 8000 上运行工作目录中的内容。可以浏览器中输入 URL<code>http://localhost:8000</code>访问此服务器</li>
<li>此时会看到文件内容目录，点击即可查看想运行的文件。</li>
<li>在 js 文件中，将 json 文件地址改为 localhost:8000 开头的地址，之后再<strong>通过这种方式</strong>打开 html 页面</li>
</ul>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序的一次划分算法从两头交替搜索，因此其时间复杂度是 O(n)；而整个快速排序算法的时间复杂度与划分的趟数有关。</p>
<h1 id="JavaScript-中的-callee-与-caller"><a href="#JavaScript-中的-callee-与-caller" class="headerlink" title="JavaScript 中的 callee 与 caller"></a>JavaScript 中的 callee 与 caller</h1><p><strong><code>callee</code></strong> 是 <code>arguments</code> 对象的一个属性。它可以用于引用该函数的函数体内当前正在执行的函数。</p>
<p>这在函数的名称是未知时很有用，例如在没有名称的函数表达式 (也称为“匿名函数”)内。</p>
<p><strong>arguments 在哪个函数里面就指代哪个函数</strong></p>
<p><strong>实现 100 的阶乘</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = (<span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n * <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(n - <span class="number">1</span>) <span class="comment">// ---》 指向函数引用</span></span><br><span class="line">&#125;)(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p><strong>caller</strong></p>
<p>函数本身的属性，不是 arguments 的属性。</p>
<p>argument 身上只有 callee 和 length。</p>
<p>在 es5.0 严格模式中，不让使用 callee 和 caller。</p>
<h1 id="js-的箭头函数设计时为什么不能使用-arguments"><a href="#js-的箭头函数设计时为什么不能使用-arguments" class="headerlink" title="js 的箭头函数设计时为什么不能使用 arguments"></a>js 的箭头函数设计时为什么不能使用 arguments</h1><p>let f &#x3D; (…args) &#x3D;&gt; console.log(…args)</p>
<p>原因嘛，跟性能相关吧</p>
<p>我猜是确定的参数列表跟变来变去的参数列表在底层执行的时候性能有差异</p>
<h1 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h1><p><strong>长得象数组，可以当成数组来用，但却不是数组。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>) <span class="comment">// [1, 3, 3, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">arguments</span>.<span class="title function_">push</span>(<span class="number">7</span>) <span class="comment">// 报错   是数组就会有push方法，但是这个没有。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<p><strong>类数组的组成部分：</strong><br>属性要为索引（数字）属性，必须有 length 属性，最好加上 push。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">push</span>: <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>,</span><br><span class="line">  <span class="attr">splice</span>: <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">splice</span>,</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">push</span>(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, push: ƒ, splice: ƒ]</span></span><br></pre></td></tr></table></figure>

<p><strong>类数组的 push 方法怎么实现的?</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span> (<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">length</span>] = target</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">length</span>++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ol>
<li><p>可以利用属性名模拟数组的特性</p>
</li>
<li><p>可以动态的增长 length 属性</p>
</li>
<li><p>如果强行让类数组调用 push 方法，则会根据 length 属性值的位置进行属性的扩充。</p>
</li>
</ol>
<h1 id="JavaScript-数组去重"><a href="#JavaScript-数组去重" class="headerlink" title="JavaScript 数组去重"></a>JavaScript 数组去重</h1><p><strong>把数组的属性值当作对象的属性名来进行去重。</strong></p>
<p><strong>利用对象的特性，对象不可能有两个属性名。</strong></p>
<p><strong>数组去重方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unique</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> temp = &#123;&#125;,</span><br><span class="line">    arr = [],</span><br><span class="line">    len = <span class="variable language_">this</span>.<span class="property">length</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!temp[<span class="variable language_">this</span>[i]]) &#123;</span><br><span class="line">      temp[<span class="variable language_">this</span>[i]] = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">      arr.<span class="title function_">push</span>(<span class="variable language_">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<h1 id="JavaScript-数组排序方法"><a href="#JavaScript-数组排序方法" class="headerlink" title="JavaScript 数组排序方法"></a>JavaScript 数组排序方法</h1><p><strong>升序</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">9</span>]</span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化版</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">9</span>]</span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x - y</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>降序</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">9</span>]</span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化版</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">9</span>]</span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> y - x</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>乱序</strong></p>
<p>给一个有序的数组，乱序 —》 随机打乱原数组的顺序，然后一次性返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">0.5</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>对象排序</strong></p>
<p>给一个对象按照年龄排序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cheng = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;cheng&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">sex</span>: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">  <span class="attr">face</span>: <span class="string">&#x27;handsome&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> deng = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;deng&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">40</span>,</span><br><span class="line">  <span class="attr">sex</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">face</span>: <span class="string">&#x27;amazing&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> zhang = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zhang&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">sex</span>: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [cheng, deng, zhang]</span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="property">age</span> - y.<span class="property">age</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>数组按照字符串长度排序</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;ac&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;asdf&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;edc&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;r&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;awertyuiovbnm&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;3456&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;poiuytre&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;mmjuyhn&#x27;</span>,</span><br><span class="line">]</span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="property">length</span> - y.<span class="property">length</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>数组按照字节长度来排序</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">retBytes</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> num = str.<span class="property">length</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="title function_">charCodeAt</span>(i) &gt; <span class="number">255</span>) &#123;</span><br><span class="line">      num++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;deng老&#x27;</span>, <span class="string">&#x27;wu嗯&#x27;</span>, <span class="string">&#x27;qin亲&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;老邓&#x27;</span>, <span class="string">&#x27;qwerty&#x27;</span>, <span class="string">&#x27;asdff&#x27;</span>]</span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">retBytes</span>(x) - <span class="title function_">retBytes</span>(y)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="隐式类型"><a href="#隐式类型" class="headerlink" title="隐式类型"></a>隐式类型</h1><p>声明的同时必须初始化，因为编译时要根据初始化值类型来推断 var</p>
<p>使用 var 定义个变量后，将不能修改数据类型，因为初始化的时候已经确定 var 数据类型了</p>
<p>比如 var i&#x3D;10,i&#x3D;”hello” 出现错误：</p>
<p>无法将类型“string”隐式转换为“int” F:\基础学习\mvc 基础知识\02 新语法\02 隐士类型\Program.cs 16 17 02 隐士类型</p>
<p>var 定义的变量只能作为方法局部变量使用。类的成员字段、方法的形参和返回值都不能使用！因为无法编译时确定他们的类型</p>
<p>初始化表达式不能是匿名函数和 null。</p>
<h1 id="显示类型"><a href="#显示类型" class="headerlink" title="显示类型"></a>显示类型</h1><p>一般情况下，数据的类型的转换通常是由编译系统自动进行的，不需要人工干预，所以被称为隐式类型转换。但如果程序要求一定要将某一类型的数据转换为另外一种类型，则可以利用强制类型转换运算符进行转换，这种强制转换过程称为显式转换</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><strong>外观模式</strong></p>
<p>兼容浏览器事件绑定封装接口</p>
<p>设计初期，应该要有意识地将不同的两个层分离，比如经典的三层结构，在数据访问层和业务逻辑层、业务逻辑层和表示层之间建立外观 Facade<br>在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观 Facade 可以提供一个简单的接口，减少他们之间的依赖。<br>在维护一个遗留的大型系统时，可能这个系统已经很难维护了，这时候使用外观 Facade 也是非常合适的，为系系统开发一个外观 Facade 类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和 Facade 对象交互，Facade 与遗留代码交互所有的复杂工作。</p>
<p><strong>优点</strong></p>
<ul>
<li>减少系统相互依赖。</li>
<li>提高灵活性。</li>
<li>提高了安全性</li>
</ul>
<p><strong>缺点</strong></p>
<p>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p>
<p><strong>代理模式</strong></p>
<p>是为一个对象提供一个代用品或占位符，以便控制对它的访问<br>假设当 A 在心情好的时候收到花，小明表白成功的几率有 60%，而当 A 在心情差的时候收到花，小明表白的成功率无限趋近于 0。小明跟 A 刚刚认识两天，还无法辨别 A 什么时候心情好。如果不合时宜地把花送给 A，花 被直接扔掉的可能性很大，这束花可是小明吃了 7 天泡面换来的。但是 A 的朋友 B 却很了解 A，所以小明只管把花交给 B，B 会监听 A 的心情变化，然后选 择 A 心情好的时候把花转交给 A</p>
<p><strong>场景</strong></p>
<p>HTML 元 素事件代理</p>
<p><strong>优点</strong></p>
<ul>
<li>代理模式能将代理对象与被调用对象分离，降低了系统的耦合度。代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用</li>
<li>代理对象可以扩展目标对象的功能；通过修改代理对象就可以了，符合开闭原则；</li>
</ul>
<p><strong>缺点</strong></p>
<p>处理请求速度可能有差别，非直接访问存在开销</p>
<p><strong>工厂模式</strong></p>
<p>工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。</p>
<p><strong>场景</strong></p>
<ul>
<li>如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择</li>
<li>将 new 操作简单封装，遇到 new 的时候就应该考虑是否用工厂模式；</li>
<li>需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>创建对象的过程可能很复杂，但我们只需要关心创建结果。</li>
<li>构造函数和创建者分离, 符合“开闭原则”</li>
<li>一个调用者想创建一个对象，只要知道其名称就可以了。</li>
<li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>添加新产品时，需要编写新的具体产品类,一定程度上增加了系统的复杂度</li>
<li>考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度</li>
</ul>
<p><strong>什么时候不用</strong></p>
<ul>
<li>当被应用到错误的问题类型上时,这一模式会给应用程序引入大量不必要的复杂性.除非为创建对象提供一个接口是我们编写的库或者框架的一个设计上目标,否则我会建议使用明确的构造器,以避免不必要的开销。</li>
<li>由于对象的创建过程被高效的抽象在一个接口后面的事实,这也会给依赖于这个过程可能会有多复杂的单元测试带来问题。</li>
</ul>
<p><strong>单例模式</strong></p>
<p>顾名思义，单例模式中 Class 的实例个数最多为 1。当需要一个对象去贯穿整个系统执行某些任务时，单例模式就派上了用场。而除此之外的场景尽量避免单例模式的使用，因为单例模式会引入全局状态，而一个健康的系统应该避免引入过多的全局状态。</p>
<p><strong>场景</strong></p>
<ul>
<li>定义命名空间和实现分支型方法</li>
<li>登录框</li>
<li>vuex 和 redux 中的 store</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>划分命名空间，减少全局变量</li>
<li>增强模块性，把自己的代码组织在一个全局变量名下，放在单一位置，便于维护</li>
<li>且只会实例化一次。简化了代码的调试和维护</li>
</ul>
<p><strong>缺点</strong></p>
<p>由于单例模式提供的是一种单点访问，所以它有可能导致模块间的强耦合<br>从而不利于单元测试。无法单独测试一个调用了来自单例的方法的类，而只能把它与那个单例作为一个单元一起测试。</p>
<p><strong>策略模式</strong></p>
<p>策略模式简单描述就是：对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。把它们一个个封装起来，并且使它们可以互相替换</p>
<p><strong>场景</strong></p>
<ul>
<li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的’行为’，那么-<br>使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li>
<li>一个系统需要动态地在几种算法中选择一种。</li>
<li>表单验证</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>利用组合、委托、多态等技术和思想，可以有效的避免多重条件选择语句</li>
<li>提供了对开放-封闭原则的完美支持，将算法封装在独立的 strategy 中，使得它们易于切换，理解，易于扩展</li>
<li>利用组合和委托来让 Context 拥有执行算法的能力，这也是继承的一种更轻便的代替方案</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><p>会在程序中增加许多策略类或者策略对象</p>
</li>
<li><p>要使用策略模式，必须了解所有的 strategy，必须了解各个 strategy 之间的不同点，这样才能选择一个合适的 strategy</p>
</li>
</ul>
<p><strong>迭代器模式</strong></p>
<p>迭代器模式简单的说就是提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p>
<p>迭代器模式解决了以下问题：</p>
<ul>
<li>提供一致的遍历各种数据结构的方式，而不用了解数据的内部结构</li>
<li>提供遍历容器（集合）的能力而无需改变容器的接口</li>
</ul>
<p>一个迭代器通常需要实现以下接口：</p>
<ul>
<li>hasNext()：判断迭代是否结束，返回 Boolean</li>
<li>next()：查找并返回下一个元素</li>
</ul>
<p>ES6 提供了更简单的迭代循环语法 for…of，使用该语法的前提是操作对象需要实现 可迭代协议（The iterable protocol），简单说就是该对象有个 Key 为 Symbol.iterator 的方法，该方法返回一个 iterator 对象。</p>
<p><strong>观察者模式（Observer Pattern）</strong></p>
<p>观察者模式又称发布-订阅模式（Publish&#x2F;Subscribe Pattern），是我们经常接触到的设计模式，日常生活中的应用也比比皆是，比如你订阅了某个博主的频道，当有内容更新时会收到推送；又比如 JavaScript 中的事件订阅响应机制。观察者模式的思想用一句话描述就是：被观察对象（subject）维护一组观察者（observer），当被观察对象状态改变时，通过调用观察者的某个方法将这些变化通知到观察者。<br>观察者模式中 Subject 对象一般需要实现以下 API：</p>
<ul>
<li><p>subscribe(): 接收一个观察者 observer 对象，使其订阅自己</p>
</li>
<li><p>unsubscribe(): 接收一个观察者 observer 对象，使其取消订阅自己</p>
</li>
<li><p>fire(): 触发事件，通知到所有观察者</p>
<p><strong>场景</strong></p>
<p>DOM 事件</p>
<p>vue 响应式的实现</p>
<p><strong>优点</strong></p>
<p>支持简单的广播通信，自动通知所有已经订阅过的对象<br>目标对象与观察者之间的抽象耦合关系能单独扩展以及重用<br>增加了灵活性<br>观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。</p>
<p><strong>缺点</strong></p>
<p>过度使用会导致对象与对象之间的联系弱化，会导致程序难以跟踪维护和理解</p>
</li>
</ul>
<p><strong>中介者模式</strong></p>
<p>在中介者模式中，中介者（Mediator）包装了一系列对象相互作用的方式，使得这些对象不必直接相互作用，而是由中介者协调它们之间的交互，从而使它们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用，保证这些作用可以彼此独立的变化。<br>中介者模式和观察者模式有一定的相似性，都是一对多的关系，也都是集中式通信，不同的是中介者模式是处理同级对象之间的交互，而观察者模式是处理 Observer 和 Subject 之间的交互。中介者模式有些像婚恋中介，相亲对象刚开始并不能直接交流，而是要通过中介去筛选匹配再决定谁和谁见面。</p>
<p><strong>场景</strong></p>
<p>例如购物车需求，存在商品选择表单、颜色选择表单、购买数量表单等等，都会触发 change 事件，那么可以通过中介者来转发处理这些事件，实现各个事件间的解耦，仅仅维护中介者对象即可。</p>
<p><strong>优点</strong></p>
<ul>
<li>使各对象之间耦合松散，而且可以独立地改变它们之间的交互</li>
<li>中介者和对象一对多的关系取代了对象之间的网状多对多的关系</li>
<li>如果对象之间的复杂耦合度导致维护很困难，而且耦合度随项目变化增速很快，就需要中介者重构代码</li>
</ul>
<p><strong>缺点</strong></p>
<p>系统中会新增一个中介者对象，因为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介 者对象自身往往就是一个难以维护的对象。</p>
<p><strong>访问者模式（Visitor Pattern）</strong></p>
<p>访问者模式 是一种将算法与对象结构分离的设计模式，通俗点讲就是：访问者模式让我们能够在不改变一个对象结构的前提下能够给该对象增加新的逻辑，新增的逻辑保存在一个独立的访问者对象中。访问者模式常用于拓展一些第三方的库和工具。</p>
<p>访问者模式的实现有以下几个要素：</p>
<ul>
<li><p>Visitor Object：访问者对象，拥有一个 visit()方法</p>
</li>
<li><p>Receiving Object：接收对象，拥有一个 accept() 方法</p>
</li>
<li><p>visit(receivingObj)：用于 Visitor 接收一个 Receiving Object</p>
</li>
<li><p>accept(visitor)：用于 Receving Object 接收一个 Visitor，并通过调用 Visitor 的 visit() 为其提供获取 Receiving Object 数据的能力</p>
</li>
<li><p><strong>场景</strong></p>
<ul>
<li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作</li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>符合单一职责原则</li>
<li>优秀的扩展性</li>
<li>灵活性</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>具体元素对访问者公布细节，违反了迪米特原则</li>
<li>违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</li>
<li>具体元素变更比较困难</li>
</ul>
</li>
</ul>
<p><strong>1.结构型模式（Structural Patterns）： 通过识别系统中组件间的简单关系来简化系统的设计。</strong></p>
<p>2.<strong>创建型模式</strong>（Creational Patterns）： 处理对象的创建，根据实际情况使用合适的方式创建对象。常规的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。</p>
<p>3.<strong>行为型模式</strong>（Behavioral Patterns）： 用于识别对象之间常见的交互模式并加以实现，如此，增加了这些交互的灵活性</p>
<h1 id="跟你匹配的后端技术"><a href="#跟你匹配的后端技术" class="headerlink" title="跟你匹配的后端技术"></a>跟你匹配的后端技术</h1><p>java</p>
<h1 id="堆和栈的概念和区别"><a href="#堆和栈的概念和区别" class="headerlink" title="堆和栈的概念和区别"></a>堆和栈的概念和区别</h1><p>Java 程序在运行时都要开辟空间，任何软件在运行时都要在内存中开辟空间，Java 虚拟机运行时也是要开辟空间的。JVM 运行时在内存中开辟一片内存区域，启动时在自己的内存区域中进行更细致的划分，因为虚拟机中每一片内存处理的方式都不同，所以要单独进行管理。</p>
<p>栈内存:栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for 循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。</p>
<p>堆内存:存储的是数组和对象（其实数组就是对象），凡是 new 建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java 有垃圾回收机制不定时的收取。</p>
<p>比如主函数里的语句 int [] arr&#x3D;new int [3];在内存中是怎么被定义的：</p>
<p>主函数先进栈，在栈中定义一个变量 arr,接下来为 arr 赋值，但是右边不是一个具体值，是一个实体。实体创建在堆里，在堆里首先通过 new 关键字开辟一个空间，内存在存储数据的时候都是通过地址来体现的，地址是一块连续的二进制，然后给这个实体分配一个内存地址。数组都是有一个索引，数组这个实体在堆内存中产生之后每一个空间都会进行默认的初始化（这是堆内存的特点，未初始化的数据是不能用的，但在堆里是可以用的，因为初始化过了，但是在栈里没有），不同的类型初始化的值不一样。所以堆和栈里就创建了变量和实体：</p>
<p><strong>那么堆和栈是怎么联系起来的呢?</strong></p>
<p>我们刚刚说过给堆分配了一个地址，把堆的地址赋给 arr，arr 就通过地址指向了数组。所以 arr 想操纵数组时，就通过地址，而不是直接把实体都赋给它。这种我们不再叫他基本数据类型，而叫引用数据类型。称为 arr 引用了堆内存当中的实体。</p>
<p>如果当 int [] arr&#x3D;null;</p>
<p>arr 不做任何指向，null 的作用就是取消引用数据类型的指向。</p>
<p>当一个实体，没有引用数据类型指向的时候，它在堆内存中不会被释放，而被当做一个垃圾，在不定时的时间内自动回收，因为 Java 有一个自动回收机制，（而 c++没有，需要程序员手动回收，如果不回收就越堆越多，直到撑满内存溢出，所以 Java 在内存管理上优于 c++）。自动回收机制（程序）自动监测堆里是否有垃圾，如果有，就会自动的做垃圾回收的动作，但是什么时候收不一定。</p>
<p>所以堆与栈的区别很明显：</p>
<p>1.栈内存存储的是局部变量而堆内存存储的是实体；</p>
<p>2.栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</p>
<p>3.栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。</p>
<h1 id="JavaScript-的深度克隆"><a href="#JavaScript-的深度克隆" class="headerlink" title="JavaScript 的深度克隆"></a>JavaScript 的深度克隆</h1><p><strong>论是原始值还是引用值都是各自独立(互不影响)的。</strong></p>
<p><strong>原始值的拷贝，直接复制过去。引用值复制的是地址。</strong></p>
<p><strong>深度克隆过程：</strong></p>
<p>&#x2F;&#x2F; 先遍历对象 for(var prop in obj)</p>
<p>&#x2F;&#x2F; 1. 判断是不是原始值 typeof() object</p>
<p>&#x2F;&#x2F; 2. 判断是数组还是对象 constructor instanceof toString(推荐)</p>
<p>&#x2F;&#x2F; 3. 建立相应的数组或对象</p>
<p><strong>三目运算符简化代码</strong></p>
<h1 id="JavaScript-判断属性是不是自己的方法"><a href="#JavaScript-判断属性是不是自己的方法" class="headerlink" title="JavaScript 判断属性是不是自己的方法"></a>JavaScript 判断属性是不是自己的方法</h1><p><strong>hasOwnProperty</strong></p>
<p><strong>—》 判断这个属性是不是自己的（不会把原型上的属性拿出来）</strong></p>
<p><strong>in 操作符 (很少用)</strong></p>
<p><strong>—》判断能不能在这个对象上调用这个属性。（继承来的也能访问）</strong></p>
<p>- 和 hasOwnProperty 差不多</p>
<p><strong>instanceof</strong></p>
<p><strong>—》看 A 对象的原型链上 有没有 B 的原型</strong></p>
<p>- 类似 in</p>
<h1 id="js-中-indexof-为什么不可以全局查找？"><a href="#js-中-indexof-为什么不可以全局查找？" class="headerlink" title="js 中 indexof 为什么不可以全局查找？"></a>js 中 indexof 为什么不可以全局查找？</h1><p>为了性能更好，所以只查找第一个吧！</p>
<h1 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h1><p><strong>Audio 对象</strong></p>
<p>使用 ES6 语法，引入之前说到的 svg icon.js，获取页面节点，创建 audio 对象，初始化音乐列表、每首歌的下标</p>
<p><strong>获取数据、绑定事件</strong></p>
<p>在 start 函数里面使用 fetch 获取 mock 好的音乐数据接口，在 bind 里面 绑定事件</p>
<p>注意 除了箭头函数外 其他的 this 都会改变，如果想让里面的 this 和外面一样，要在外面先声明一下</p>
<p><strong>加载歌曲、歌词</strong></p>
<p>数据获取好后就可以加载歌曲、歌词，歌词一般先在 html 里写好假歌词，数据到了再渲染就行了</p>
<p><strong>歌词部分</strong></p>
<p>这一部分比较复杂，涉及到样式重新调整，正则、排序等，是较难的一个部分，每首歌的歌词结构、形式都是不一样的</p>
<p>每个时间点播放到相应的歌词，或者不同的时间播放同样的歌词。</p>
<p><strong>放入页面</strong></p>
<p>先在 html 里放入假歌词，然后调整一下样式：居中、line-height、font-size、是否溢出隐藏等，然后默认高亮</p>
<p><strong>歌词滚动</strong></p>
<p>当高亮到居中歌词后面，歌词就需要往上滚动了，也就是整体往上滚动，可以使用 css3 偏移或者 js scroll，用 scroll 无法连续缓慢的滚动，会突然变掉，所以推荐使用 transition、tramsform translateY(-xxx px)，然后考虑滚动多少、滚动到谁身上 偏移高度+容器一半的高度就可以使高亮歌词居中，offsetTop 就是高亮歌词距离滚动顶部的距离，offsetHeight 就是高亮歌词距离容器顶部的距离，offsetTop - offsetHeight&#x2F;2 就是高亮歌词居中的位置</p>
<p>把复杂的歌词对象变成数组[[‘时间 xxx’, ‘歌词 xxx’], [], …]，每个元素有两项，第一项是时间，第二项是歌词。</p>
<p>过滤掉空的时间；得到对应歌词的字符串，用正则过滤掉中括号里的时间内容，得到纯歌词字符串；过滤掉不统一的时间都变成毫秒数；创建新数组，放入毫秒数和歌词字符串。 把歌词渲染到页面 DOM 结构的部分</p>
<h1 id="移动端手势"><a href="#移动端手势" class="headerlink" title="移动端手势"></a><strong>移动端手势</strong></h1><p>因为需要页面切换，播放页面 -&gt; 歌词页面；歌词页面 -&gt; 播放页面，所以需要在页面上左滑右滑；</p>
<p>PC 页面是没有 click 事件的，手机页面使用的是 ontouchstart、ontouchmove 等；</p>
<p>一般都是使用一些手势库</p>
<p>使用函数节流，让触控划动不要那么敏感，使用 setTimeout 定时器加点延迟，划动一小点距离事件才会切换，再加上 transition 过渡丝滑一下。</p>
<h1 id="Scss"><a href="#Scss" class="headerlink" title="Scss"></a>Scss</h1><p>Sass(Syntactically Awesome Style Sheets) ,是一种 css 预处理器和一种语言, 它可以用来定义一套新的语法规则和函数，以加强和提升 CSS. 它有很多很好的特性，但是它有类似 Ruby 的语法，没有花括号，没有分号，遵循严格的缩进</p>
<p>它在书写规则，变量命名方面和 CSS 代码有着很大的区别。于是，后来官方在 2010 年推出了一个全新的语法，叫做 SCSS, 意思是 Sassy CSS. 这个语法带来了对 CSS 友好的语法，试图弥合 Sass 和 CSS 之间的差别.</p>
<p><strong>嵌套</strong></p>
<p>可以把子元素放入父元素里面</p>
<p><strong>变量</strong></p>
<p>在 CSS 文件中，我们经常会用到颜色 color， 可能好几个元素的 CSS 样式都会用到同样的一种颜色，因为网站往往是一个统一的风格。 这样，我们如果一旦要更改这个颜色，我们就要更改整个 css 文件中的所有地方。而变量解决了这个问题，我们可以把一个颜色值赋给一个变量，所有用到这个颜色的地方，都用这个变量替代。这样，需要更改颜色时，只需要修改这个变量的值就可以了. 当然，CSS 中的宽度，长度等也可以类似这样，使用统一的变量来进行.</p>
<p><strong>3. 局部</strong></p>
<p>Sass 可以通过使用局部系统来把样式表分成多份文件，根据不同的需求组织不同部分的样式表，形成不同的 css 文件</p>
<p>比如，把页眉样式写在页眉样式表中，类似的有 页脚样式表，导航样式表,按钮样式表….我们公司在开发多个项目时，都采用了这种方法，形成多个 scss 文件，比如有</p>
<p>colours.scss, typography.scss, layout.scss, footer.scss, header.scss, navigation.scss, blocks.scss, forms.scss, slider.scss, buttons.scss, margins.scss,icons.scss, tables.scss..</p>
<p><strong>@import</strong>命令也可以用于在 html 文件中导入外部的 css 文件</p>
<p><strong>import 规则一定要先于除了 @charset 的其他任何 CSS 规则</strong></p>
<p>使用@import 命令进行媒体查询</p>
<p>媒体查询是 CSS3 中出现的新特征，在 css 中使用 media 关键字来指定, 一个媒体查询由一个可选的媒体类型和零个或多个使用媒体功能的限制了样式范围的表达式组成，比如宽度，高度和颜色。 它允许内容的呈现针对一个特定范围的输出设备进行裁剪，而不必改变内容本身.</p>
<p><strong>混合宏</strong></p>
<p>使用 Sass 的一个很大的特性是，混合宏. 混合宏是很小的代码片段(类似局部), 使用@mixin 标志来标识 你可以在文件中的任何部分，使用@include 标志来复用这个混合宏.</p>
<p>混合宏结合变量使用，是个很普遍的例子, 最常见的例子就是创建圆角按钮. 创建一段实现圆角代码的混合宏，用传入的变量来代替圆角值, 这样，可以根据传入变量值不同，实现不同的圆角按钮</p>
<p>公司项目中，前端 css 文件我们都是写 SCSS 文件,然后通过@import 导入到 style.scss 文件中，最后通过 gulp 来生成 style.css 文件</p>
<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>一个回调函数，也被称为高阶函数，是一个被作为参数传递给另一个函数（otherFunction）的函数，回调函数在 otherFunction 中被调用。一个回调函数本质上是一种编程模式，因此，使用回调函数也叫做回调模式。 在项目中一般将一个函数作为参数传递给 click 方法。click 方法会调用我们传递给它的函数。</p>
<p><strong>回调函数是如何运作的？</strong></p>
<p>因为函数在 JavaScript 中是第一类对象，我们像对待对象一样对待函数，因此我们能像传递变量一样传递函数，在函数中返回函数，在其他函数中使用函数。当我们将一个回调函数作为参数传递给另一个函数时，我们仅仅传递了函数定义。我们并没有在参数中执行函数。我们并不传递像我们平时执行函数一样带有一对小括号（）的函数。</p>
<p>需要注意的很重要的一点是回调函数并不会马上被执行。它会在包含它的函数内的某个特定时间被“回调”。</p>
<p><strong>回调函数是闭包</strong></p>
<p>能够将一个回调函数作为变量传递给另一个函数时，这个回调函数在包含它的函数内的某一点执行，就好像这个回调函数是在它包含的函数中定义一样。这意味着回调函数本质上是一个闭包。</p>
<p>闭包能够进入包含它的函数的作用域，因此回调函数能够获取包含它的函数中的变量，以及全局作用域中的变量。</p>
<p><strong>实现回调函数的基本原理</strong></p>
<p><strong>1：使用命名或匿名函数作为回调</strong></p>
<p>使用在参数位置定义的匿名函数作为回调函数。这是在回调函数使用中的一种普遍的模式。另一种常见的模式是定义一个命名函数并将命名函数名作为变量传递给函数</p>
<p><strong>传递参数给回调函数</strong></p>
<p>既然回调函数在执行时仅仅是一个普通函数，我们就能给它传递参数。我们能够传递任何包含它的函数的属性（或者全局属性）作为回调函数的参数。</p>
<p><strong>在执行之前确保回调函数是一个函数</strong></p>
<p>在调用之前检查作为参数被传递的回调函数确实是一个函数，这样的做法是明智的。这也是一个实现条件回调函数的最佳时间。</p>
<p><strong>使用 this 对象的方法作为回调函数时的问题</strong></p>
<p>当回调函数是一个 this 对象的方法时，我们必须改变执行回调函数的方法来保证 this 对象的上下文。否则如果回调函数被传递给一个全句函数，this 对象要么指向全局 window 对象。要么指向包含方法的对象。</p>
<p><strong>使用 Call 和 Apply 函数来保存 this</strong></p>
<p>每个 JavaScript 中的函数都有两个方法：Call 和 Apply。而这些函数被用来设置函数内部的 this 对象以及给此函数传递变量。call 接受的第一个参数为被用来在函数内部当做 this 的对象，传递给函数的参数被挨个传递。apply 函数的第一个参数也是在函数内部作为 this 的对象，然而最后一个参数却是传递给函数的值的数组。</p>
<p><strong>允许多重回调函数</strong></p>
<p>我们可以将不止一个的回调函数作为参数传递给一个函数，就像我们能够传递不止一个变量一样。</p>
<h1 id="受控组件与非受控组件"><a href="#受控组件与非受控组件" class="headerlink" title="受控组件与非受控组件"></a>受控组件与非受控组件</h1><p><strong>受控组件</strong></p>
<ul>
<li><p>HTML 中的表单元素是可输入的，也就是有自己的可变状态</p>
</li>
<li><p>而 React 中可变状态通常保存在 state 中，并且只能通过<code>setState()</code> 方法来修改</p>
</li>
<li><p>React 讲 state 与表单元素值 value 绑定在一起，有 state 的值来控制表单元素的值</p>
</li>
<li><p>受控组件：值受到 react 控制的表单元素</p>
<p><strong>非受控组件</strong></p>
<ul>
<li>调用 <code>React.createRef()</code> 方法创建 ref 对象</li>
<li>将创建好的 ref 对象添加到文本框中</li>
<li>通过 ref 对象获取到文本框的值</li>
<li>非受控组件： 表单组件没有 value prop 就可以称为非受控组件</li>
</ul>
</li>
</ul>
<h1 id="响应式布局与自适应布局"><a href="#响应式布局与自适应布局" class="headerlink" title="响应式布局与自适应布局"></a>响应式布局与自适应布局</h1><p>实现不同屏幕分辨率的终端上浏览网页的不同展示方式。通过响应式设计能使网站在手机和平板电脑上有更好的浏览阅读体验。</p>
<p><strong>响应式设计的步骤</strong></p>
<p><strong>设置 Meta 标签</strong></p>
<p>大多数移动浏览器将 HTML 页面放大为宽的视图（viewport）以符合屏幕分辨率。你可以使用视图的 meta 标签来进行重置。下面的视图标签告诉浏览器，使用设备的宽度作为视图宽度并禁止初始的缩放。 在标签里加入这个 meta 标签。</p>
<p><strong>通过媒介查询来设置样式 Media Queries</strong></p>
<p>Media Queries 是响应式设计的核心。 它根据条件告诉浏览器如何为指定视图宽度渲染页面。</p>
<p><strong>设置多种试图宽度</strong></p>
<p><strong>一些注意的</strong></p>
<ol>
<li><p>宽度需要使用百分比</p>
</li>
<li><p>处理图片缩放的方法</p>
<ul>
<li>简单的解决方法可以使用百分比，但这样不友好，会放大或者缩小图片。那么可以尝试给图片指定的最大宽度为百分比。假如图片超过了，就缩小。假如图片小了，就原尺寸输出。</li>
</ul>
<p><strong>其他属性</strong></p>
<p>例如 <code>pre``iframe``video``img``table</code></p>
</li>
</ol>
<h1 id="typeof-使用以及-null-和-undefined-的判断区分"><a href="#typeof-使用以及-null-和-undefined-的判断区分" class="headerlink" title="typeof 使用以及 null 和 undefined 的判断区分"></a>typeof 使用以及 null 和 undefined 的判断区分</h1><p>1 typeof 的使用;这是一个运算符，不是方法</p>
<p>1.1 检测数据类型，返回的结果是一个字符串类型。有六种可能：number boolean string object function undefined</p>
<p>注意 typeof(null) 返回的是 : object</p>
<p>1.2 typeof 可以用于被声明 或者未被声明 的变量；但是未被声明的变量不能用其他运算符运算，之外的其他运算符的话，会引起错误，因为其他运算符只能用于已声明的变量上。</p>
<p>1.3 对于基本数据类型(Number Boolean String null undefined) 以及引用类型 object 的 typeof 值</p>
<p>1.3.1 类 : Object Function Array String Boolean Number Date ；这些未初始化为实例的类的 typeof 类型为 function</p>
<p>1.3.2 对象的创建方式是用关键字 new 后面跟上实例化的类的名字，当将一个函数通过 new 实例化之后，那么就创建了一个对象</p>
<p>1.3.3 基本数据类型的 typeof 的值</p>
<p><strong>2 null undefined</strong></p>
<p>2.1 null 是一个表示”无”的对象，转化为数值的时候值为 0；典型的用法是：</p>
<ul>
<li>用来初始化一个变量，该变量将来可能会被赋值成一个对象</li>
<li>用来和一个已经初始化的对象进行比较，这个变量可以是一个对象，也可以不是一个对象</li>
<li>当函数的参数期望是对象时，被用作参数传入</li>
<li>当函数返回值期望是对象时，被当做返回值输出</li>
<li>删除事件绑定,事件本身是一个 null ,是一个空的对象，可以添加</li>
<li>作为对象原型链的终点</li>
</ul>
<p><strong>2.2 undefined 是一个表示”无”的原始值，转化为数值的时候值为 NaN ；典型用法是：</strong></p>
<ul>
<li><p>变量被声明了，但是没有赋值，那么该变量的值就是 undefined</p>
</li>
<li><p>调用一个函数的时候，如果应该提供的参数没有提供，那么该参数默认是 undefined</p>
</li>
<li><p>如果一个对象的属性没有赋值，那么该属性值为 undefined</p>
</li>
<li><p>函数没有返回值的时候，默认返回 undefined;</p>
<p>2.3 如何区分二者？</p>
</li>
<li><p>&#x3D;&#x3D; 运算符只比较值，不进行类型的比较，比较之前会进行隐式转化，null&#x3D;&#x3D;undefined 返回 true.</p>
</li>
<li><p>&#x3D;&#x3D;&#x3D; 区分两者，不仅仅比较内容，还比较数据类型 null&#x3D;&#x3D;&#x3D;undefined false</p>
</li>
</ul>
<h1 id="React-中获取-DOM-节点的两种方法"><a href="#React-中获取-DOM-节点的两种方法" class="headerlink" title="React 中获取 DOM 节点的两种方法"></a>React 中获取 DOM 节点的两种方法</h1><p>React 提供的获取 DOM 元素的方法有两种，一是 react-dom 中的 findDOMNode()，二是 refs。</p>
<h1 id="1、findDOMNode"><a href="#1、findDOMNode" class="headerlink" title="1、findDOMNode"></a><strong>1、findDOMNode</strong></h1><p>findDOMNode 通常用于 React 组件的引用, 当组件被渲染到 DOM 中后，findDOMNode 会返回该组件实例对应的 DOM 节点。 如果 render()中返回 null，那么 findDOMNode()也返回 null。findDOMNode 只对已经挂载的组件有效。</p>
<h1 id="2、refs"><a href="#2、refs" class="headerlink" title="2、refs"></a><strong>2、refs</strong></h1><p>refs 多用于 React 组件内子组件的引用。使用 ref 获取 DOM 节点有两种情况：</p>
<p>（1）子组件为原生 DOM 组件：获取到的就是这个 DOM 节点。 refs 也支持字符串格式：</p>
<p>子组件为 React 组件，比如<code>：获得的就是</code>的实例，因此就可以调用&#96;&#96;的实例方法。</p>
<p>调用&#96;&#96;实例方法的方式：this.refs.myComp.method()，但并不建议这种调用方式。</p>
<h1 id="封装-type-方法"><a href="#封装-type-方法" class="headerlink" title="封装 type 方法"></a>封装 type 方法</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">思路  <span class="number">1.</span> 分两类   原始值  引用值    <span class="number">2.</span> 区分引用值</span><br></pre></td></tr></table></figure>

<h1 id="x3D-与-x3D-x3D-的区别"><a href="#x3D-与-x3D-x3D-的区别" class="headerlink" title="&#x3D;与&#x3D;&#x3D;的区别"></a>&#x3D;与&#x3D;&#x3D;的区别</h1><p>“&#x3D;&#x3D;”是关系运算符，而 bai“&#x3D;”是赋值运算符。</p>
<p>一、二者的含义不同</p>
<p>＝是赋值号；&#x3D;&#x3D;是条件判断 zhi 语句 dao 中是否相等的意思。</p>
<p>二、二者的作用不同</p>
<p>1、&#x3D;</p>
<p>作用是将一个表达式的值赋给一个左值。一个表达式或者是一个左值，或者是一个右值。所谓左值是指一个能用于赋值运算左边的表达式。左值必须能够被修改，不能是常量。我们用变量作左值，还可以看到，指针和引用也可以作左值。</p>
<p>2、&#x3D;&#x3D;</p>
<p>当左边的内容与右边的内容相同时，返回 1。其余时候返回 0。&#x3D;&#x3D;是判断两个值大小是否相同的运算符。</p>
<h1 id="js-的三目运算符"><a href="#js-的三目运算符" class="headerlink" title="js 的三目运算符"></a>js 的三目运算符</h1><p><strong>条件判断 ? 是 : 否 》》》 并且会返回值</strong></p>
<p><strong>- 相当于 if + else if + return</strong></p>
<h1 id="JavaScript-属性的表示方法"><a href="#JavaScript-属性的表示方法" class="headerlink" title="JavaScript 属性的表示方法"></a>JavaScript 属性的表示方法</h1><p><strong>obj.prop</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;abc&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>)</span><br></pre></td></tr></table></figure>

<p><strong>obj[“prop”]</strong></p>
<p><strong>—》 灵活 拼接更好</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;abc&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[<span class="string">&#x27;name&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p><strong>每当你 obj.prop 的时候，都会隐式的访问 obj[‘prop’]。</strong></p>
<h1 id="JavaScript-中的-Function-即是对象又是构造函数，Function-是如何自己构造自己的？"><a href="#JavaScript-中的-Function-即是对象又是构造函数，Function-是如何自己构造自己的？" class="headerlink" title="JavaScript 中的 Function 即是对象又是构造函数，Function 是如何自己构造自己的？"></a>JavaScript 中的 Function 即是对象又是构造函数，Function 是如何自己构造自己的？</h1><p>如果把函数看成是构建对象的唯一方法，这问题就是无解的。试想函数是“生成对象的对象”，那么第一个函数对象是没法生成的</p>
<p>解决的方法就是第一个函数对象 Function 不是由上述方法构建的。</p>
<h1 id="JavaScript-怎么区分对象和数组"><a href="#JavaScript-怎么区分对象和数组" class="headerlink" title="JavaScript 怎么区分对象和数组"></a>JavaScript 怎么区分对象和数组</h1><p><strong>1. 使用 constructor</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([].<span class="property">constructor</span>) <span class="comment">// ƒ Array() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">constructor</span>) <span class="comment">// ƒ Object() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 使用 instanceof</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Array</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj <span class="keyword">instanceof</span> <span class="title class_">Array</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 使用 toString</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([])) <span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;)) <span class="comment">// &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="JavaScript-数组"><a href="#JavaScript-数组" class="headerlink" title="JavaScript 数组"></a>JavaScript 数组</h1><p><strong>arr 表示数组的引用：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="string">&#x27;acb&#x27;</span>, <span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure>

<h1 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a><strong>数组的定义</strong></h1><p><strong>- 字面量(推荐)：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br></pre></td></tr></table></figure>

<p><strong>new Array(length&#x2F;content); —&gt; 系统自带</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>() <span class="comment">// 系统提供的构造方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>) <span class="comment">// ---&gt; 这种和字面量没什么区别</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>) <span class="comment">// ----》  表示长度为10的稀松数组。  和字面量唯一的区别。  不能写小数，会报错。</span></span><br></pre></td></tr></table></figure>

<h1 id="数组的读和写"><a href="#数组的读和写" class="headerlink" title="数组的读和写"></a><strong>数组的读和写</strong></h1><p>数组是基于对象的，数组是一种特殊的对象。</p>
<p>读:<strong>arr[unm]</strong></p>
<p><strong>写：arr[num] &#x3D; xxx;</strong></p>
<p><strong>数组常用方法</strong></p>
<p><strong>1. 改变原数组：在原来数组的基础上改变。</strong></p>
<p><strong>- push, pop, shift, unshift, sort, reverse</strong></p>
<p><strong>push：</strong>在数组的最后一位添加</p>
<p><strong>pop：</strong>把数组的最后一位剪切出去。 （不需要传参数）</p>
<p><strong>unshift：</strong>在第一位添加东西</p>
<p><strong>shift：</strong>剪切第一位。（不需要传参）</p>
<p><strong>reverse：</strong>逆转数组顺序</p>
<p><strong>sort：</strong>给数组排序（升序） 。字符串排序 ASCII 码排序。<br><strong>splice：</strong>从第几位开始，截取多少的长度，在切口处添加新的数据。</p>
<p><strong>2. 不改变原数组</strong></p>
<p><strong>- concat, join —&gt;split, toString, slice</strong></p>
<p><strong>concat：</strong>连接两个数组</p>
<p><strong>toString：</strong>把数组变成字符串展示出来</p>
<p><strong>slice：</strong>该位开始截取，截取到该位</p>
<p><strong>join：</strong>表示以什么来连接。（参数必须是字符串形式的）</p>
<p><strong>split：</strong>split 与 join 是互逆的，把字符串拆分成数组。（参数必须是字符串形式的）</p>
<p>3.<strong>数组的属性 length</strong></p>
<p><strong>length：</strong>表示数组的长度</p>
<h1 id="面向对象的三大基本特征，五大基本原则"><a href="#面向对象的三大基本特征，五大基本原则" class="headerlink" title="面向对象的三大基本特征，五大基本原则"></a>面向对象的三大基本特征，五大基本原则</h1><h1 id="1、封装"><a href="#1、封装" class="headerlink" title="1、封装"></a>1、封装</h1><p>封装就是隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别，将抽象得到的数据和行为（或功能）相结合，<strong>形成一个有机的整体</strong>，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。</p>
<p>封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员。</p>
<p>面相对象的不就是使用程序处理事情时以对象为中心去分析吗，与面向过程不同，面向过程关心处理的逻辑、流程等问题，而不关心事件主体。而面向对象即面向主体，所以我们在解决问题时应该先进行对象的封装（对象是封装类的实例，比如张三是人，人是一个封装类，张三只是对象中的一个实例、一个对象）。比如我们日常生活中的小兔子、小绵羊都可以封装为一个类。</p>
<h1 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a>2、继承</h1><p>继承是面向对象的基本特征之一，继承机制允许创建分等级层次的类。<strong>继承就是子类继承父类的特征和行为</strong>，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
<h1 id="3、多态"><a href="#3、多态" class="headerlink" title="3、多态"></a>3、多态</h1><p>多态同一个行为具有多个不同表现形式或形态的能力。是指一个类实例（对象）的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p>
<p><strong>多态的优点：</strong></p>
<ul>
<li>\1. 消除类型之间的耦合关系</li>
<li>\2. 可替换性</li>
<li>\3. 可扩充性</li>
<li>\4. 接口性</li>
<li>\5. 灵活性</li>
<li>\6. 简化性</li>
</ul>
<p>多态存在的<strong>三个必要条件</strong>：</p>
<ul>
<li>继承</li>
<li>重写（子类继承父类后对父类方法进行重新定义）</li>
<li>父类引用指向子类对象</li>
</ul>
<p>简言之，<strong>多态其实是在继承的基础上的。</strong>比如说今天我们要去动物园参观动物，那么你说我们去参观兔子、参观绵羊、参观狮子、参观豹子都是对的，但你不能说我们去参观汽车。在这个例子中，子类具有多态性：除了使用自己的身份，还能充当父类。</p>
<h1 id="1、单一职责原则（SRP）"><a href="#1、单一职责原则（SRP）" class="headerlink" title="1、单一职责原则（SRP）"></a>1、单一职责原则（SRP）</h1><p>一个类应该有且只有一个去改变它的理由，这意味着一个类应该只有一项工作。</p>
<p>比如在职员类里，将工程师、销售人员、销售经理这些情况都放在职员类里考虑，其结果将会非常混乱，在这个假设下，职员类里的每个方法都要 if else 判断是哪种情况，从类结构上来说将会十分臃肿。</p>
<h1 id="2、开放封闭原则（OCP）"><a href="#2、开放封闭原则（OCP）" class="headerlink" title="2、开放封闭原则（OCP）"></a>2、开放封闭原则（OCP）</h1><p>对象或实体应该对扩展开放，对修改封闭。</p>
<p>更改封闭即是在我们对模块进行扩展时，勿需对源有程序代码和 DLL 进行修改或重新编译文件！这个原则对我们在设计类的时候很有帮助，坚持这个原则就必须尽量考虑接口封装，抽象机制和多态技术！</p>
<h1 id="3、里氏替换原则（LSP）"><a href="#3、里氏替换原则（LSP）" class="headerlink" title="3、里氏替换原则（LSP）"></a>3、里氏替换原则（LSP）</h1><p>在对象 x 为类型 T 时 q(x) 成立，那么当 S 是 T 的子类时，对象 y 为类型 S 时 q(y) 也应成立。（即对父类的调用同样适用于子类）</p>
<h1 id="4、依赖倒置原则（DIP）"><a href="#4、依赖倒置原则（DIP）" class="headerlink" title="4、依赖倒置原则（DIP）"></a>4、依赖倒置原则（DIP）</h1><p>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。具体实现应该依赖于抽象，而不是抽象依赖于实现。</p>
<p>可以这样理解，上面我举例子的时候先说了兔子和绵羊，然后才推出食草动物。但如果我们继续认识了牛、马等食草动物，我们会发现我们需要不断调整食草动物的描述，这样程序会变得僵化，所以我们不应该让子类依赖于实体，不应该让父类模块依赖于子类模块。所以我们需要将食草动物设计为抽象类，即<strong>抽象类或接口</strong>。这样下层只需要实现相应的细节而不会影响父类。</p>
<h1 id="5、接口隔离原则（ISP）"><a href="#5、接口隔离原则（ISP）" class="headerlink" title="5、接口隔离原则（ISP）"></a>5、接口隔离原则（ISP）</h1><p>不应强迫客户端实现一个它用不上的接口，或是说客户端不应该被迫依赖它们不使用的方法，使用多个专门的接口比使用单个接口要好的多！</p>
<p>比如，为了减少接口的定义，将许多类似的方法都放在一个接口中，最后会发现，维护和实现接口的时候花了太多精力，而接口所定义的操作相当于对客户端的一种承诺，这种承诺当然是越少越好，越精练越好，过多的承诺带来的就是你的大量精力和时间去维护！</p>
<h1 id="Function-函数的理解"><a href="#Function-函数的理解" class="headerlink" title="Function 函数的理解"></a>Function 函数的理解</h1><p>两种自定义函数的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function fnName()&#123;&#125;`</span><br><span class="line">`var fnName=function()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>函数的返回值：</p>
<ol>
<li>当函数无明确返回值时，函数返回 undefined。</li>
<li>有返回值返回。</li>
</ol>
<p><strong>函数的参数列表是可变的</strong>，数据类型也是任意数据类型，JS 中有一个变量，argument 可以访问所有传到函数内部的参数。</p>
<p><strong>Js 支持创建动态函数</strong>，动态函数必须用 Function 对象来定义。</p>
<p><img src="https://pic2.zhimg.com/80/v2-be4e4cb3860783e2ac642bfd4ee50df1_720w.jpg" alt="img"></p>
<p><strong>JavaScript 本身不支持函数的重载</strong>。如果两个方法名字一样，即使参数个数不一样，那么后面定义的就会覆盖前面定义，调用方法时永远是调用后定义的那个。</p>
<h1 id="Ajax-请求的原理"><a href="#Ajax-请求的原理" class="headerlink" title="Ajax 请求的原理"></a>Ajax 请求的原理</h1><p>通过<strong>XMLHttpRequest</strong>对象来向服务器发送异步请求，从服务器获取数据。</p>
<p>然后用 JavaScript 来操作 DOM 而更新页面。<strong>XMLHttpRequest 是 ajax 的核心机制</strong>，它是 IE5 中首先引入的，是一种支持异步请求的技术。</p>
<p>简单的说，也就是 JavaScript 可以及时的向服务器提出请求并及时响应。而不阻塞用户。达到无刷新效果。</p>
<p>由事件触发，创建一个 XMLHttpRequest 对象，把 HTTP 方法 （POST&#x2F;GET）和目标 URL 以及请求返回后的回调函数设置到 XMLHttpRequest 对象，通过 XMLHttpRequest 向服务器发送请求，请求发送后继续响应用户的界面交互，只有等到请求真正从服务器返回的时候才调用 callback()函数，对响应数据进行处理。</p>
<h1 id="原生-js-实现轮播图的方法"><a href="#原生-js-实现轮播图的方法" class="headerlink" title="原生 js 实现轮播图的方法"></a>原生 js 实现轮播图的方法</h1><p>轮播图要实现的步骤和效果</p>
<p>1,显示和隐藏左右按钮</p>
<p>(1),鼠标移入，左右按钮显示</p>
<p>(2),鼠标离开，左右箭头隐藏</p>
<p>2,动态生成小圆点</p>
<p>(1)获取所有图片</p>
<p>(2)循环</p>
<p>(1),创建新的 li</p>
<p>(2),把 li 添加到 ol 中</p>
<p>(3),给新的 li 设置索引号（自定义属性）</p>
<p>(4),给新的 li 注册点击事件</p>
<p>3,单击小圆点，小圆点呈现选中白色，移动图片</p>
<p>(1),排他样式</p>
<p>(1),去掉所有 li 的白色样式</p>
<p>(2),留下当前 li(第一个默认为白色的小圆点)</p>
<p>(2),移动 ul</p>
<p>（1),获取索引号（自定义属性的值）</p>
<p>（2),计算 ul 的移动位置（-索引号*图片的宽）</p>
<p>（3),使用动画函数，移动 ul</p>
<p>4,单击右箭头，切换下一张图片</p>
<p>(1),切换下一张图片</p>
<p>(2),小圆点跟着变化</p>
<p>(3),无缝切换</p>
<p>(1),核心原理：复制了一个图片，放到 ul 的最后</p>
<p>(2),如果当前是最后一张，则瞬间回到第 1 张图片。</p>
<p>5,单击左箭头，切换上一张图片</p>
<p>6,自动轮播</p>
<p>(1),每隔 2 秒钟，触发右箭头的点击事件</p>
<p>节流阀，避免狂点右箭头</p>
<p>(1),定义一个全局变量（开关变量）</p>
<p>(2),把要锁住的代码放到 if 判断中</p>
<p>(3),if 判断中，先锁开关。flag &#x3D; false</p>
<p>(4),animate 的回调函数中，打开开关。flag &#x3D; true</p>
<h1 id="压缩-html-css-JavaScript"><a href="#压缩-html-css-JavaScript" class="headerlink" title="压缩 html css JavaScript"></a>压缩 html css JavaScript</h1><p>压缩 html、css、js 的一般方法是把各个文件单独压缩。这个方法的缺点比较明显，就是各个代码文件中的类名、id 等可压缩量，因为技术原因被忽略。且，代码压缩后无法复原，对调试工作不利。</p>
<p>1、<strong>进入在线工具 HCJCompress。</strong></p>
<p>2、<strong>根据代码文件的数量增加或减少输入框的数量。</strong></p>
<p>3、<strong>执行压缩指令，等待回传。</strong></p>
<p>4、<strong>保存带有调试辅助信息的源代码文件。</strong></p>
<p>5、<strong>如果需要调试压缩后的代码，从浏览器的提示中获取错误发生的位置，输入到工具中，即可定位代码压缩前的状态。</strong></p>
<h1 id="js-获取元素宽高的几种方法"><a href="#js-获取元素宽高的几种方法" class="headerlink" title="js 获取元素宽高的几种方法"></a>js 获取元素宽高的几种方法</h1><p><strong>1、Element.style.width&#x2F;height</strong></p>
<p>只能获取内联样式</p>
<p><strong>2、window.getComputedStyle(ele).width&#x2F;height</strong></p>
<p>可获取实时的 style</p>
<p><strong>3、Element.currentStyle.width&#x2F;height</strong></p>
<p>功能与第二点相同，只存在于旧版本 IE 中(IE9 以下)，除了做旧版 IE 兼容，就不要用它了。</p>
<p><strong>4、Element.getBoundingClientRect().width&#x2F;height</strong></p>
<p>除了能够获取宽高，还能获取元素位置等信息</p>
<h1 id="为什么全局对象没有-window？"><a href="#为什么全局对象没有-window？" class="headerlink" title="为什么全局对象没有 window？"></a>为什么全局对象没有 window？</h1><p>他是顶级对象，为了简化 js 的书写，就在设计 js 语言的时候，把他去掉了。 但是并不是说他不存在。</p>
<p>主要就是为了简化 js 代码的书写，不至于每个地方都写一遍 window</p>
<h1 id="前端必须了解的网络协议"><a href="#前端必须了解的网络协议" class="headerlink" title="前端必须了解的网络协议"></a>前端必须了解的网络协议</h1><table>
<thead>
<tr>
<th>应用层（Application）</th>
<th>应用层</th>
<th>HTTP、TFTP、FTP、NFS、WAIS、SMTP</th>
</tr>
</thead>
<tbody><tr>
<td>表示层（Presentation）</td>
<td></td>
<td>Telnet、Rlogin、SNMP、Gopher</td>
</tr>
<tr>
<td>会话层（session）</td>
<td></td>
<td>SNMP、DNS</td>
</tr>
<tr>
<td>传输层（Transport）</td>
<td>传输层</td>
<td>TCP、UDP</td>
</tr>
<tr>
<td>网络层（Network）</td>
<td>网络层</td>
<td>IP、ICMP、ARP、RARP、AKP、UUCP</td>
</tr>
<tr>
<td>数据链路层（Data link）</td>
<td>数据链路层</td>
<td>FDDI、Ethernet、Arpanet、PDN、SLIP、PPP</td>
</tr>
<tr>
<td>物理层（Physical）</td>
<td></td>
<td>IEEE 802.1A、IEEE 802.2 到 IEEE 802.11</td>
</tr>
</tbody></table>
<p><strong>http 和 https 的区别</strong></p>
<p>http：是互联网上应用最广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（tcp），用于从 www 服务器传输超文本到本地浏览器的传输协议，它可以是浏览器更加高效，使网络传输减少。</p>
<p>https：是以安全为目标的 http 通道，简单讲是 http 的安全办。即 http 下加入 ssl 层，https 的安全基础是 ssl，因此加密的详细内容就需要 ssl。</p>
<p>https 的作用主要可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性；</p>
<p><strong>两者的主要区别</strong></p>
<ol>
<li>https 协议需要 ca 申请证书，一般免费证书较少，因而需要一定费用；</li>
<li>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议;</li>
<li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443；</li>
<li>http 的连接很简单，是无状态的；https 协议是由 ssl+http 协议构建的可进行加密传输，身份认证的网络协议，比 http 协议安全。</li>
</ol>
<p><strong>http 的特点</strong></p>
<ol>
<li>支持客户、服务器模式（c&#x2F;s 模式）</li>
<li>简单快速：客户向服务器请求服务时，秩序传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。没中方法规定了客户与服务器联系的类型不同。由于 http 协议简单，是的 http 服务器的程序规模小，因为通信速度很快。</li>
<li>灵活：http 允许传输任意类型的数据对象。正在传输的类型有 content-type 加以标记。</li>
<li>无连接：含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li>无状态：无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信心时它的应答就比较快。</li>
</ol>
<p><strong>http 工作流程</strong></p>
<ol>
<li>建立 tcp&#x2F;ip 连接，客户端与服务器通过 socket 三次握手进行连接</li>
<li>客户端向服务端发起 HTTP 请求（例：POST&#x2F;login.html http&#x2F;1.1）</li>
<li>客户端发送一空白行，表示客户端请求完毕</li>
<li>服务器做出应答，表示对于客户端请求的应答，例如：HTTP、1.1 200 OK</li>
<li>服务器向客户端发送应答头信息</li>
<li>服务器向客户端发送应答头信息后，也会发送一空白行，表示应答头信息发送完毕，接着就以 content-type 要求的数据格式发送数据给客户端</li>
<li>服务端关闭 tcp 连接，如果服务器或者客户端增加 connection：keep-alive 就表示客户端与服务端继续保存连接，在下次请求时可以继续使用这次的连接</li>
</ol>
<p><strong>https 的特点</strong></p>
<p><strong>优点</strong></p>
<ol>
<li>认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>
<li>安全性 可防止数据在传输过程中不被窃取，改变，确保数据完整性；同事也一定程度上保护了服务端，使用恶意攻击和伪装数据的成本大大提高。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%-20%的耗电；</li>
<li>缓存不如 http 高效，会增加数据开销；</li>
<li>SSL 证书需要钱，功能越强大费用越高；</li>
<li>SSL 证书需要绑定 ip，不能在同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗</li>
</ol>
<p><strong>https 的工作流程</strong></p>
<ol>
<li><p>客户使用 https 的 url 访问 web 服务器，要求与 web 服务器建立 SSL 连接；</p>
</li>
<li><p>web 服务器收到客户端请求后，会将网站的证书信息（证书中包含了公钥）传送一份给客户端；</p>
</li>
<li><p>客户端的浏览器与 web 服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级；</p>
</li>
<li><p>客户端浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站</p>
</li>
<li><p>web 服务器利用自己的私钥解密出会话密钥</p>
</li>
<li><p>web 服务器利用会话密钥加密与客户端之间的通信</p>
<h1 id="http-与-websocket"><a href="#http-与-websocket" class="headerlink" title="http 与 websocket"></a>http 与 websocket</h1><p>WebSocket 是 HTML5 规范提出的一种协议；目前除了完犊子的 IE 浏览器，其他浏览器都基本支持。他是一种协议，万变不离其宗，也是基于 TCP 协议的；和 HTTP 协议是并存的两种协议。<br>WebSocket 连接的过程是：</p>
<ol>
<li>客户端发起 http 请求，经过 3 次握手后，建立起 TCP 连接；http 请求里存放 WebSocket 支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version 等；</li>
<li>服务器收到客户端的握手请求后，同样采用 HTTP 协议回馈数据；</li>
<li>客户端收到连接成功的消息后，开始借助于 TCP 传输信道进行全双工通信。</li>
</ol>
<p><strong>相同点</strong><br>都是一样基于 TCP 的，都是可靠性传输协议<br><strong>区别</strong></p>
<ol>
<li>Websocket 是一个持久化的协议，http 不支持（长连接，循环连接的不算）；</li>
<li>Websocket 支持双向通讯（可以让服务器主动向客户端推送消息，客户端也可以主动向服务器发送信息）；http 只能由客户端发起，一个 request 对应一个 response；</li>
</ol>
</li>
</ol>
<h1 id="http-协议的请求头"><a href="#http-协议的请求头" class="headerlink" title="http 协议的请求头"></a>http 协议的请求头</h1><p><strong>Cache-control</strong> 缓存的开关（静态资源 自动缓存 认为干涉无效；From disk cache 表示来自于缓存）<br>取值：private（被私有缓存缓存）、public（可以被任何缓存所缓存）、max-age&#x3D;xxx（有时间限制，一般单位为秒）、no-cache（不缓存过期的资源，缓存会向服务器进行有效处理确认之后处理资源）、no-store（不缓存）<br><strong>资源标示对比</strong><br>Etag 与 if-None-Mach（最高级）：后端传递的 if-None-Mach 与 Etag 相比较，比不上了其他不用看 直接重新下载，不用缓存里的<br>Last-Modified 与 If-Modified-Since：前者表示浏览器最后修改时间，在请求头里；后者表示最后接收时间，在响应头里；</p>
<h1 id="js-循环多维数组"><a href="#js-循环多维数组" class="headerlink" title="js 循环多维数组"></a>js 循环多维数组</h1><p>层数已知，且固定，且层级小于 4 的，可以直接嵌套着写，如果层数不确定，不固定，太多直接用递归的方式去处理就行了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">arryLoopR</span> = (<span class="params">array, iterator</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array)) <span class="keyword">return</span> <span class="title function_">iterator</span>(array)</span><br><span class="line">  <span class="keyword">return</span> array.<span class="title function_">map</span>(arrayLoopR)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>套两层循环也可以</p>
<h1 id="在-JavaScript-函数中，什么时候会使用-return"><a href="#在-JavaScript-函数中，什么时候会使用-return" class="headerlink" title="在 JavaScript 函数中，什么时候会使用 return"></a>在 JavaScript 函数中，什么时候会使用 return</h1><p>在你需要返回值的时候，就能用</p>
<h1 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽"></a>拖拽</h1><p>\1. 按下时 获取 元素坐标 和 手指坐标</p>
<p>\2. move 时 获取手指坐标</p>
<p>\3. 用 move 的手指 - start 时的手指坐标 &#x3D; 手指移动距离</p>
<p>\4. start 时元素坐标 + 手指移动距离 &#x3D; 元素的当前距离</p>
<p><strong>触摸事件拖拽：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>触摸拖拽<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      * &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">ul</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">361px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">cursor</span>: pointer;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">top</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">left</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: <span class="number">#787878</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul1&quot;</span>&gt;</span></span><br><span class="line">      拖拽</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> ul1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;ul1&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> startPoint = <span class="number">0</span> <span class="comment">// 按下时的手指坐标</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> startEl = <span class="number">0</span> <span class="comment">// 按下时的元素坐标</span></span></span><br><span class="line"><span class="language-javascript">      ul1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        startPoint = e.<span class="property">changedTouches</span>[<span class="number">0</span>].<span class="property">pageX</span></span></span><br><span class="line"><span class="language-javascript">        startEl = <span class="built_in">parseFloat</span>(<span class="title function_">getComputedStyle</span>(ul1, <span class="literal">null</span>).<span class="property">left</span>)</span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">      ul1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> nowPoint = e.<span class="property">changedTouches</span>[<span class="number">0</span>].<span class="property">pageX</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> pointDis = nowPoint - startPoint</span></span><br><span class="line"><span class="language-javascript">        ul1.<span class="property">style</span>.<span class="property">left</span> = pointDis + startEl + <span class="string">&#x27;px&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>鼠标事件拖拽：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>鼠标拖拽<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      * &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">ul</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">361px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">cursor</span>: pointer;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">top</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">left</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: <span class="number">#787878</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> oUl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;ul1&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> disX = <span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> offsetLeft = <span class="number">0</span> <span class="comment">//元素坐标</span></span></span><br><span class="line"><span class="language-javascript">        oUl.<span class="property">onmousedown</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          disX = ev.<span class="property">pageX</span></span></span><br><span class="line"><span class="language-javascript">          offsetLeft = oUl.<span class="property">offsetLeft</span> <span class="comment">// parseFloat(getComputedStyle(oUl,null).left)</span></span></span><br><span class="line"><span class="language-javascript">          oUl.<span class="property">onmousemove</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            oUl.<span class="property">style</span>.<span class="property">left</span> = ev.<span class="property">pageX</span> - disX + offsetLeft + <span class="string">&#x27;px&#x27;</span></span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">          <span class="comment">// 鼠标抬起</span></span></span><br><span class="line"><span class="language-javascript">          oUl.<span class="property">onmouseup</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 取消事件监听</span></span></span><br><span class="line"><span class="language-javascript">            oUl.<span class="property">onmousemove</span> = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">            oUl.<span class="property">onmouseup</span> = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">          <span class="comment">//防止文字选中</span></span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> <span class="literal">false</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul1&quot;</span>&gt;</span></span><br><span class="line">      拖拽</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><p>迭代器有什么用处?</p>
<ul>
<li>用于 forof 循环</li>
<li>数组解构运算符</li>
<li>Array.from()转化类数组为数组</li>
<li>创建集合 Set</li>
<li>创建映射 Map</li>
<li>Promise.all()通过迭代器来获取异步函数</li>
<li>Promise.race()同样是通过迭代器来获取一步函数</li>
<li>yield*操作符,在生成器中生成一个小型迭代</li>
</ul>
<p>如果我的数据开始迭代以后我对他进行更改只要是迭代器还没有迭代到的游标位置</p>
<p>后续的迭代继续,导致游标后移,而此时后移部分有新修改的部分迭代器也会继续迭代</p>
<p><strong>终止迭代</strong></p>
<p>有些迭代器原型上还有<strong>break return throw continue</strong>等方法</p>
<h1 id="操作对象"><a href="#操作对象" class="headerlink" title="操作对象"></a>操作对象</h1><p><strong>操作单个对象内置特性</strong></p>
<ul>
<li><strong>Object.defineProperty() 设置</strong></li>
<li><strong>Object.getOwnPropertyDescriptor() 获取</strong></li>
</ul>
<p>Object.defineProperty()接受三个参数:</p>
<ul>
<li>第一个参数为一个对象</li>
<li>第二个参数为对象的属性名(可以原来就有,也可以是原本不具有的属性名)</li>
<li>第三个参数为这个对象配置一些**[内置特性]**(请牢记这个名词)</li>
</ul>
<h1 id="es6-中的箭头函数和普通函数有什么区别？"><a href="#es6-中的箭头函数和普通函数有什么区别？" class="headerlink" title="es6 中的箭头函数和普通函数有什么区别？"></a>es6 中的箭头函数和普通函数有什么区别？</h1><p>1、普通函数中的 this 总是指向调用它的那个对象，</p>
<p>箭头函数没有自己的 this,他的 this 永远指向其定义环境，任何方法都改变不了其指向，如 call()、bind()、apply()。（正是因为它没有 this，所以也就不能用作构造函数，也没有原型对象）</p>
<p>箭头函数不能当作构造函数，也就是说，不能使用 new 命令，否则会报错。</p>
<p>箭头函数没有原型属性。</p>
<p>箭头函数不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。</p>
<p>箭头函数不能使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
<p>变量提升：由于 js 的内存机制，function 的级别最高，而用箭头函数定义函数的时候，需要 var（let、const）关键字，而 var 所定义的变量不能得到变量提升。故箭头函数一定要定义于调用之前。</p>
<p>拓展：this 的指向问题？</p>
<p>1、普通函数中，this 指向其函数的直接调用者；</p>
<p>2、箭头函数中，this 指向其定义环境，任何方法都改变不了其指向，如 call( ）、bind（）等；</p>
<p>3、构造函数中，如果不使用 new，则 this 指向 window，</p>
<p>如果使用 new 创建了一个实例，则 this 指向该实例。</p>
<p>4、window 内置函数中，如 setInterval，setTimeout 等，其内部的 this 指向 Window。</p>
<p>5、匿名函数的 this 指向 Window。</p>
<p>6、apply（）、call（）、bind（）可以改变 this 的指向</p>
<h1 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h1><p>一个程序至少有一个进程，一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。</p>
<p>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>
<p>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
<p>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>
<h1 id="cookies，sessionStorage-和-localStorage-的区别"><a href="#cookies，sessionStorage-和-localStorage-的区别" class="headerlink" title="cookies，sessionStorage 和 localStorage 的区别"></a>cookies，sessionStorage 和 localStorage 的区别</h1><p>sessionStorage 和 localStorage 是 HTML5 Web Storage API 提供的，可以方便的在 web 请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。sessionStorage、localStorage、cookie 都是在浏览器端存储的数据，其中 sessionStorage 的概念很特别，引入了一个“浏览器窗口”的概念。sessionStorage 是在同源的同窗口（或 tab）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，sessionStorage 即被销毁。同时“独立”打开的不同窗口，即使是同一页面，sessionStorage 对象也是不同的 cookies 会发送到服务器端。其余两个不会。Microsoft 指出 InternetExplorer8 增加 cookie 限制为每个域名 50 个，但 IE7 似乎也允许每个域名 50 个 cookie。</p>
<ul>
<li>Firefox 每个域名 cookie 限制为 50 个。</li>
<li>Opera 每个域名 cookie 限制为 30 个。</li>
<li>Firefox 和 Safari 允许 cookie 多达 4097 个字节，包括名（name）、值（value）和等号。</li>
<li>Opera 允许 cookie 多达 4096 个字节，包括：名（name）、值（value）和等号。</li>
<li>InternetExplorer 允许 cookie 多达 4095 个字节，包括：名（name）、值（value）和等号。</li>
</ul>
<h1 id="“reset”CSS-文件的作用和使用它的好处。"><a href="#“reset”CSS-文件的作用和使用它的好处。" class="headerlink" title="“reset”CSS 文件的作用和使用它的好处。"></a>“reset”CSS 文件的作用和使用它的好处。</h1><p>因为浏览器的品种很多，每个浏览器的默认样式也是不同的，所以定义一个 css reset 可以使各浏览器的默认样式统一。</p>
<h1 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h1><p><strong><code>function</code></strong> 关键字可以用来在一个表达式中定义一个函数。</p>
<p>你也可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>Function</code></a> 构造函数和一个<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function">函数声明</a>来定义函数。 可以使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a> 。</p>
<p><strong>参数</strong></p>
<ul>
<li><p><code>name</code></p>
<p>函数名称。可被省略，此种情况下的函数是匿名函数（_anonymous_）。 函数名称只是函数体中的一个本地变量。</p>
</li>
<li><p><code>paramN</code></p>
<p>被传递给函数的一个参数名称。一个函数至多拥有 255 个参数。</p>
</li>
<li><p><code>statements</code></p>
</li>
<li><p>构成函数体的语句。</p>
<p>函数表达式（function expression）非常类似于函数声明（function statement）（详情查看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function">函数声明</a>），并且两者拥有几乎相同的语法。函数表达式与函数声明的最主要区别是函数名称（<em>function name_），在函数表达式中可省略它，从而创建匿名函数（_anonymous</em> functions）。一个函数表达式可以被用作一个 IIFE（Immediately Invoked Function Expression，即时调用的函数表达式），它一旦定义就运行。</p>
</li>
</ul>
<h1 id="js-中的匿名函数"><a href="#js-中的匿名函数" class="headerlink" title="js 中的匿名函数"></a>js 中的匿名函数</h1><p>匿名函数顾名思义指的是没有名字的函数，在实际开发中使用的频率非常高！</p>
<p>匿名函数的作用：</p>
<p>1、通过匿名函数可以实现闭包，关于闭包在后面的文章中会重点讲解。在这里简单介绍一下：闭包是可以访问在函数作用域内定义的变量的函数。若要创建一个闭包，往往都需要用到匿名函数。</p>
<p>2、模拟块级作用域，减少全局变量。执行完匿名函数，存储在内存中相对应的变量会被销毁，从而节省内存。再者，在大型多人开发的项目中，使用块级作用域，会大大降低命名冲突的问题，从而避免产生灾难性的后果。自此开发者再也不必担心搞乱全局作用域了。</p>
<h1 id="将arguments转换为真正的数组的方法"><a href="#将arguments转换为真正的数组的方法" class="headerlink" title="将arguments转换为真正的数组的方法"></a>将<code>arguments</code>转换为真正的数组的方法</h1><ol>
<li><strong>Array.prototype.slice.apply(arguments)</strong></li>
</ol>
<p>这是运行效率比较快的方法（看别人资料说的），为什么不是数组也可以，因为<code>arguments</code>对象有<code>length</code>属性，而这个方法会根据<code>length</code>属性,返回一个具有<code>length</code>长度的数组。若<code>length</code>属性不为<code>number</code>，则数组长度返回<code>0</code>；</p>
<ol start="2">
<li><strong>Array.prototype.concat.apply(thisArg,arguments)</strong></li>
</ol>
<p><code>thisArg</code>是新的空数组，<code>apply</code>方法将函数<code>this</code>指向<code>thisArg</code>，<code>arguments</code>做为类数组传参给<code>apply</code>。</p>
<p>根据<code>apply</code>的方法的作用，即将<code>Array.prototype.slice</code>方法在指定的<code>this</code>为<code>thisArg</code>内调用，并将参数传给它。用此方法注意：若数组内有数组，会被拼接成一个数组。原因是<code>apply</code>传参的特性。</p>
<h1 id="判断-array-对象"><a href="#判断-array-对象" class="headerlink" title="判断 array 对象"></a>判断 array 对象</h1><p>可以使用<code>Array.isArray()</code>或者<code>Object.prototype.toString.call()</code>判断</p>
<h1 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h1><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<h1 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h1><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<h1 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h1><p><strong>添加节点</strong><br>appendChild()<br><strong>移除节点</strong><br>removeChild() 一个参数，这个参数是指要移走的节点，返回被移除的节点<br>注意：被移除的节点仍然在文档中，但是文档中没有位置<br><strong>替换节点</strong><br>replaceChild() 两个参数，第一个是要插入的节点 第二个是要替换的节点 返回被替换的节点<br><strong>插入节点</strong><br>insertBefore() 两个参数，第一个是要插入的节点，第二个是参考节点<br><strong>复制节点</strong><br>cloneNode() 方法，用于复制节点， 接受一个布尔值参数， true 表示深复制（复制节点及其所有子节点）， false 表示浅复制（复制节点本身，不复制子节点）</p>
<p><strong>创建节点</strong><br>createDocumentFragment() &#x2F;&#x2F;创建一个 DOM 片段<br>createElement() &#x2F;&#x2F;创建一个具体的元素<br>createTextNode() &#x2F;&#x2F;创建一个文本节点</p>
<p><strong>查找节点</strong><br>getElementsByTagName() &#x2F;&#x2F;通过标签名称<br>getElementsByName() &#x2F;&#x2F;通过元素的 Name 属性的值(IE 容错能力较强，会得到一个数组，其中包括 id 等于 name 值的)<br>getElementById() &#x2F;&#x2F;通过元素 Id，唯一性</p>
<h1 id="事件阶段"><a href="#事件阶段" class="headerlink" title="事件阶段"></a>事件阶段</h1><p>事件捕获，目标阶段，事件冒泡</p>
<h1 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h1><p>原理利用事件冒泡，本来应该给子元素注册的事件，给父元素来注册</p>
<p><strong>事件委托优点</strong> 1.减少内存消耗，不必为大量元素绑定事件 2.为动态添加的元素绑定事件</p>
<p><strong>事件委托缺点:</strong> 1.部分事件如 focus、blur 等无冒泡机制，所以无法委托。 2.事件委托有对子元素的查找过程，委托层级过深，可能会有性能问题 3.频繁触发的事件如 mousemove、mouseout、mouseover 等，不适合事件委托</p>
<h1 id="如何阻止事件冒泡，如何阻止默认行为"><a href="#如何阻止事件冒泡，如何阻止默认行为" class="headerlink" title="如何阻止事件冒泡，如何阻止默认行为"></a>如何阻止事件冒泡，如何阻止默认行为</h1><p>event.stopPropagation()<br>event.preventDefault()或者 return false</p>
<h1 id="内置对象常用方法"><a href="#内置对象常用方法" class="headerlink" title="内置对象常用方法"></a>内置对象常用方法</h1><p>Math.random()<br>Math.abs()<br>Math.floor()<br>Math.ceil()<br>Math.round()<br>String.prototype.substr()<br>String.prototype.split()<br>String.prototype.replace()</p>
<h1 id="window-中的宿主对象"><a href="#window-中的宿主对象" class="headerlink" title="window 中的宿主对象"></a>window 中的宿主对象</h1><p>dom，history，location，screen，navigator</p>
<h1 id="on"><a href="#on" class="headerlink" title="on"></a>on</h1><p>on() 方法在被选元素及子元素上添加一个或多个事件处理程序。</p>
<h1 id="后台管理系统权限你是如何实现的？"><a href="#后台管理系统权限你是如何实现的？" class="headerlink" title="后台管理系统权限你是如何实现的？"></a>后台管理系统权限你是如何实现的？</h1><p>1.定义静态路由表(无需权限的使用) 2.定义权限路由表(和后台返回的权限进行匹配用)<br>开始登录判断登录是否成功，（成功后将返回的登录 token 值存储到本地里，用导航守卫进行判断本地是否存在返回的这个 token 值）没有成功继续登录，<br>成功的话判断是否已经获取了用户的权限列表，没有获取重新获取权限列表，<br>获取到了将权限数据存储到 vuex 中，<br>（vuex 中的数据是公共数据，我们在写组件时任何一个地方都可能用到这个数据，所以将这个权限数据存储到 vuex 中，方便使用），<br>然后将 vuex 中的权限数据和定义好的需要访问权限的路由表进行对比，<br>（在设置路由的组件中设置 name 和获取的权限列表中的路由一样），<br>生成当前账户对应的权限路由表，<br>通过 addRoutes 方法动态添加路由规则，<br>就可以生成可访问的侧边栏菜单</p>
<h1 id="Scope-作用范围"><a href="#Scope-作用范围" class="headerlink" title="Scope 作用范围"></a><strong>Scope 作用范围</strong></h1><p>如果有 这里有两个变量声明 a 跟 b，但 a 使用关键字 var 声明的。代表它是一个函数的局部变量。与此相反，b 变成了全局变量。</p>
<h1 id="创建原生（native）方法"><a href="#创建原生（native）方法" class="headerlink" title="创建原生（native）方法"></a><strong>创建原生（native）方法</strong></h1><p>给字符串对象定义一个 repeatify 功能。当传入一个整数 n 时，它会返回重复 n 次字符串的结果</p>
<h1 id="js-是由哪三部分构成的"><a href="#js-是由哪三部分构成的" class="headerlink" title="js 是由哪三部分构成的"></a>js 是由哪三部分构成的</h1><p>有 js 的<strong>语法核心 ECMAScript</strong>，还有<strong>文档对象模型 DOM</strong>，以及<strong>浏览器对象模型 BOM。</strong></p>
<h1 id="没有-DOM，会对开发有什么影响"><a href="#没有-DOM，会对开发有什么影响" class="headerlink" title="没有 DOM，会对开发有什么影响"></a>没有 DOM，会对开发有什么影响</h1><p>那根本没法开发啊。<strong>前端的主要工作有两个，一个是高保真的实现 UI 设计稿，一个是高效率的从后端获取数据并渲染到页面上。</strong>如果没有 DOM，就不能渲染页面了。</p>
<h1 id="CSS-justify-content-属性"><a href="#CSS-justify-content-属性" class="headerlink" title="CSS justify-content 属性"></a>CSS justify-content 属性</h1><p>justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。</p>
<p>justify-content: flex-start|flex-end|center|space-between|space-around|initial|inherit;</p>
<p><strong>提示：</strong>使用 align-content 属性拆分交叉轴上的规格（垂直）。</p>
<table>
<thead>
<tr>
<th>flex-start</th>
<th>默认值。项目位于容器的开头。</th>
<th><a target="_blank" rel="noopener" href="https://www.runoob.com/try/playit.php?f=playcss_justify-content&preval=flex-start">测试 »</a></th>
</tr>
</thead>
<tbody><tr>
<td>flex-end</td>
<td>项目位于容器的结尾。</td>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/try/playit.php?f=playcss_justify-content&preval=flex-end">测试 »</a></td>
</tr>
<tr>
<td>center</td>
<td>项目位于容器的中心。</td>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/try/playit.php?f=playcss_justify-content&preval=center">测试 »</a></td>
</tr>
<tr>
<td>space-between</td>
<td>项目位于各行之间留有空白的容器内。</td>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/try/playit.php?f=playcss_justify-content&preval=space-between">测试 »</a></td>
</tr>
<tr>
<td>space-around</td>
<td>项目位于各行之前、之间、之后都留有空白的容器内。</td>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/try/playit.php?f=playcss_justify-content&preval=space-around">测试 »</a></td>
</tr>
<tr>
<td>initial</td>
<td>设置该属性为它的默认值。请参阅 <a target="_blank" rel="noopener" href="https://www.runoob.com/cssref/css-initial.html"><em>initial</em></a>。</td>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/try/playit.php?f=playcss_justify-content&preval=initial">测试 »</a></td>
</tr>
<tr>
<td>inherit</td>
<td>从父元素继承该属性。请参阅 <a target="_blank" rel="noopener" href="https://www.runoob.com/cssref/css-inherit.html"><em>inherit</em></a>。</td>
<td></td>
</tr>
</tbody></table>
<h1 id="RBAC-是什么？"><a href="#RBAC-是什么？" class="headerlink" title="RBAC 是什么？"></a>RBAC 是什么？</h1><p><a target="_blank" rel="noopener" href="http://www.sojson.com/tag_rbac.html">RBAC </a>是基于角色的访问控制（<code>Role-Based Access Control</code> ）在<a target="_blank" rel="noopener" href="http://www.sojson.com/tag_rbac.html"> RBAC </a>中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。这样管理都是层级相互依赖的，权限赋予给角色，而把角色又赋予用户，这样的权限设计很清楚，管理起来很方便。</p>
<h1 id="RBAC-介绍。"><a href="#RBAC-介绍。" class="headerlink" title="RBAC 介绍。"></a>RBAC 介绍。</h1><p><a target="_blank" rel="noopener" href="http://www.sojson.com/tag_rbac.html">RBAC </a>认为授权实际上是<code>Who</code> 、<code>What</code> 、<code>How</code> 三元组之间的关系，也就是<code>Who</code> 对<code>What</code> 进行<code>How</code> 的操作，也就是“主体”对“客体”的操作。</p>
<p><strong>Who：是权限的拥有者或主体（如：User，Role）。</strong></p>
<p><strong>What：是操作或对象（operation，object）。</strong></p>
<p><strong>How：具体的权限（Privilege,正向授权与负向授权）。</strong></p>
<p>然后<a target="_blank" rel="noopener" href="http://www.sojson.com/tag_rbac.html"> RBAC </a>又分为<code>RBAC0、RBAC1、RBAC2、RBAC3</code> ，如果你不知道他们有什么区别，你可以百度百科：<a target="_blank" rel="noopener" href="http://baike.baidu.com/link?url=Tg3nxejvD2QVLLkjKa_4XaQoOWSPAVpR1FgHAG_gANcamtN2cYIm1r1irNw9VZ816FBrMEvdoYqwzixqdHd5e_">百度百科-RBAC</a> 估计你看不懂。还是看看我的简单介绍。</p>
<p>我这里结合我的见解，简单的描述下（去掉那么多的废话）。</p>
<p>RBAC0、RBAC1、RBAC2、RBAC3 简单介绍。</p>
<ul>
<li><strong>RBAC0：是 RBAC 的核心思想。</strong></li>
<li><strong>RBAC1：是把 RBAC 的角色分层模型。</strong></li>
<li><strong>RBAC2：增加了 RBAC 的约束模型。</strong></li>
<li><strong>RBAC3：其实是 RBAC2 + RBAC1。</strong></li>
</ul>
<p><strong>RBAC0，RBAC 的核心。</strong></p>
<p>RBAC1，基于角色的分层模型</p>
<p>RBAC2、是 RBAC 的约束模型。</p>
<p>RBAC3、就是 RBAC1+RBAC2</p>
<p><strong>估计看完图后，应该稍微清楚一点。</strong></p>
<p>下面来看个 Demo。员工权限设计的模型图，以及对应关系。</p>
<p>关系图，以及实体设计。</p>
<p>表设计</p>
<p>在我们平常的权限系统中，想完全遵循 <a target="_blank" rel="noopener" href="http://www.sojson.com/tag_rbac.html">RBAC</a> 模型是很难的，因为难免系统业务上有一些差异化的业务考量，所以在设计之初，不要太理想，太追求严格的 <a target="_blank" rel="noopener" href="http://www.sojson.com/tag_rbac.html">RBAC</a> 模型设计，因为这样会使得你的系统处处鸡肋，无法拓展。</p>
<p>所以在这里要说明一下， <a target="_blank" rel="noopener" href="http://www.sojson.com/tag_rbac.html">RBAC</a> 是一种模型，是一种思想，是一种核心思想，但是就思想而言，不是要你完全参照，而是你在这个基础之上，融入你自己的思想，赋予你的业务之上，达到适用你的业务。所以要批评一下那些说：“<code>RBAC</code>模型是垃圾，按照它思路去执行，结果无法拓展。”之类话语的人。那是你自己不会变通。</p>
<p>言归正传。</p>
<p>背景需求：</p>
<p>需要在<code>“权限”=&gt;“角色”=&gt;“用户”</code>之间，在赋予一个特殊的角色“客服”，这个需求比较常见，我一个用户想把我的权限分配到“客服”角色上，然后由几个“客服”去操作对应的业务流程。比如我们的天猫，淘宝商家后天就是如此，当店铺开到一定的规模，那么就会有分工。</p>
<p>A 客服：负责打单填写发货单。</p>
<p>B~E 客服：负责每天对我们说“亲，您好。祝亲生活愉快！”，也就是和我们沟通交流的客服。</p>
<p>F~H：负责售后。</p>
<p>那么这些客服也是归属到这个商家下面去。而且每个商家可能都有类似的客服，分工完全靠商家自己去分配管理。</p>
<p>这样的系统，融合我们的权限控制，关键要看“客服”用户的添加是在哪添加，如果是由客服直接添加，不走我们的统一注册流程，那建议不要融合到上面这一套 权限、角色、用户之间去，而是给用户再多一个绑定，把多个用户绑定到客服下，并且给客服赋予对应的权限。</p>
<p>1、权限赋予：</p>
<p>权限赋予是把当前用户的权限拉出来，然后分配的客服可以小于等于当前用户的权限。</p>
<p>2、权限加载：</p>
<p>正常的加载权限，当用户登录后，并且第一次使用权限判断的时候， <a target="_blank" rel="noopener" href="http://www.sojson.com/tag_shiro.html">Shiro</a> 会去加载权限。</p>
<p>3、权限判断：</p>
<p>走正常用户权限判断，但是数据操作需要判断是不是当前归属的用户的数据，其实这个是属于业务层，就算你不是客服，也是需要判断。</p>
<p>4、禁用|启用：</p>
<p>禁用启用，也是正常的用户流程，添加到禁用列表里，如果被禁用，就无法操作任何内容。</p>
<h1 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h1><p><strong>字符串分割</strong> : **slice（start,end） **</p>
<p>（1）截取字符串时不包括下标为 end 的元素。</p>
<p>（2）end 是可选参数，没有时，默认从 start 到结束的所有字符串。</p>
<p>（3）String.slice 与 Array.slice 区别。</p>
<p>（4）参数为负数时，是如何处理的。</p>
<p><strong>substr（start，length）；</strong></p>
<p>关于这个方法，也需要搞懂几个关键点：</p>
<p>（1）第二个参数是子串中的字符数，必须是数值。可以没有。</p>
<p>（2）参数为负数时如何进行处理。</p>
<p>由于 substr() 的参数指定的是子串的开始位置和长度，因此它可以替代 substring() 和 slice() 来使用。</p>
<p><strong>substring（start，end）；</strong></p>
<p>和 slice 类似，关于这个方法，同样需要搞懂几个关键点：</p>
<p>（1）返回的字符串中不包括 end 处的字符。</p>
<p>（2）参数为负数时如何进行处理。</p>
<p>（3）如果参数 start 与 end 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。</p>
<p>（4）如果 start 比 end 大，那么该方法在提取子串之前会先交换这两个参数。</p>
<p>这个方法的作用同样可以使用 slice 方法来替代。</p>
<p><strong>charAt（pos）</strong></p>
<p>返回指定位置（如上 pos）的字符。如果 pos 小于 0 或者大于等于字符串的长度 string.length，它会返回空字符串。</p>
<p>**concat（string…） **</p>
<p>用于连接两个或者多个字符串。相较于数组 Array.concat()。其实字符串到是用的不多，主要是之前使用加号（+）会更方便一些，新语法时一步优化字符串拼接的操作。</p>
<p><strong>indexOf（searchString，position）</strong></p>
<p>在 string 内查找另一个字符串 searchString。如果它被找到，就返回第 1 个匹配字符的位置，否则返回-1。</p>
<p>需要记住一点是：可选参数 position 可设置从 string 的某个指定的位置开始查找。</p>
<p><strong>lastIndexOf（searchString，position）</strong><br>与 indexOf 方法类似，只不过它是从该字符串的末尾开始查找而不是从开头。</p>
<p><strong>localeCompare（target）</strong><br>用来比较两个字符串，返回比较结果数字。如果 stringObject 小于 target，则 localeCompare() 返回小于 0 的数。如果 stringObject 大于 target，则该方法返回大于 0 的数。如果两个字符串相等，或根据本地排序规则没有区别，该方法返回 0。</p>
<p><strong>match（regexp）</strong></p>
<p>match 方法让字符串和一个正则表达式进行匹配。它依据 g 标识来决定如何进行匹配。如果没有 g 标识，那么调用 string.match(regexp)的结果与调用 regexp.exec(string)的结果相同。带 g 标识返回的是一个结果数组，</p>
<p><strong>replace（searchValue，replaceValue）</strong><br>作用：replace 方法对 string 进行查找和替换操作，并返回一个新的字符串。</p>
<p>取值：而参数 searchValue 可以是一个字符串或者一个正则表达式对象。</p>
<p>第一种情况：如果 searchValue 是一个字符串，那么 searchValue 只会在第 1 次出现 的地方被替换</p>
<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><table>
<thead>
<tr>
<th>命令</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>git add</td>
<td>添加至暂存区</td>
</tr>
<tr>
<td>git add–interactive</td>
<td>交互式添加</td>
</tr>
<tr>
<td>git apply</td>
<td>应用补丁</td>
</tr>
<tr>
<td>git am</td>
<td>应用邮件格式补丁</td>
</tr>
<tr>
<td>git annotate</td>
<td>同义词，等同于 git blame</td>
</tr>
<tr>
<td>git archive</td>
<td>文件归档打包</td>
</tr>
<tr>
<td>git bisect</td>
<td>二分查找</td>
</tr>
<tr>
<td>git blame</td>
<td>文件逐行追溯</td>
</tr>
<tr>
<td>git branch</td>
<td>分支管理</td>
</tr>
<tr>
<td>git cat-file</td>
<td>版本库对象研究工具</td>
</tr>
<tr>
<td>git checkout</td>
<td>检出到工作区、切换或创建分支</td>
</tr>
<tr>
<td>git cherry-pick</td>
<td>提交拣选</td>
</tr>
<tr>
<td>git citool</td>
<td>图形化提交，相当于 git gui 命令</td>
</tr>
<tr>
<td>git clean</td>
<td>清除工作区未跟踪文件</td>
</tr>
<tr>
<td>git clone</td>
<td>克隆版本库</td>
</tr>
<tr>
<td>git commit</td>
<td>提交</td>
</tr>
<tr>
<td>git config</td>
<td>查询和修改配置</td>
</tr>
<tr>
<td>git describe</td>
<td>通过里程碑直观地显示提交 ID</td>
</tr>
<tr>
<td>git diff</td>
<td>差异比较</td>
</tr>
<tr>
<td>git difftool</td>
<td>调用图形化差异比较工具</td>
</tr>
<tr>
<td>git fetch</td>
<td>获取远程版本库的提交</td>
</tr>
<tr>
<td>git format-patch</td>
<td>创建邮件格式的补丁文件。参见 git am 命令</td>
</tr>
<tr>
<td>git grep</td>
<td>文件内容搜索定位工具</td>
</tr>
<tr>
<td>git gui</td>
<td>基于 Tcl&#x2F;Tk 的图形化工具，侧重提交等操作</td>
</tr>
<tr>
<td>git help</td>
<td>帮助</td>
</tr>
<tr>
<td>git init</td>
<td>版本库初始化</td>
</tr>
<tr>
<td>git init-db*</td>
<td>同义词，等同于 git init</td>
</tr>
<tr>
<td>git log</td>
<td>显示提交日志</td>
</tr>
<tr>
<td>git merge</td>
<td>分支合并</td>
</tr>
<tr>
<td>git mergetool</td>
<td>图形化冲突解决</td>
</tr>
<tr>
<td>git mv</td>
<td>重命名</td>
</tr>
<tr>
<td>git pull</td>
<td>拉回远程版本库的提交</td>
</tr>
<tr>
<td>git push</td>
<td>推送至远程版本库</td>
</tr>
<tr>
<td>git rebase</td>
<td>分支变基</td>
</tr>
<tr>
<td>git rebase–interactive</td>
<td>交互式分支变基</td>
</tr>
<tr>
<td>git reflog</td>
<td>分支等引用变更记录管理</td>
</tr>
<tr>
<td>git remote</td>
<td>远程版本库管理</td>
</tr>
<tr>
<td>git repo-config*</td>
<td>同义词，等同于 git config</td>
</tr>
<tr>
<td>git reset</td>
<td>重置改变分支“游标”指向</td>
</tr>
<tr>
<td>git rev-parse</td>
<td>将各种引用表示法转换为哈希值等</td>
</tr>
<tr>
<td>git revert</td>
<td>反转提交</td>
</tr>
<tr>
<td>git rm</td>
<td>删除文件</td>
</tr>
<tr>
<td>git show</td>
<td>显示各种类型的对象</td>
</tr>
<tr>
<td>git stage*</td>
<td>同义词，等同于 git add</td>
</tr>
<tr>
<td>git stash</td>
<td>保存和恢复进度</td>
</tr>
<tr>
<td>git status</td>
<td>显示工作区文件状态</td>
</tr>
<tr>
<td>git tag</td>
<td>里程碑管理</td>
</tr>
</tbody></table>
<p>2、对象库操作相关命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>git commit-tree</td>
<td>从树对象创建提交</td>
</tr>
<tr>
<td>git hash-object</td>
<td>从标准输入或文件计算哈希值或创建对象</td>
</tr>
<tr>
<td>git ls-files</td>
<td>显示工作区和暂存区文件</td>
</tr>
<tr>
<td>git ls-tree</td>
<td>显示树对象包含的文件</td>
</tr>
<tr>
<td>git mktag</td>
<td>读取标准输入创建一个里程碑对象</td>
</tr>
<tr>
<td>git mktree</td>
<td>读取标准输入创建一个树对象</td>
</tr>
<tr>
<td>git read-tree</td>
<td>读取树对象到暂存区</td>
</tr>
<tr>
<td>git update-index</td>
<td>工作区内容注册到暂存区及暂存区管理</td>
</tr>
<tr>
<td>git unpack-file</td>
<td>创建临时文件包含指定 blob 的内容</td>
</tr>
<tr>
<td>git write-tree</td>
<td>从暂存区创建一个树对象</td>
</tr>
</tbody></table>
<p>3、引用操作相关命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>git check-ref-format</td>
<td>检查引用名称是否符合规范</td>
</tr>
<tr>
<td>git for-each-ref</td>
<td>引用迭代器，用于 shell 编程</td>
</tr>
<tr>
<td>git ls-remote</td>
<td>显示远程版本库的引用</td>
</tr>
<tr>
<td>git name-rev</td>
<td>将提交 ID 显示为友好名称</td>
</tr>
<tr>
<td>git peek-remote*</td>
<td>过时命令，请使用 git ls-remote</td>
</tr>
<tr>
<td>git rev-list</td>
<td>显示版本范围</td>
</tr>
<tr>
<td>git show-branch</td>
<td>显示分支列表及拓扑关系</td>
</tr>
<tr>
<td>git show-ref</td>
<td>显示本地引用</td>
</tr>
<tr>
<td>git symbolic-ref</td>
<td>显示或者设置符号引用</td>
</tr>
<tr>
<td>git update-ref</td>
<td>更新引用的指向</td>
</tr>
<tr>
<td>git verify-tag</td>
<td>校验 GPG 签名的 Tag</td>
</tr>
</tbody></table>
<p>4、版本库管理相关命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>git count-objects</td>
<td>显示松散对象的数量和磁盘占用</td>
</tr>
<tr>
<td>git filter-branch</td>
<td>版本库重构</td>
</tr>
<tr>
<td>git fsck</td>
<td>对象库完整性检查</td>
</tr>
<tr>
<td>git fsck-objects*</td>
<td>同义词，等同于 git fsck</td>
</tr>
<tr>
<td>git gc</td>
<td>版本库存储优化</td>
</tr>
<tr>
<td>git index-pack</td>
<td>从打包文件创建对应的索引文件</td>
</tr>
<tr>
<td>git lost-found*</td>
<td>过时，请使用 git fsck –lost-found 命令</td>
</tr>
<tr>
<td>git pack-objects</td>
<td>从标准输入读入对象 ID，打包到文件</td>
</tr>
<tr>
<td>git pack-redundant</td>
<td>查找多余的 pack 文件</td>
</tr>
<tr>
<td>git pack-refs</td>
<td>将引用打包到 .git&#x2F;packed-refs 文件中</td>
</tr>
<tr>
<td>git prune</td>
<td>从对象库删除过期对象</td>
</tr>
<tr>
<td>git prune-packed</td>
<td>将已经打包的松散对象删除</td>
</tr>
<tr>
<td>git relink</td>
<td>为本地版本库中相同的对象建立硬连接</td>
</tr>
<tr>
<td>git repack</td>
<td>将版本库未打包的松散对象打包</td>
</tr>
<tr>
<td>git show-index</td>
<td>读取包的索引文件，显示打包文件中的内容</td>
</tr>
<tr>
<td>git unpack-objects</td>
<td>从打包文件释放文件</td>
</tr>
<tr>
<td>git verify-pack</td>
<td>校验对象库打包文件</td>
</tr>
</tbody></table>
<p>5、数据传输相关命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>git fetch-pack</td>
<td>执行 git fetch 或 git pull 命令时在本地执行此命令，用于从其他版本库获取缺失的对象</td>
</tr>
<tr>
<td>git receive-pack</td>
<td>执行 git push 命令时在远程执行的命令，用于接受推送的数据</td>
</tr>
<tr>
<td>git send-pack</td>
<td>执行 git push 命令时在本地执行的命令，用于向其他版本库推送数据</td>
</tr>
<tr>
<td>git upload-archive</td>
<td>执行 git archive –remote 命令基于远程版本库创建归档时，远程版本库执行此命令传送归档</td>
</tr>
<tr>
<td>git upload-pack</td>
<td>执行 git fetch 或 git pull 命令时在远程执行此命令，将对象打包、上传</td>
</tr>
</tbody></table>
<p>6、邮件相关命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>git imap-send</td>
<td>将补丁通过 IMAP 发送</td>
</tr>
<tr>
<td>git mailinfo</td>
<td>从邮件导出提交说明和补丁</td>
</tr>
<tr>
<td>git mailsplit</td>
<td>将 mbox 或 Maildir 格式邮箱中邮件逐一提取为文件</td>
</tr>
<tr>
<td>git request-pull</td>
<td>创建包含提交间差异和执行 PULL 操作地址的信息</td>
</tr>
<tr>
<td>git send-email</td>
<td>发送邮件</td>
</tr>
</tbody></table>
<p>7、协议相关命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>git daemon</td>
<td>实现 Git 协议</td>
</tr>
<tr>
<td>git http-backend</td>
<td>实现 HTTP 协议的 CGI 程序，支持智能 HTTP 协议</td>
</tr>
<tr>
<td>git instaweb</td>
<td>即时启动浏览器通过 gitweb 浏览当前版本库</td>
</tr>
<tr>
<td>git shell</td>
<td>受限制的 shell，提供仅执行 Git 命令的 SSH 访问</td>
</tr>
<tr>
<td>git update-server-info</td>
<td>更新哑协议需要的辅助文件</td>
</tr>
<tr>
<td>git http-fetch</td>
<td>通过 HTTP 协议获取版本库</td>
</tr>
<tr>
<td>git http-push</td>
<td>通过 HTTP&#x2F;DAV 协议推送</td>
</tr>
<tr>
<td>git remote-ext</td>
<td>由 Git 命令调用，通过外部命令提供扩展协议支持</td>
</tr>
<tr>
<td>git remote-fd</td>
<td>由 Git 命令调用，使用文件描述符作为协议接口</td>
</tr>
<tr>
<td>git remote-ftp</td>
<td>由 Git 命令调用，提供对 FTP 协议的支持</td>
</tr>
<tr>
<td>git remote-ftps</td>
<td>由 Git 命令调用，提供对 FTPS 协议的支持</td>
</tr>
<tr>
<td>git remote-http</td>
<td>由 Git 命令调用，提供对 HTTP 协议的支持</td>
</tr>
<tr>
<td>git remote-https</td>
<td>由 Git 命令调用，提供对 HTTPS 协议的支持</td>
</tr>
<tr>
<td>git remote-testgit</td>
<td>协议扩展示例脚本</td>
</tr>
</tbody></table>
<p>8、版本库转换和交互相关命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>git archimport</td>
<td>导入 Arch 版本库到 Git</td>
</tr>
<tr>
<td>git bundle</td>
<td>提交打包和解包，以便在不同版本库间传递</td>
</tr>
<tr>
<td>git cvsexportcommit</td>
<td>将 Git 的一个提交作为一个 CVS 检出</td>
</tr>
<tr>
<td>git cvsimport</td>
<td>导入 CVS 版本库到 Git。或者使用 cvs2git</td>
</tr>
<tr>
<td>git cvsserver</td>
<td>Git 的 CVS 协议模拟器，可供 CVS 命令访问 Git 版本库</td>
</tr>
<tr>
<td>git fast-export</td>
<td>将提交导出为 git-fast-import 格式</td>
</tr>
<tr>
<td>git fast-import</td>
<td>其他版本库迁移至 Git 的通用工具</td>
</tr>
<tr>
<td>git svn</td>
<td>Git 作为前端操作 Subversion</td>
</tr>
</tbody></table>
<p>9、合并相关的辅助命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>git merge-base</td>
<td>供其他脚本调用，找到两个或多个提交最近的共同祖先</td>
</tr>
<tr>
<td>git merge-file</td>
<td>针对文件的两个不同版本执行三向文件合并</td>
</tr>
<tr>
<td>git merge-index</td>
<td>对 index 中的冲突文件调用指定的冲突解决工具</td>
</tr>
<tr>
<td>git merge-octopus</td>
<td>合并两个以上分支。参见 git merge 的 octopus 合并策略</td>
</tr>
<tr>
<td>git merge-one-file</td>
<td>由 git merge-index 调用的标准辅助程序</td>
</tr>
<tr>
<td>git merge-ours</td>
<td>合并使用本地版本，抛弃他人版本。参见 git merge 的 ours 合并策略</td>
</tr>
<tr>
<td>git merge-recursive</td>
<td>针对两个分支的三向合并。参见 git merge 的 recursive 合并策略</td>
</tr>
<tr>
<td>git merge-resolve</td>
<td>针对两个分支的三向合并。参见 git merge 的 resolve 合并策略</td>
</tr>
<tr>
<td>git merge-subtree</td>
<td>子树合并。参见 git merge 的 subtree 合并策略</td>
</tr>
<tr>
<td>git merge-tree</td>
<td>显式三向合并结果，不改变暂存区</td>
</tr>
<tr>
<td>git fmt-merge-msg</td>
<td>供执行合并操作的脚本调用，用于创建一个合并提交说明</td>
</tr>
<tr>
<td>git rerere</td>
<td>重用所记录的冲突解决方案</td>
</tr>
</tbody></table>
<p>10、 杂项</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>git bisect–helper</td>
<td>由 git bisect 命令调用，确认二分查找进度</td>
</tr>
<tr>
<td>git check-attr</td>
<td>显示某个文件是否设置了某个属性</td>
</tr>
<tr>
<td>git checkout-index</td>
<td>从暂存区拷贝文件至工作区</td>
</tr>
<tr>
<td>git cherry</td>
<td>查找没有合并到上游的提交</td>
</tr>
<tr>
<td>git diff-files</td>
<td>比较暂存区和工作区，相当于 git diff –raw</td>
</tr>
<tr>
<td>git diff-index</td>
<td>比较暂存区和版本库，相当于 git diff –cached –raw</td>
</tr>
<tr>
<td>git diff-tree</td>
<td>比较两个树对象，相当于 git diff –raw A B</td>
</tr>
<tr>
<td>git difftool–helper</td>
<td>由 git difftool 命令调用，默认要使用的差异比较工具</td>
</tr>
<tr>
<td>git get-tar-commit-id</td>
<td>从 git archive 创建的 tar 包中提取提交 ID</td>
</tr>
<tr>
<td>git gui–askpass</td>
<td>命令 git gui 的获取用户口令输入界面</td>
</tr>
<tr>
<td>git notes</td>
<td>提交评论管理</td>
</tr>
<tr>
<td>git patch-id</td>
<td>补丁过滤行号和空白字符后生成补丁唯一 ID</td>
</tr>
<tr>
<td>git quiltimport</td>
<td>将 Quilt 补丁列表应用到当前分支</td>
</tr>
<tr>
<td>git replace</td>
<td>提交替换</td>
</tr>
<tr>
<td>git shortlog</td>
<td>对 git log 的汇总输出，适合于产品发布说明</td>
</tr>
<tr>
<td>git stripspace</td>
<td>删除空行，供其他脚本调用</td>
</tr>
<tr>
<td>git submodule</td>
<td>子模组管理</td>
</tr>
<tr>
<td>git tar-tree</td>
<td>过时命令，请使用 git archive</td>
</tr>
<tr>
<td>git var</td>
<td>显示 Git 环境变量</td>
</tr>
<tr>
<td>git web–browse</td>
<td>启动浏览器以查看目录或文件</td>
</tr>
<tr>
<td>git whatchanged</td>
<td>显示提交历史及每次提交的改动</td>
</tr>
<tr>
<td>git-mergetool–lib</td>
<td>包含于其他脚本中，提供合并&#x2F;差异比较工具的选择和执行</td>
</tr>
<tr>
<td>git-parse-remote</td>
<td>包含于其他脚本中，提供操作远程版本库的函数</td>
</tr>
<tr>
<td>git-sh-setup</td>
<td>包含于其他脚本中，提供 shell 编程的函数库</td>
</tr>
</tbody></table>
<h1 id="Git-冲突与解决方法"><a href="#Git-冲突与解决方法" class="headerlink" title="Git 冲突与解决方法"></a>Git 冲突与解决方法</h1><p>1、git 冲突的场景</p>
<ul>
<li>情景一：多个分支代码合并到一个分支时；</li>
<li>情景二：多个分支向同一个远端分支推送代码时；</li>
</ul>
<p>实际上，push 操作即是将本地代码 merge 到远端库分支上。</p>
<p>关于 push 和 pull 其实就分别是用本地分支合并到远程分支 和 将远程分支合并到本地分支</p>
<p>所以这两个过程中也可能存在冲突。</p>
<p>git 的合并中产生冲突的具体情况：<br>　　&lt;1&gt;两个分支中修改了同一个文件（不管什么地方）<br>　　&lt;2&gt;两个分支中修改了同一个文件的名称<br>两个分支中分别修改了不同文件中的部分，不会产生冲突，可以直接将两部分合并。</p>
<p>2、冲突解决方法</p>
<ul>
<li>情景一：在当前分支上，直接修改冲突代码—&gt;add—&gt;commit。</li>
<li>情景二：在本地当前分支上，修改冲突代码—&gt;add—&gt;commit—&gt;push</li>
</ul>
<p>注：借用 vim 或者 IDE 或者直接找到冲突文件，修改。</p>
<h1 id="redux-之同步-x2F-异步控制数据"><a href="#redux-之同步-x2F-异步控制数据" class="headerlink" title="redux 之同步&#x2F;异步控制数据"></a>redux 之同步&#x2F;异步控制数据</h1><p>1、同步</p>
<p>Redux 通过 <a target="_blank" rel="noopener" href="http://cn.redux.js.org/docs/api/Store.html#dispatch"><code>store.dispatch()</code></a> 将 action 传到 store。</p>
<p>Redux 应用中数据的生命周期遵循下面 4 个步骤：</p>
<ol>
<li><strong>调用</strong> <a target="_blank" rel="noopener" href="http://cn.redux.js.org/docs/api/Store.html#dispatch"><code>store.dispatch(action)</code></a>。</li>
<li><strong>Redux store 调用传入的 reducer 函数。</strong></li>
<li><strong>根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。</strong></li>
<li><strong>Redux store 保存了根 reducer 返回的完整 state 树。</strong></li>
</ol>
<p>2、异步</p>
<p>redux-saga</p>
<p>redux-saga 是一个 redux 中间件。</p>
<h1 id="redux-有什么缺点"><a href="#redux-有什么缺点" class="headerlink" title="redux 有什么缺点"></a>redux 有什么缺点</h1><ul>
<li>Redux 带来了函数式编程、不可变性思想等等，为了配合这些理念，开发者必须要写很多“模式代码（boilerplate）”，繁琐以及重复是开发者不愿意容忍的。当然也有很多 hack 旨在减少 boilerplate，但目前阶段，可以说 Redux 天生就附着繁琐；</li>
<li>使用 Redux，那么你的应用就要用 objects 或者 arrays 描述状态；OMG！</li>
<li>使用 Redux，那么你的应用就要使用 plain objects 即 actions ，来描述变化；OMG！</li>
<li>使用 Redux，那么你的应用就要使用纯函数去处理变化；OMG！</li>
<li>应用中，状态很多都要抽象到 store，那么何时使用 local states 何时接入 Redux store？</li>
<li>不能痛痛快快地写业务，一个变化就要对应编写 action（action creator），reducer 等等；</li>
<li>和响应式结合函数式的 Mobx 相比，编程体验“打折扣”</li>
</ul>
<p><strong>我在额外追加一条：</strong></p>
<p><strong>Redux 可以理解为一个简易的发布订阅系统。那么因此带来的内存消费也许会大一丢丢。</strong></p>
<h1 id="Vue-源码"><a href="#Vue-源码" class="headerlink" title="Vue 源码"></a>Vue 源码</h1><p><strong>1.1 Flow 基本语法</strong></p>
<p>相信大家都知道，javascript 是弱类型的语言，在写代码灰常爽的同时也十分容易犯错误，所以 Facebook 搞了这么一个类型检查工具，可以加入类型的限制，提高代码质量，举个例子:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可是这样，我们如果这么调用这个函数 sum(‘a’, 1) 甚至 sum(1, [1,2,3])这么调用，执行时会得到一些你想不到的结果，这样编程未免太不稳定了。那我们看看用了 Flow 之后的结果：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到多了一个 number 的限制，标明对 a 和 b 只能传递数字类型的，否则的话用 Flow 工具检测会报错。其实这里大家可能有疑问，这么写还是 js 吗？ 浏览器还能认识执行吗？当然不认识了，所以需要翻译或者说编译。其实现在前端技术发展太快了，各种插件层出不穷–Babel、Typescript 等等，其实都是将一种<strong>更好的写法</strong>编译成浏览器认识的 javascript 代码（我们以前都是写浏览器认识的 javascript 代码的）。我们继续说 Flow 的事情，在 Vue 源码中其实出现的 Flow 语法都比较好懂，比如下面这个函数的定义：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">renderList</span> (</span><br><span class="line">  <span class="attr">val</span>: <span class="built_in">any</span>,</span><br><span class="line">  <span class="attr">render</span>: <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    val: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    keyOrIndex: <span class="built_in">string</span> | <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    index?: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> <span class="title class_">VNode</span></span><br><span class="line">): ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>val 是 any 代表可以传入的类型是任何类型， keyOrIndex 是 string|number 类型，代表要不是 string 类型，要不是 number，不能是别的；index?:number 这个我们想想正则表达式中？的含义—0 个或者 1 个，这里其实意义也是一致的，但是要注意?的位置是在冒号之前还是冒号之后–因为这两种可能性都有，<strong>上面代码中问号是跟在冒号前面，代表 index 可以不传，但是传的话一定要传入数字类型；如果问号是在冒号后面的话，则代表这个参数必须要传递，但是可以是数字类型也可以是空</strong>。这样是不是顿时感觉严谨多了？同时，代码意义更明确了。为啥这么说呢？ 之前看打包后的 vue 源码，其中看到观察者模式实现时由于没有类型十分难看懂，但是看了这个 Flow 版本的源码，感觉容易懂。 当然，如果想学习 Flow 更多的细节， 可以看看下面这个学习文档：<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26204569">Flow 学习资料</a></p>
<p><strong>1.2 原型与原型继承</strong></p>
<p>Vue 中的组件相信大家都使用过，并且组件之中可以有子组件，那么这里就涉及到父子组件了。组件其实初始化过程都是一样的，显然有些方法是可以继承的。Vue 代码中是使用原型继承的方式实现父子组件共享初始化代码的。</p>
<p><strong>1.3 Object.defineProperty</strong></p>
<p>这个方法在 js 中十分强大，Vue 正是使用了它实现了响应式数据功能。我们先瞄一眼 Vue 中定义响应式数据的代码：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">defineReactive</span> (</span><br><span class="line">  <span class="attr">obj</span>: <span class="title class_">Object</span>,</span><br><span class="line">  <span class="attr">key</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">val</span>: <span class="built_in">any</span>,</span><br><span class="line">  customSetter?: ?<span class="title class_">Function</span>,</span><br><span class="line">  shallow?: <span class="built_in">boolean</span></span><br><span class="line">) &#123;</span><br><span class="line">  .....</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span> () &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        dep.<span class="title function_">depend</span>()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line">          <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">            <span class="title function_">dependArray</span>(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span> (newVal) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        <span class="title function_">customSetter</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.<span class="title function_">call</span>(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(newVal)</span><br><span class="line">      dep.<span class="title function_">notify</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中我们看到 Object.defineProperty 这个函数的运用，其中第一个参数代表要设置的对象，第二个参数代表要设置的对象的键值，第三个参数是一个配置对象，对象里面可以设置参数如下：<br>value: 对应 key 的值，无需多言<br>configurable：是否可以删除该 key 或者重新配置该 key<br>enumerable：是否可以遍历该 key<br>writable：是否可以修改该 key<br>get: 获取该 key 值时调用的函数<br>set: 设置该 key 值时调用的函数<br>我们通过一个例子来了解一下这些属性：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = &#123;&#125;</span><br><span class="line">x[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(x, <span class="string">&#x27;name&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>Object.getOwnPropertyDescriptor 可以获取对象某个 key 的描述对象，打印结果如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">value</span>: <span class="string">&quot;vue&quot;</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上可知，该 key 对应的属性我们可以改写(writable:true),可以重新设置或者删除(configurable: true),同时可以遍历(enumerable:true)。那么让我们修改一下这些属性，比如 configurable,代码如下:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(x, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">      configurable: <span class="keyword">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>执行成功之后，如果你再想删除该属性，比如 delete x[‘name’]，你会发现返回为 false，即无法删除了。<br>那 enumerable 是什么意思呢？来个例子就明白了，代码如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = &#123;&#125;</span><br><span class="line">x[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">x[<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(x, <span class="number">2</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> x) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;key:&#x27;</span> + key + <span class="string">&#x27;|value:&#x27;</span> + x[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：<br>key:1|value:2<br>为什么呢？ 因为我们把 2 设置为不可遍历了，那么我们的 for 循环就取不到了，当然我们还是可以用 x[2]去取到 2 对应的值得，只是 for 循环中取不到而已。这个有什么用呢？Vue 源码中 Observer 类中有下面一行代码：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def(value, <span class="string">&#x27;__ob__&#x27;</span>, this);</span><br></pre></td></tr></table></figure>

<p>这里 def 是个工具函数，目的是想给 value 添加一个 key 为<strong>ob</strong>，值为 this，但是为什么不直接 value.<strong>ob</strong> &#x3D; this 反而要大费周章呢？<br>因为程序下面要遍历 value 对其子内容进行递归设置，如果直接用 value.<strong>ob</strong>这种方式，在遍历时又会取到造成，这显然不是本意，所以 def 函数是利用 Object.defineProperty 给 value 添加的属性，同时 enumerable 设置为 false。<br>至于 get 和 set 嘛？这个就更强大了，类似于在获取对象值和设置对象值时加了一个代理，在这个代理函数中可以做的东西你就可以想象了，比如设置值时再通知一下 View 视图做更新。也来个例子体会一下吧：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(x, <span class="number">1</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getter called!&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setter called! newVal is:&#x27;</span> + newVal)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当我们访问 x[1]时便会打印 getter called，当我们设置 x[1] &#x3D; 2 时，打印 setter called。Vue 源码正是通过这种方式实现了访问属性时收集依赖，设置属性时源码有一句 dep.notify，里面便是通知视图更新的相关操作。</p>
<p><strong>1.4 Vnode 概念</strong></p>
<p>Vnode，顾名思义，Virtual node，虚拟节点，首先声明，这不是 Vue 自己首创的概念，其实 Github 上早就有一个类似的项目:<a target="_blank" rel="noopener" href="https://github.com/snabbdom/snabbdom">Snabbdom</a>。我个人认为，Vue 应该也参考过这个库的实现，因为这个库包含了完整的 Vnode 以及 dom diff 算法，甚至实现的具体代码上感觉 Vue 和这个库也是有点相像的。为啥要用 Vnode 呢？其实原因主要是原生的 dom 节点对象太大了，我们运行一下代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dom = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> dom) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印的结果灰常长！！！说明这个 dom 对象节点有点重量级，而我们的 html 网页经常数以百计个这种 dom 节点，如果采用之前的 Jquery 这种方式直接操作 dom，性能上确实稍微 low 一点。所以 snabbdom 或者 Vue 中应用了 Vnode，Vnode 对象啥样呢？ 看看 Vue 源码对 Vnode 的定义：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">VNode</span> &#123;</span><br><span class="line">  <span class="attr">tag</span>: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">data</span>: <span class="title class_">VNodeData</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">children</span>: ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;;</span><br><span class="line">  <span class="attr">text</span>: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">elm</span>: <span class="title class_">Node</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">ns</span>: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span> | <span class="built_in">void</span>; <span class="comment">// rendered in this component&#x27;s scope</span></span><br><span class="line">  <span class="attr">key</span>: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">componentOptions</span>: <span class="title class_">VNodeComponentOptions</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">componentInstance</span>: <span class="title class_">Component</span> | <span class="built_in">void</span>; <span class="comment">// component instance</span></span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">VNode</span> | <span class="built_in">void</span>; <span class="comment">// component placeholder node</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// strictly internal</span></span><br><span class="line">  <span class="attr">raw</span>: <span class="built_in">boolean</span>; <span class="comment">// contains raw HTML? (server only)</span></span><br><span class="line">  <span class="attr">isStatic</span>: <span class="built_in">boolean</span>; <span class="comment">// hoisted static node</span></span><br><span class="line">  <span class="attr">isRootInsert</span>: <span class="built_in">boolean</span>; <span class="comment">// necessary for enter transition check</span></span><br><span class="line">  <span class="attr">isComment</span>: <span class="built_in">boolean</span>; <span class="comment">// empty comment placeholder?</span></span><br><span class="line">  <span class="attr">isCloned</span>: <span class="built_in">boolean</span>; <span class="comment">// is a cloned node?</span></span><br><span class="line">  <span class="attr">isOnce</span>: <span class="built_in">boolean</span>; <span class="comment">// is a v-once node?</span></span><br><span class="line">  <span class="attr">asyncFactory</span>: <span class="title class_">Function</span> | <span class="built_in">void</span>; <span class="comment">// async component factory function</span></span><br><span class="line">  <span class="attr">asyncMeta</span>: <span class="title class_">Object</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">isAsyncPlaceholder</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">ssrContext</span>: <span class="title class_">Object</span> | <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">fnContext</span>: <span class="title class_">Component</span> | <span class="built_in">void</span>; <span class="comment">// real context vm for functional nodes</span></span><br><span class="line">  <span class="attr">fnOptions</span>: ?<span class="title class_">ComponentOptions</span>; <span class="comment">// for SSR caching</span></span><br><span class="line">  <span class="attr">fnScopeId</span>: ?<span class="built_in">string</span>;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比之下, Vnode 对象的属性确实少了很多；其实光属性少也不见得性能就能高到哪儿去，另一个方面便是针对新旧 Vnode 的 diff 算法了。这里其实有一个现象：其实大多数场景下即便有很多修改，但是如果从宏观角度观看，其实修改的点不多。举个例子：<br>比如有以下三个 dom 节点 A B C<br>我们的操作中依次会改成 B C D<br>如果采用 Jquery 的改法，当碰到第一次 A 改为 B 时，修改了一次，再碰到 B 改为 C，又修改了一次，再次碰到 C 改为 D，又又修改了一次，显然其实从宏观上看，只需要删除 A，然后末尾加上 D 即可，修改次数得到减少；但是这种优化是有前提的，也就是说能够从宏观角度看才行。以前 Jquery 的修改方法在碰到第一次修改的时候，需要把 A 改为 B，这时代码还没有执行到后面，它是不可能知道后面的修改的，也就是无法以全局视角看问题。所以从全局看问题的方式就是异步，先把修改放到队列中，然后整成一批去修改，做 diff，这个时候从统计学意义上来讲确实可以优化性能。这也是为啥 Vue 源码中出现下述代码的原因:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queueWatcher(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p><strong>1.5 函数柯里化</strong></p>
<p>函数柯里化是什么鬼呢？其实就是将多参数的函数化作多个部分函数去调用。举个例子：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是个两个参数的函数，可以直接 getSum(1,2)调用拿到结果；然而，有时候并不会两个参数都能确定，只想先传一个值，另外一个在其他时间点再传入，那我们把函数改为：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们如何调用这个柯里化之后的函数呢？</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="title function_">getSum</span>(<span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">f</span>(<span class="number">3</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(<span class="number">2</span>)(<span class="number">3</span>)) <span class="comment">//结果同上</span></span><br></pre></td></tr></table></figure>

<p>可见，柯里化的效果便是之前必须同时传入两个参数才能调用成功而现在两个参数可以在不同时间点传入。那为毛要这么做嘛？Vue 源码是这么应用这个特性的，Vue 源码中有一个 platform 目录，专门存放和平台相关的源码（Vue 可以在多平台上运行 比如 Weex）。那这些源码中肯定有些操作是和平台相关的，比如会有些以下伪代码所表示的逻辑:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(平台A)&#123;</span><br><span class="line">....</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(平台B)&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可是如果这么写会有个小不舒服的地方，那就是其实代码运行时第一次走到这里根据当前平台就已经知道走哪一个分支了，而现在这么写必当导致代码再次运行到这里的时候还会进行平台判断，这样总感觉会多一些无聊的多余判断，因此 Vue 解决此问题的方式就是应用了函数柯里化技巧，类似声明了以下一个函数:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> ...(平台相关参数)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">平台不相关参数</span>)&#123;</span><br><span class="line">          处理逻辑</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Vue 的 patch 以及编译环节都应用了这种方式，讲到那部分代码时我们再细致的看，读者提前先了解一下可以帮助理解 Vue 的设计。</p>
<p><strong>1.6 Macrotask 与 Microtask</strong></p>
<p>可能有的读者第一次听到这两个词，实际上这个和 js 的事件循环机制息息相关。在上面我们也提到，Vue 更新不是数据一改马上同步更新视图的，这样肯定会有性能问题，比如在一个事件处理函数里先 this.data &#x3D; A 然后再 this.data&#x3D;B,如果要渲染两次，想想都感觉很 low。Vue 源码实际上是将更改都放入到队列中，同一个 watcher 不会重复（不理解这些概念不要紧，后面源码会重点介绍），然后异步处理更新逻辑。在实现异步的方式时，js 实际提供了两种 task–<strong>Macrotask 与 Microtask</strong>。两种 task 有什么区别呢？先从一个例子讲起：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise3&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise4&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>以上代码运行结果是什么呢？读者可以思考一下，答案应该是：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">script <span class="keyword">end</span></span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br><span class="line">promise3</span><br><span class="line">promise4</span><br></pre></td></tr></table></figure>

<p>简单可以这么理解，js 事件循环中有两个队列，一个叫 MacroTask，一个 MircroTask，看名字就知道 Macro 是大的，Micro 是小的（想想宏观经济学和微观经济学的翻译）。那么大任务队列跑大任务–比如主流程程序了、事件处理函数了、setTimeout 了等等，小任务队列跑小任务，目前读者记住一个就可以–Promise。js 总是<strong>先从大任务队列拿一个执行，然后再把所有小任务队列全部执行再循环往复</strong>。以上面示例程序，首先整体上个这个程序是一个大任务先执行，执行完毕后要执行所有小任务，Promise 就是小任务，所以又打印出 promise1 和 promise2，而 setTimeout 是大任务，所以执行完所有小任务之后，再取一个大任务执行，就是 setTimeout，这里面又往小任务队列扔了一个 Promise，所以等 setTimeout 执行完毕之后，又去执行所有小任务队列，所以最后是 promise3 和 promise4。说的有点绕，把上面示例程序拷贝到浏览器执行一下多思考一下就明白了，关键是要知道<strong>上面程序本身也是一个大任务</strong>。一定要理解了之后再去看 Vue 源码，否则不会理解 Vue 中的 nextTick 函数。<br>推荐几篇文章吧（我都认真读完了，受益匪浅）<br><a target="_blank" rel="noopener" href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">Macrotask Vs Microtask</a><br><a target="_blank" rel="noopener" href="https://juejin.im/entry/58d4df3b5c497d0057eb99ff">理解 js 中 Macrotask 和 Microtask</a><br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">阮一峰 Eventloop 理解</a></p>
<p><strong>1.7 递归编程算法</strong></p>
<p>很多程序员比较害怕递归，但是递归真的是一种灰常灰常强大的算法。Vue 源码中大量使用了递归算法–比如 dom diff 算法、ast 的优化、目标代码的生成等等….很多很多。而且这些递归不仅仅是 A-&gt;A 这么简单，大多数源码中的递归是 A-&gt;B-&gt;C…-&gt;A 等等这种复杂递归调用。比如 Vue 中经典的 dom diff 算法：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldStartVnode)) &#123;</span><br><span class="line">    oldStartVnode = oldCh[++oldStartIdx]; <span class="comment">// Vnode has been moved left</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldEndVnode)) &#123;</span><br><span class="line">    oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">    <span class="title function_">patchVnode</span>(oldStartVnode, newStartVnode, insertedVnodeQueue);</span><br><span class="line">    oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">    newStartVnode = newCh[++newStartIdx];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">    <span class="title function_">patchVnode</span>(oldEndVnode, newEndVnode, insertedVnodeQueue);</span><br><span class="line">    oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">    newEndVnode = newCh[--newEndIdx];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">    <span class="title function_">patchVnode</span>(oldStartVnode, newEndVnode, insertedVnodeQueue);</span><br><span class="line">    canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, oldStartVnode.<span class="property">elm</span>, nodeOps.<span class="title function_">nextSibling</span>(oldEndVnode.<span class="property">elm</span>));</span><br><span class="line">    oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">    newEndVnode = newCh[--newEndIdx];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">    <span class="title function_">patchVnode</span>(oldEndVnode, newStartVnode, insertedVnodeQueue);</span><br><span class="line">    canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, oldEndVnode.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>);</span><br><span class="line">    oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">    newStartVnode = newCh[++newStartIdx];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldKeyToIdx)) &#123; oldKeyToIdx = <span class="title function_">createKeyToOldIdx</span>(oldCh, oldStartIdx, oldEndIdx); &#125;</span><br><span class="line">    idxInOld = <span class="title function_">isDef</span>(newStartVnode.<span class="property">key</span>)</span><br><span class="line">      ? oldKeyToIdx[newStartVnode.<span class="property">key</span>]</span><br><span class="line">      : <span class="title function_">findIdxInOld</span>(newStartVnode, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">      <span class="title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="property">elm</span>, <span class="literal">false</span>, newCh, newStartIdx);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnodeToMove = oldCh[idxInOld];</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">sameVnode</span>(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">        <span class="title function_">patchVnode</span>(vnodeToMove, newStartVnode, insertedVnodeQueue);</span><br><span class="line">        oldCh[idxInOld] = <span class="literal">undefined</span>;</span><br><span class="line">        canMove &amp;&amp; nodeOps.<span class="title function_">insertBefore</span>(parentElm, vnodeToMove.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">        <span class="title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="property">elm</span>, <span class="literal">false</span>, newCh, newStartIdx);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    newStartVnode = newCh[++newStartIdx];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面代码是比较新旧 Vnode 节点更新孩子节点的部分源码，调用者是 patchVnode 函数，我们发现这部分函数中又会调用会 patchVnode，调用链条为:patchVnode-&gt;updateChildren-&gt;patchVnode。同时，即便没有直接应用递归，在将模板编译成 AST（抽象语法树）的过程中，其使用了栈去模拟了递归的思想，由此可见递归算法的重要性。这也难怪，毕竟不管是真实 dom 还是 vnode，其实本质都是树状结构，本来就是递归定义的东西。我们也会单独拿出一篇文章讲讲递归，比如用递归实现一下 JSON 串的解析。希望读者注意查看。</p>
<p><strong>1.8 编译原理基础知识</strong></p>
<p>这恐怕比递归更让某些程序员蛋疼，但是我相信只要读者认真把 Vue 这部分代码看懂，绝对比看 N 遍编译原理的课本更能管用。我们看看 Vue 源码这里的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> ast = <span class="built_in">parse</span>(<span class="keyword">template</span>.<span class="built_in">trim</span>(), options)</span><br><span class="line"><span class="keyword">if</span> (options.optimize !== <span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="built_in">optimize</span>(ast, options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> code = <span class="built_in">generate</span>(ast, options)</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  ast,</span><br><span class="line">  render: code.render,</span><br><span class="line">  staticRenderFns: code.staticRenderFns</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码首先通过 parse 函数将 template 编译为抽象语法树 ast，然后对 ast 进行代码优化，最后生成 render 函数。其实这个过程就是翻译，比如 gcc 把 c 语言翻译为汇编、又比如 Babel 把 ES6 翻译为 ES5 等等，这里面的流程十分都是十分地相似。Vue 也玩了这么一把，把模板 html 编译为 render 函数，什么意思呢？</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;record in commits&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;date&quot;</span>&gt;</span>&#123;&#123;record.commit.author.date&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>比如上面的 html，你觉得浏览器会认识嘛？显然 v-for 不是 html 原生的属性，上述代码如果直接在浏览器运行，你会发现就直接展示出来了，v-for 也没有起作用，当然还是会出现 html 里面（毕竟 html 容错性很高的）；但是经过 Vue 的编译系统一编译生成一些函数，这些函数一执行就是浏览器认识的 html 元素了，神奇吧? 其实仅仅是应用了编译原理课本的部分知识罢了，这部分我们后面会灰常灰常详细的介绍源码，只要跟着看下来，必定会对编译过程有所理解。现在可以这么简单理解一下 AST（抽象语法树），比如 java 可以写一个 if 判断，C 语言也可以写，js、python 等等也可以（如下所示）:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java:</span><br><span class="line">if(x &gt; 5)&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">python:</span><br><span class="line">if x&gt;5:</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>虽然从语法形式上写法不太一致，但是抽象出共同点其实都是一个 if 语句跟着一个 x&gt;5 的条件，那么 ast 就是一种表现大家共同点的一种结构。得到 ast 是翻译的基础。</p>
<p>综上，Vue 源码其实代码行数并不是很多，但是其简约凝练的风格深深吸引了我。我会重点分析 Vue 源码中观察者模式的实现、Vnode 以及 dom diff 算法的实现以及模板编译为 render 函数的实现。这三者我感觉就是 Vue 源码中最精彩的地方，希望你我都可以从中汲取养分，不断提高！</p>
<h1 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h1><p><strong>移动端适配技术构成：</strong></p>
<ul>
<li>rem</li>
<li>rem 是相对长度单位，可以做到一样的取值，在不同尺寸的屏幕上的大小按比例缩放。<br><strong>rem 的定义：</strong>rem（font size of the root element）是相对于根元素（即 html 元素）font-size 计算值的倍数。<br>例如 html 标签设置 font-size:16px，同时 div 设置 width:1.2rem。那么这个 div 的宽度就是 1.2rem&#x3D;16px*1.2&#x3D;19.2px。<br>因此这种方法的<strong>适配原理</strong>是：根据不同屏幕的宽度，以相同的比例动态修改 html 的 font-size 适配，并将 px 替换成 rem，它可以很好的根据根元素的字体大小来进行变化，从而达到各种屏幕基本一直的效果体验。</li>
<li>vw ，vh</li>
<li>calc（） 函数可以动态计算长度。</li>
<li>media queries 媒体查询</li>
<li>百分比布局</li>
<li>flex，grid</li>
<li>flexible image 弹性图片</li>
</ul>
<ol>
<li><p>说说 TS 和 ES 的区别，以及 TS 带来的好处？</p>
<ol>
<li><p>目标：生命周期较长（常常持续几年）的复杂 SPA 应用，保障开发效率的同时提升代码的可维护性和线上运行时质量。</p>
<ul>
<li>从开发效率上看，虽然需要多写一些类型定义代码，但 TS 在 VSCode、WebStorm 等 IDE 下可以做到智能提示，智能感知 bug，同时我们项目常用的一些第三方类库框架都有 TS 类型声明，我们也可以给那些没有 TS 类型声明的稳定模块写声明文件，如我们的前端 KOP 框架(目前还是蚂蚁内部框架，类比 dva)，这在团队协作项目中可以提升整体的开发效率。</li>
<li>从可维护性上看，长期迭代维护的项目开发和维护的成员会有很多，团队成员水平会有差异，而软件具有熵的特质，长期迭代维护的项目总会遇到可维护性逐渐降低的问题，有了强类型约束和静态检查，以及智能 IDE 的帮助下，可以降低软件腐化的速度，提升可维护性，且在重构时，强类型和静态类型检查会帮上大忙，甚至有了类型定义，会不经意间增加重构的频率（更安全、放心）。</li>
<li>从线上运行时质量上看，我们现在的 SPA 项目的很多 bug 都是由于一些调用方和被调用方（如组件模块间的协作、接口或函数的调用）的数据格式不匹配引起的，由于 TS 有编译期的静态检查，让我们的 bug 尽可能消灭在编译器，加上 IDE 有智能纠错，编码时就能提前感知 bug 的存在，我们的线上运行时质量会更为稳定可控。</li>
</ul>
<p>TS 适合大规模 JavaScript 应用，正如他的官方宣传语 JavaScript that scales。从以下几点可以看到 TS 在团队协作、可维护性、易读性、稳定性（编译期提前暴露 bug）等方面上有着明显的好处：</p>
<ul>
<li>加上了类型系统，对于阅读代码的人和编译器都是友好的。对阅读者来说，类型定义加上 IDE 的智能提示，增强了代码的易读型；对于编译器来说，类型定义可以让编译器揪出隐藏的 bug。</li>
<li>类型系统+静态分析检查+智能感知&#x2F;提示，使大规模的应用代码质量更高，运行时 bug 更少，更方便维护。</li>
<li>有类似 VSCode 这样配套的 IDE 支持，方便的查看类型推断和引用关系，可以更方便和安全的进行重构，再也不用全局搜索，一个个修改了。</li>
<li>给应用配置、应用状态、前后端接口及各种模块定义类型，整个应用都是一个个的类型定义，使协作更为方便、高效和安全。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h3><ol>
<li>虚拟 DOM 中采用的算法</li>
<li>把树形结构按照层级分解，只比较同级元素。不同层级的节点只有创建和删除操作</li>
<li>给列表结构的每个单元添加唯一的 key 属性，方便比较。</li>
<li>React 只会匹配相同 class 名的 component（这里面的 class 指的是组件的名字）</li>
<li>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.</li>
<li>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</li>
</ol>
<h1 id="前端错误处理"><a href="#前端错误处理" class="headerlink" title="前端错误处理"></a>前端错误处理</h1><h4 id="操作错误-VS-编码错误"><a href="#操作错误-VS-编码错误" class="headerlink" title="操作错误 VS 编码错误"></a>操作错误 VS 编码错误</h4><h5 id="1-操作错误"><a href="#1-操作错误" class="headerlink" title="1. 操作错误"></a>1. 操作错误</h5><p>操作错误往往发生在运行时，并不是 bug 导致，可能是由于你的系统内存用完了或者是由于文件句柄用完了，也可能是没有网络了等等</p>
<h5 id="2-编码错误"><a href="#2-编码错误" class="headerlink" title="2.编码错误"></a>2.编码错误</h5><p>编码错误那就比较容易理解了，可能是<strong>undefined</strong>却当作函数调用，或者返回了不正确的数据类型，或者内存泄露等等</p>
<h4 id="处理操作错误"><a href="#处理操作错误" class="headerlink" title="处理操作错误"></a>处理操作错误</h4><ul>
<li>你可以记录一下错误，然后什么都不做</li>
<li>你也可以重试，比如因为链接数据库失败了，但是重试需要限制次数</li>
<li>你也可以将错误告诉前端，稍后再试</li>
<li>也许你也可以直接处理，比如某个路径不存在，则创建该路径</li>
</ul>
<h4 id="处理编码错误"><a href="#处理编码错误" class="headerlink" title="处理编码错误"></a>处理编码错误</h4><p>错误编码是不好处理的，因为是由于编码错误导致的。好的办法其实重启该进程，因为</p>
<ul>
<li>你不确定某个编码错误导致的错误会不会影响其它请求，比如建立数据库链接错误由于编码错误导致不能成功，那么其它错误将导致其它的请求也不可用</li>
<li>或许在错误抛出之前进行 IO 操作，导致 IO 句柄无法关闭，这将长期占有内存，可能导致最后内存耗尽整个服务不可用。</li>
<li>上面提到的两点其实都没有解决问题根本，应该在上线前做好测试，并在上线后做好监控，一旦发生类似的错误，就应该监控报警，关注并解决问题</li>
</ul>
<h4 id="如何分发错误"><a href="#如何分发错误" class="headerlink" title="如何分发错误"></a>如何分发错误</h4><ul>
<li>在同步函数中，直接<strong>throw</strong>出错误</li>
<li>对于一些异步函数，可以将错误通过<strong>callback</strong>抛出</li>
<li><strong>async&#x2F;await</strong>可以直接使用<strong>try..catch</strong>捕获错误</li>
<li><strong>EventEmitter</strong>抛出<strong>error</strong>事件</li>
</ul>
<h4 id="NodeJs-的运维"><a href="#NodeJs-的运维" class="headerlink" title="NodeJs 的运维"></a>NodeJs 的运维</h4><p>一个 NodeJs 运用，仅仅从码层面是很难保证稳定运行的，还要从运维层面去保障。</p>
<h5 id="多进程来管理你的应用"><a href="#多进程来管理你的应用" class="headerlink" title="多进程来管理你的应用"></a>多进程来管理你的应用</h5><p>单进程的 nodejs 一旦挂了，整个服务也就不可用了，所以我萌需要多个进程来保障服务的可用，某个进程只负责处理其它进程的启动，关闭，重启。保障某个进程挂掉后能够立即重启。</p>
<h2 id="Vue-首屏加载速度优化，提升-80-以上"><a href="#Vue-首屏加载速度优化，提升-80-以上" class="headerlink" title="Vue 首屏加载速度优化，提升 80%以上"></a>Vue 首屏加载速度优化，提升 80%以上</h2><p>**一、对于第三方****js 库的优化，分离打包**</p>
<p>生产环境是内网的话，就把资源放内网，通过静态文件引入，会比 node_modules 和外网 CDN 的打包加载快很多。如果有外网的话，可以通过 CDN 方式引入，因为不用占用访问外网的带宽，不仅可以为您节省流量，还能通过 CDN 加速，获得更快的访问速度。但是要注意下，如果你引用的 CDN 资源存在于第三方服务器，在安全性上并不完全可控。</p>
<p>目前采用引入依赖包生产环境的 js 文件方式加载，直接通过 window 可以访问暴露出的全局变量，不必通过 import 引入，Vue.use 去注册</p>
<p>在 webpack 的 dev 开发配置文件中, 加入如下参数，可以分离打包第三方资源包，key 为依赖包名称，value 是源码抛出来的全局变量。如下图所示，可以看到打包后 vue 相关资源包已经排除在外了。对于一些其他的工具库，尽量采用按需引入的方式。</p>
<p>**二、vue-router****使用懒加载**</p>
<p>在访问到当前页面才会加载相关的资源，异步方式分模块加载文件，默认的文件名是随机的 id。如果在 output 中配置了 chunkFilename，可以在 component 中添加 WebpackChunkName，是为了方便调试，在页面加载时候，会显示加载的对应文件名+hash 值，如下图：</p>
<p>三、图片资源的压缩，icon 资源使用雪碧图</p>
<p>严格说来这一步不算在编码技术范围内，但是却对页面的加载速度影响很大。对于所有的图片文件，都可以在一个叫 tinypng 的网站上去压缩一下。网址：tinypng.com&#x2F;，对页面上使用到的 icon，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻 http 请求压力。然后通过操作 CSS 的 background 属性，控制背景的位置以及大小，来展示需要的部分。</p>
<p><strong>四、开启 gizp 压缩</strong></p>
<p>gizp 压缩是一种 http 请求优化方式，通过减少文件体积来提高加载速度。html、js、css 文件甚至 json 数据都可以用它压缩，可以减小 60%以上的体积。前端配置 gzip 压缩，并且服务端使用 nginx 开启 gzip，用来减小网络传输的流量大小。</p>
<p><strong>五、webpack 相关配置优化</strong></p>
<p>（1）使用 uglifyjs-webpack-plugin 插件代替 webpack 自带 UglifyJsPlugin 插件来压缩 JS 文件；生产环境关闭源码映射，一方面能减少代码包的大小，另一方面也有利于系统代码安全；清除打印日志和 debugger 信息；配置 SplitChunks 抽取公有代码，提升你的应用的性能</p>
<p>（2）使用 mini-xss-extract-plugin 提取 CSS 到单独的文件, 并使用 optimize-css-assets-webpack-plugin 来压缩 CSS 文件 。</p>
<p><strong>六、前端页面代码层面的优化</strong></p>
<p>（1）合理使用 v-if 和 v-show</p>
<p>（2）合理使用 watch 和 computed</p>
<p>（3）使用 v-for 必须添加 key, 最好为唯一 id, 避免使用 index, 且在同一个标签上，v-for 不要和 v-if 同时使用</p>
<p>（4）定时器的销毁。可以在 beforeDestroy()生命周期内执行销毁事件；也可以使用$once 这个事件侦听器，在定义定时器事件的位置来清除定时器。详细见 vue 官网</p>
<h2 id="JavaScript-之从原型到原型链"><a href="#JavaScript-之从原型到原型链" class="headerlink" title="JavaScript 之从原型到原型链"></a>JavaScript 之从原型到原型链</h2><ol>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/dzam1RaeZtfLxZvVh4PSrw">https://mp.weixin.qq.com/s/dzam1RaeZtfLxZvVh4PSrw</a></li>
</ol>
<h3 id="React-有哪些特点"><a href="#React-有哪些特点" class="headerlink" title="React 有哪些特点"></a>React 有哪些特点</h3><p>1，有自身的生命周期来判断 dom 是否加载完成，来引入三方 dom library（如 D3）；以及比对下次到来的 state 和 props 来决定是否渲染，提高性能<br>2，不需要经常修改 dom，只需要更改 state 来进行自动更新<br>3，使用 props 来沟通子父组件</p>
<h3 id="React-有哪些局限性"><a href="#React-有哪些局限性" class="headerlink" title="React 有哪些局限性"></a><strong>React 有哪些局限性</strong></h3><p>1，使用 state 来维护每个组件的 dom 变更行为会导致整体软件的可维护性大打折扣，因为需要关心每一个组件的动态，明明想使用同一个 state 的属性，在不同的组件内这个值却是有可能不一样的，大大增加了维护难度<br>2，使用 props 来层层双向传递对象也会增加软件复杂度</p>
<p><strong>React 有哪些优点</strong></p>
<p>1，有自身的生命周期来判断 dom 是否加载完成，来引入三方 dom library（如 D3）；以及比对下次到来的 state 和 props 来决定是否渲染，提高性能<br>2，不需要经常修改 dom，只需要更改 state 来进行自动更新<br>3，使用 props 来沟通子父组件</p>
<h1 id="useMemo-与-useCallback-使用指南"><a href="#useMemo-与-useCallback-使用指南" class="headerlink" title="useMemo 与 useCallback 使用指南"></a>useMemo 与 useCallback 使用指南</h1><p>1.你是如何理解 HTML 5 的语义化?</p>
<ol>
<li>代码结构清晰，易于阅读，利于开发和维护</li>
<li>方便其他设备解析(如屏幕阅读器)根据语义渲染网页。</li>
<li>有利于搜索引擎优化(SEO)，</li>
<li>什么是语义化？<br>HTML5 语义化指的是合理正确的使用语义化的标签来创建页面结构，比如 header、footer、nav，从标签上可以直观的知道这个标签的作用，而不是滥用 div。<br>为什么要语义化？<br>为的就是不仅对自己来说容易阅读，书写，别人看你代码和结构也容易理解。<br>为了在没有 css 代码时，也能呈现很好的内容结构，代码结构。<br>提高用户体验，比如 title，all 用于解释名词和图片信息。<br>便于团队开发和维护，语义化更具有可读性。<br>应该注意什么？<br>尽可能减少使用没有语义的 div 和 span 元素。<br>需要强调的文，可以包含在 strong 或者 em 中。<br>使用表格表头用 thead，主体部分用 tbody 包围，尾部用 tfoot 包围。</li>
</ol>
<p>2.什么是盒子模型?</p>
<ol>
<li><p>把所有的网页元素都看成一个盒子，它具有：</p>
<p>content，padding，border，margin</p>
<p>四个属性，这就是盒子模型。</p>
<p>2.盒子分为是哪两种?</p>
<ol>
<li><p>W3C 盒模型（标准盒模型）</p>
</li>
<li><p>w3c 盒子模型的范围包括 margin、border、padding、content,并且 content 部分不包含其他部分</p>
</li>
<li><p>IE 盒模型（怪异盒模型）</p>
<ol>
<li>IE 盒子模型的范围包括 margin、border、padding、content,和 w3c 盒子模型不同的是，IE 盒子模型的 content 部分包含了 padding 和 border</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>3.说说原型和原型链</p>
<ol>
<li>原型：<ol>
<li>一个可以被克隆的一个类，通过复制原型可以创建一个一模一样的新对象，也可以说原型就是一个模板，在设计语言中更准确的说是一个对象模板</li>
<li>原型是定义了一些公用的属性和方法，利用原型创建出来的新对象实例会共享原型的所有属性和方法</li>
</ol>
</li>
<li>原型链：<ol>
<li>原型链是原型对象创建过程的历史记录，当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的<code>__proto__</code>隐式原型上查找，即它的构造函数的 prototype，如果还没有找到就会再在构造函数的 prototype 的<code>__proto__</code>中查找，这样一层一层向上查找就会形成一个链式结构</li>
</ol>
</li>
</ol>
<p>4.vue 有哪些生命周期钩子函数?分别有什么用</p>
<ol>
<li>VUE 生命周期是 VUE 实例化或者组件创建到消亡的过程。<ol>
<li>beforeCreate 创建前的状态，初始化事件和生命周期。</li>
<li>创建完毕状态 Init (初始化) injections (依赖注入) &amp; reactivity (开始响应)。</li>
<li>beforeMount 挂载前状态， 是否有元素 el，是否有模板，是否渲染到了函数内，是否作为模板进行了 outerHTML 渲染到了页 面，向虚拟 DOM 上挂载的过程，并且还是把我们的‘#app’生成虚拟 DOM，生成完毕后并渲染到 view 层。</li>
<li>mounted 挂载结束状态，渲染到真正的 DOM。</li>
<li>beforeUpdate 可以拿到 Vue 实例化改变前的状态。</li>
<li>Updated 拿到变动完成的状态。</li>
<li>beforeDestroy 消亡前的状态。</li>
<li>destroyed 实例化或组件被摧毁消亡</li>
</ol>
</li>
</ol>
<p>5.如何理解 flex 布局</p>
<ol>
<li><strong>目前的浏览器支持程度：</strong> IE10+，chrome21+，opera12.1+，Firefox22+，safari6.1+等;<br>如上浏览器的支持程度，我们可以把此元素使用在移动端很方便;</li>
<li>flex 布局是一维布局模型。大多属性都是作用于主轴，交叉轴被动变化。<ol>
<li>每个弹性容器都有两根轴：<strong>主轴和交叉轴</strong>，两轴之间成 90 度关系。注意：<strong>水平的不一定就是主轴。</strong></li>
<li>每根轴都有<strong>起点和终点</strong>，这对于元素的对齐非常重要。</li>
<li>弹性容器中的所有子元素称为&lt;弹性元素&gt;，<strong>弹性元素永远沿主轴排列</strong>。</li>
<li>弹性元素也可以通过<code>display:flex</code>设置为另一个弹性容器，形成嵌套关系。因此一个元素既可以是弹性容器也可以是弹性元素。</li>
</ol>
</li>
<li>容器有如下 6 个属性<br>flex-direction<br>flex-wrap<br>flex-flow<br>justify-content<br>align-items<br>align-content</li>
</ol>
<p>6.闭包的原理？优点是什么？缺点是什么？举例说明</p>
<ol>
<li><p>什么是闭包?</p>
<ol>
<li>密闭的容器，类似于 set，map 容器，存储数据的</li>
<li>闭包是一个对象，存放数据的格式： key: value</li>
</ol>
</li>
<li><p>形成的条件：</p>
<ol>
<li>函数嵌套</li>
<li>内部函数引用外部函数的局部变量</li>
</ol>
</li>
<li><p>闭包的优点： 1.延长外部函数局部变量的 生命周期</p>
</li>
<li><p>闭包的缺点： 1.由于闭包会使函数中的变量保存在内存中，内存消耗很大，所以不能滥用闭包，解决办法是，退出函数之前，将不使用的局部变量删除，容易造成内存泄漏</p>
</li>
<li><p>闭包的使用场景</p>
<ol>
<li>setTimeout：<ol>
<li>原生的 setTimeout 传递的第一个函数不能带参数，通过闭包可以实现传参效果。</li>
</ol>
</li>
<li>回调：<ol>
<li>定义行为，然后把它关联到某个用户事件上（点击或者按键）。代码通常会作为一个回调（事件触发时调用的函数）绑定到事件。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>7.递归的原理？优点是什么？缺点是什么？</p>
<ol>
<li><p>递归：递归就是子程序（或函数）直接调用自己或通过一系列调用语句间接调用自己，是一种描述问题和解决问题的基本方法。</p>
</li>
<li><p>递归函数的内部执行过程：</p>
</li>
<li><ol>
<li>一个递归函数的调用过程类似于多个函数的嵌套的调用，只不过调用函数和被调用函数是同一个函数。为了保证递归函数的正确执行，<strong>系统需设立一个工作栈</strong>。具体地说，递归调用的内部执行过程如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.运动开始时，首先为递归调用建立一个工作栈，其结构包括值参、局部变量和返回地址；</span><br><span class="line">2.每次执行递归调用之前，把递归函数的值参和局部变量的当前值以及调用后的返回地址压栈；</span><br><span class="line">3.每次递归调用结束后，将栈顶元素出栈，使相应的值参和局部变量恢复为调用前的值，</span><br><span class="line">然后转向返回地址指定的位置继续执行。</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点：</p>
<ol>
<li>代码简洁</li>
<li>符合思维习惯，容易理解</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>效率较低</li>
<li>递归层次太深，耗内存且容易栈溢出一定要使用的话，最好使用缓存避免相同的计算，限制递归调用的次数</li>
</ol>
</li>
</ol>
<p>8.&#x3D;&#x3D; 和&#x3D;&#x3D;&#x3D;的区别即如何比较两个对象？</p>
<ol>
<li>双等号&#x3D;&#x3D;：<ol>
<li>如果两个值类型相同，再进行三个等号(&#x3D;&#x3D;&#x3D;)的比较</li>
<li>如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较：<ol>
<li>如果一个是 null，一个是 undefined，那么相等</li>
<li>如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较</li>
</ol>
</li>
</ol>
</li>
<li>三等号&#x3D;&#x3D;&#x3D;:<ol>
<li>如果类型不同，就一定不相等</li>
<li>如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是 NaN，那么不相等。（判断一个值是否是 NaN，只能使用 isNaN( ) 来判断）</li>
<li>如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。</li>
<li>如果两个值都是 true，或是 false，那么相等</li>
<li>如果两个值都引用同一个对象或是函数，那么相等，否则不相等</li>
<li>如果两个值都是 null，或是 undefined，那么相等</li>
</ol>
</li>
</ol>
<p>9.null 和 undefined 的区别</p>
<ol>
<li><p>Null：</p>
<p>null 是 js 中的关键字，表示空值，null 可以看作是 object 的一个特殊的值，如果一个 object 值为空，表示这个对象不是有效对象。</p>
<p>Undefined:</p>
<p>undefined 不是 js 中的关键字，其是一个全局变量，是 Global 的一个属性，以下情况会返回 undefined:</p>
<ol>
<li><p>使用了一个未定义的变量；var i;</p>
<p>2.使用了已定义但未声明的变量；</p>
<p>3.使用了一个对象属性，但该属性不存在或者未赋值；</p>
<p>4.调用函数时，该提供的参数没有提供：</p>
<p>function func(a){<br>console.log(a);<br>}<br>func();&#x2F;&#x2F;undefined 5.函数没有返回值时，默认返回 undefined</p>
<p>var aa&#x3D;func();<br>aa;&#x2F;&#x2F;undefined<br>相同点：</p>
<p>都是原始类型的值，保存在栈中变量本地</p>
<p>两者的区别：</p>
</li>
</ol>
<p>2.类型不一样：</p>
<p>console.log(typeOf undefined);&#x2F;&#x2F;undefined</p>
<p>console.log(typeOf null);&#x2F;&#x2F;object</p>
</li>
</ol>
<p>3.转化为值时不一样：undefined 为 NaN ,null 为 0</p>
<p>console.log(Number(undefined));&#x2F;&#x2F;NaN<br>console.log(Number(10+undefined));&#x2F;&#x2F;NaN</p>
<p>console.log(Number(null));&#x2F;&#x2F;0<br>console.log(Number(10+null));&#x2F;&#x2F;10<br>4.undefined&#x3D;&#x3D;&#x3D;null;&#x2F;&#x2F;false</p>
<p>undefined&#x3D;&#x3D;null;&#x2F;&#x2F;true</p>
<p>何时使用：</p>
<p>null 当使用完一个比较大的对象时，需要对其进行释放内存时，设置为 null;</p>
<p>var arr&#x3D;[“aa”,”bb”,”cc”];<br>arr&#x3D;null;&#x2F;&#x2F;释放指向数组的引用</p>
<ol start="10">
<li>JavaScript 的数据类型有几种分别是什么？<ol>
<li>JavaScript 数据类型：</li>
</ol>
</li>
</ol>
<p>值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。</p>
<p>引用数据类型：对象(Object)、数组(Array)、函数(Function)。</p>
<p>注：Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。</p>
<ol start="11">
<li><p>promise 的理解是什么？</p>
<ol>
<li>Promise 是一个构造函数，可以通过 new Promise()得到一个 Promise 的实例；</li>
<li>在 Promise 上，有两个函数，分别叫做 resolve（成功之后的回调函数） 和 reject（失败之后的回调函数）</li>
<li>在 Promise 构造函数的 Prototype 属性上，有一个 .then() 方法，也就说，只要是 Promise 构造函数创建的实例，都可以访问到这个 .then() 方法 ；</li>
<li>Promise 表示一个 异步操作；每当我们 new 一个 Promise 的实例，这个实例，就表示一个具体的异步操作；</li>
<li>既然 Promise 创建的实例，是一个异步操作，那么，这个 异步操作的结果，只能有两种状态：</li>
<li>状态 1： 异步执行成功了，需要在内部调用 成功的回调函数 resolve 把结果返回给调用者；</li>
<li>状态 2： 异步执行失败了，需要在内部调用 失败的回调函数 reject 把结果返回给调用者；</li>
</ol>
</li>
<li><p>如何理解块作用域变量</p>
</li>
<li><p>全局变量：</p>
<pre><code> 1. 其他任何位置使用var声明的的变量,函数除外，那么这个变量就是全局变量,全局变量可以在页面的任何位置使用。
</code></pre>
</li>
<li><p>全局变量： 1. 如果页面不关闭，那么变量所占用的内存就不会释放，就会占空间,消耗内存。</p>
</li>
<li><p>局部变量： 1. 在函数内部定义的变量,是局部变量,外面不能使用 。</p>
</li>
<li><p>块级作用域 1. 块级作用域：一对大括号就可以看成是一块，在这块区域中定义的变量，只能在这个区域中使用，但是在 js 中在这个块级作用域中定义的变量，外面也能使用。</p>
<pre><code>说明：js没有块级作用域,，只有函数除外
</code></pre>
<ol start="2">
<li><p>隐式全局变量</p>
<ol>
<li>隐式全局变量：声明的变量没有 var,就叫隐式全局变量。</li>
</ol>
</li>
<li><p>注意：</p>
<ol>
<li>全局变量是不能被删除的，隐式全局变量是可以被删除的</li>
<li>定义变量使用 var 是不会被删除的，没有 var 是可以删除的</li>
<li>定义变量的时候尽量都使用 var</li>
</ol>
</li>
</ol>
</li>
<li><p>数组去重（几种方式）</p>
<ol>
<li><p>利用 ES6 Set 去重（ES6 中最常用）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="title class_">NaN</span>,</span><br><span class="line">  <span class="title class_">NaN</span>,</span><br><span class="line">  <span class="string">&#x27;NaN&#x27;</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">unique</span>(arr))</span><br><span class="line"><span class="comment">//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;&#125;, &#123;&#125;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 for 嵌套 for，然后 splice 去重（ES5 中最常用）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] == arr[j]) &#123;</span><br><span class="line">        <span class="comment">//第一个等同于第二个，splice方法删除第二个</span></span><br><span class="line">        arr.<span class="title function_">splice</span>(j, <span class="number">1</span>)</span><br><span class="line">        j--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="title class_">NaN</span>,</span><br><span class="line">  <span class="title class_">NaN</span>,</span><br><span class="line">  <span class="string">&#x27;NaN&#x27;</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">unique</span>(arr))</span><br><span class="line"><span class="comment">//[1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line"><span class="comment">//NaN和&#123;&#125;没有去重，两个null直接消失了</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 indexOf 去重</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">unique</span><span class="params">(arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(<span class="string">&#x27;type error!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">var</span> <span class="variable">array</span> <span class="operator">=</span> [];<span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array .indexOf(arr[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">            array .push(arr[i])&#125;&#125;<span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, undefined,undefined, <span class="literal">null</span>,<span class="literal">null</span>, NaN, NaN,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];console.log(unique(arr))</span><br><span class="line">    <span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line">    <span class="comment">//NaN、&#123;&#125;没有去重</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 sort</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;type error!&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  arr = arr.<span class="title function_">sort</span>()</span><br><span class="line">  <span class="keyword">var</span> arrry = [arr[<span class="number">0</span>]]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] !== arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      arrry.<span class="title function_">push</span>(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arrry</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="title class_">NaN</span>,</span><br><span class="line">  <span class="title class_">NaN</span>,</span><br><span class="line">  <span class="string">&#x27;NaN&#x27;</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">unique</span>(arr))</span><br><span class="line"><span class="comment">// [0, 1, 15, &quot;NaN&quot;, NaN, NaN, &#123;…&#125;, &#123;…&#125;, &quot;a&quot;, false, null, true, &quot;true&quot;, undefined]</span></span><br><span class="line"><span class="comment">//NaN、&#123;&#125;没有去重</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;<span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;type error!&#x27;</span>)<span class="keyword">return</span>&#125;<span class="keyword">var</span> arrry= [];<span class="keyword">var</span> obj = &#123;&#125;;<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;<span class="keyword">if</span> (!obj[arr[i]]) &#123;arrry.<span class="title function_">push</span>(arr[i])obj[arr[i]] = <span class="number">1</span>&#125; <span class="keyword">else</span> &#123;obj[arr[i]]++&#125;&#125;<span class="keyword">return</span> arrry;&#125;<span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="title class_">NaN</span>, <span class="title class_">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">unique</span>(arr))<span class="comment">//[1, &quot;true&quot;, 15, false, undefined, null, NaN, 0, &quot;a&quot;, &#123;…&#125;] //两个true直接去掉了，NaN和&#123;&#125;去重</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 includes</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">unique</span><span class="params">(arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(<span class="string">&#x27;type error!&#x27;</span>)<span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">var</span> <span class="variable">array</span> <span class="operator">=</span>[];<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>( !array.includes( arr[i]) ) &#123;</span><br><span class="line">            <span class="comment">//includes 检测数组是否有某个值array.push(arr[i]);&#125;&#125;return array&#125;</span></span><br><span class="line">            <span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, undefined,undefined, <span class="literal">null</span>,<span class="literal">null</span>, NaN, NaN,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];console.log(unique(arr))</span><br><span class="line">                <span class="comment">//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line">                <span class="comment">//&#123;&#125;没有去重</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 hasOwnProperty</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">unique</span><span class="params">(arr)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">obj</span> <span class="operator">=</span> &#123;&#125;;<span class="keyword">return</span> arr.filter(function(item, index, arr)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj.hasOwnProperty(typeof item + item) ? <span class="literal">false</span> : (obj[typeof item + item] = <span class="literal">true</span>)&#125;)&#125;</span><br><span class="line"><span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, undefined,undefined, <span class="literal">null</span>,<span class="literal">null</span>, NaN, NaN,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];console.log(unique(arr))</span><br><span class="line">    <span class="comment">//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;]</span></span><br><span class="line">    <span class="comment">//所有的都去重了</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 filter</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">item, index, arr</span>) &#123;</span><br><span class="line">        <span class="comment">//当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素return arr.indexOf(item, 0) === index;&#125;);&#125;</span></span><br><span class="line">        <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="title class_">NaN</span>, <span class="title class_">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">unique</span>(arr))</span><br><span class="line">        <span class="comment">//[1, &quot;true&quot;, true, 15, false, undefined, null, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用递归去重</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;<span class="keyword">var</span> array= arr;<span class="keyword">var</span> len = array.<span class="property">length</span>;array.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123; <span class="comment">//排序后更加方便去重return a - b;&#125;)function loop(index)&#123;if(index &gt;= 1)&#123;if(array[index] === array[index-1])&#123;array.splice(index,1);&#125;loop(index - 1); //递归loop，然后数组去重&#125;&#125;loop(len-1);return array;&#125;var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];console.log(unique(arr))//[1, &quot;a&quot;, &quot;true&quot;, true, 15, false, 1, &#123;…&#125;, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, undefined]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 Map 数据结构去重</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arrayNonRepeatfy</span>(<span class="params">arr</span>) &#123;<span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();<span class="keyword">let</span> array = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">// 数组用于返回结果for (let i = 0; i &lt; arr.length; i++) &#123;if(map .has(arr[i])) &#123; // 如果有该key值map .set(arr[i], true);&#125; else &#123;map .set(arr[i], false); // 如果没有该key值array .push(arr[i]);&#125;&#125;return array ;&#125;var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];console.log(unique(arr))//[1, &quot;a&quot;, &quot;true&quot;, true, 15, false, 1, &#123;…&#125;, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, undefined]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 reduce+includes</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(</span><br><span class="line">    <span class="function">(<span class="params">prev, cur</span>) =&gt;</span> (prev.<span class="title function_">includes</span>(cur) ? prev : [...prev, cur]),</span><br><span class="line">    []</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="title class_">NaN</span>,</span><br><span class="line">  <span class="title class_">NaN</span>,</span><br><span class="line">  <span class="string">&#x27;NaN&#x27;</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">unique</span>(arr)) <span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>[…new Set(arr)]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;[...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)] <span class="comment">//代码就是这么少----（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码）</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>宏任务，微任务及其区别</p>
<ol>
<li>宏任务<ol>
<li>宏任务被放在在 callback queue 中，由事件触发线程维护；微任务被放在微任务队列中，由 js 引擎线程维护</li>
<li>当前调用栈中执行的任务，称为宏任务</li>
</ol>
</li>
<li>一次循环中的宏任务执行完成后，下一个宏任务执行之前，执行微任务，可以当做是回调函数</li>
</ol>
</li>
<li><p>深拷贝和浅拷贝？如何实现深浅拷贝的转换？</p>
<ol>
<li>深拷贝：对于浅拷贝来说，如果拷贝基本类型，那么就等于赋值一样，会直接拷贝其本身；但如果拷贝的是引用类型，就只会拷贝一层，如果 原对象发生改变，那么拷贝对象也会发生改变<ol>
<li>ES6 的 Object.assign()方法</li>
<li>将对象转成字符串再转换回来</li>
<li>递归方法实现深拷贝</li>
<li>jQuery.extend()</li>
<li>函数递归调用</li>
</ol>
</li>
<li>浅拷贝<ol>
<li>自定义函数</li>
<li>ES6 Object.assign() &#x2F;&#x2F; 多层是浅拷贝 一层是深拷贝</li>
<li>ES6 扩展运算符</li>
<li>jQuery.extend()</li>
<li>数组方法（只适用于类数组对象） Array.from()</li>
</ol>
</li>
</ol>
</li>
<li><p>JS 的继承？有几种继承</p>
<ol>
<li><h3 id="借助构造函数实现继承"><a href="#借助构造函数实现继承" class="headerlink" title="借助构造函数实现继承"></a>借助构造函数实现继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">saiHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age, gender</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">gender</span> = gender</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;王磊&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">name</span>) <span class="comment">// 王磊</span></span><br><span class="line">child.<span class="title function_">sayHi</span>() <span class="comment">// Uncaught TypeError:child.sayHi is not a function</span></span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="借助原型链实现继承"><a href="#借助原型链实现继承" class="headerlink" title="借助原型链实现继承"></a>借助原型链实现继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name, gender</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">gender</span> = gender</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;晚餐时间到&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>(<span class="string">&#x27;李白&#x27;</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="number">20</span>)</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="number">30</span>)</span><br><span class="line">child.<span class="title function_">eat</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">list</span>, child2.<span class="property">list</span>) <span class="comment">// [1,2,3] [1,2,3]</span></span><br><span class="line">child.<span class="property">list</span>.<span class="title function_">push</span>(<span class="number">4</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">list</span>) <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">list</span>) <span class="comment">// [1,2,3,4]</span></span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="组合型"><a href="#组合型" class="headerlink" title="组合型"></a>组合型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">school</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">school</span> = school</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">skill</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;学习&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">school, name, age, gender</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, school)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">gender</span> = gender</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="keyword">let</span> student = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;广铁一中&#x27;</span>, <span class="string">&#x27;王菲菲&#x27;</span>, <span class="number">14</span>, <span class="string">&#x27;女&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(student.<span class="property">constructor</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="组合方式优化"><a href="#组合方式优化" class="headerlink" title="组合方式优化"></a>组合方式优化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name, play</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">play</span> = play</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, play, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, play)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;玩&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">let</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;吃&#x27;</span>, <span class="number">10</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child, child2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property"><span class="keyword">prototype</span></span> === child2.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">constructor</span>) <span class="comment">// 构造函数指向的是Parent</span></span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="组方式优化"><a href="#组方式优化" class="headerlink" title="组方式优化"></a>组方式优化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name, play</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">play</span> = play</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, play, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, play)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// 隔离了父类和子类的构造函数,父类的添加到了__proto__属性上</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span></span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;玩&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">let</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;吃&#x27;</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">constructor</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h1 id="react-中的-setState-是同步还是异步"><a href="#react-中的-setState-是同步还是异步" class="headerlink" title="react 中的 setState 是同步还是异步"></a>react 中的 setState 是同步还是异步</h1><ol>
<li>setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。<ul>
<li>合成事件：就是 react 在组件中的 onClick 等都是属于它自定义的合成事件</li>
<li>原生事件：比如通过 addeventListener 添加的，dom 中的原生事件</li>
</ul>
</li>
<li>setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的 callback 拿到更新后的结果。</li>
<li>setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新</li>
</ol>
</li>
<li><p>Js 常用的函数</p>
<ol>
<li>javascript 常规函数包括以下 9 个函数：<ol>
<li>alert 函数：显示一个警告对话框，包括一个 OK 按钮。</li>
<li>confirm 函数：显示一个确认对话框，包括 OK、Cancel 按钮。</li>
<li>scape 函数：将字符转换成 Unicode 码。</li>
<li>eval 函数：计算表达式的结果。</li>
<li>isNaN 函数：测试是(true)否(false)不是一个数字。</li>
<li>parseFloat 函数：将字符串转换成符点数字形式。</li>
<li>parseInt 函数：将符串转换成整数数字形式(可指定几进制)。</li>
<li>prompt 函数：显示一个输入对话框，提示等待用户输入。例如：</li>
<li>unescape 函数：解码由 escape 函数编码的字符。</li>
</ol>
</li>
</ol>
</li>
<li><p>跨域的产生</p>
</li>
<li><p>浏览器的同源策略是浏览器上为安全性考虑实施的非常重要的安全策略。</p>
<p>从一个域上加载的脚本不允许访问另外一个域的文档属性。</p>
<p>举个例子：比如一个恶意网站的页面通过 iframe 嵌入了银行的登录页面（二者不同源），</p>
<p>如果没有同源限制，恶意网页上的 javascript 脚本就可以在用户登录银行的时候获取用户名和密码。</p>
<p>何谓同源:URL 由协议、域名、端口和路径组成，如果两个 URL 的协议、域名和端口相同，则表示它们同源。</p>
<p>在浏览器中，<script>、<img>、<iframe>、<link>等标签都可以加载跨域资源，而不受同源限制，</p>
<p>但浏览器会限制脚本中发起的跨域请求。比如，使用 XMLHttpRequest 对象和 Fetch 发起 HTTP 请求就必须遵守同源策略。</p>
<p>Web 应用程序通过 XMLHttpRequest 对象或 Fetch 能且只能向同域名的资源发起 HTTP 请求，而不能向任何其它域名发起请求。</p>
<p>不允许跨域访问并非是浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但是返回结果被浏览器拦截了。</p>
<p>最好的例子是 CSRF 跨站攻击原理，请求是发送到了后端服务器,无论是否设置允许跨域,</p>
<p>有些浏览器不允许从 HTTPS 跨域访问 HTTP，比如 Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求,这是特例。</p>
</li>
<li><p>浏览器的同源策略是浏览器上为安全性考虑实施的非常重要的安全策略。</p>
<p>从一个域上加载的脚本不允许访问另外一个域的文档属性。</p>
<p>举个例子：比如一个恶意网站的页面通过 iframe 嵌入了银行的登录页面（二者不同源），</p>
<p>如果没有同源限制，恶意网页上的 javascript 脚本就可以在用户登录银行的时候获取用户名和密码。</p>
<p>何谓同源:URL 由协议、域名、端口和路径组成，如果两个 URL 的协议、域名和端口相同，则表示它们同源。</p>
<p>在浏览器中，<script>、<img>、<iframe>、<link>等标签都可以加载跨域资源，而不受同源限制，</p>
<p>但浏览器会限制脚本中发起的跨域请求。比如，使用 XMLHttpRequest 对象和 Fetch 发起 HTTP 请求就必须遵守同源策略。</p>
<p>Web 应用程序通过 XMLHttpRequest 对象或 Fetch 能且只能向同域名的资源发起 HTTP 请求，而不能向任何其它域名发起请求。</p>
<p>不允许跨域访问并非是浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但是返回结果被浏览器拦截了。</p>
<p>最好的例子是 CSRF 跨站攻击原理，请求是发送到了后端服务器,无论是否设置允许跨域,</p>
<p>有些浏览器不允许从 HTTPS 跨域访问 HTTP，比如 Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求,这是特例</p>
</li>
<li><p>如何解决跨域</p>
<ol>
<li><p>如何解决跨域问题？首先我们需要知道什么是跨域，跨域指的是浏览器不能执行其它网站的脚本，它是由浏览器的同源策略造成的，是浏览器对 JavaScript 施加的安全限制。</p>
<ol>
<li><h4 id="response-添加-header"><a href="#response-添加-header" class="headerlink" title="response 添加 header"></a>response 添加 header</h4></li>
<li><h4 id="JSONP-方式"><a href="#JSONP-方式" class="headerlink" title="JSONP 方式"></a>JSONP 方式</h4><ol>
<li>在同源策略下，在某个服务器下的页面是无法获取到该服务器以外的数据的，即一般的 ajax 是不能进行跨域请求的。但 img、iframe 、script 等标签是个例外，这些标签可以通过 src 属性请求到其他服务器上的数据。利用 script 标签的开放策略，我们可以实现跨域请求数据，当然这需要服务器端的配合。 Jquery 中 ajax 的核心是通过 XmlHttpRequest 获取非本页内容，而 jsonp 的核心则是动态添加 <script>标签来调用服务器提供的 js 脚本。</li>
<li>当我们正常地请求一个 JSON 数据的时候，服务端返回的是一串 JSON 类型的数据，而我们使用 JSONP 模式来请求数据的时候服务端返回的是一段可执行的 JavaScript 代码。因为 jsonp 跨域的原理就是用的动态加载 script 的 src ，所以我们只能把参数通过 url 的方式传递,所以 jsonp 的 type 类型只能是 get ！</li>
</ol>
</li>
<li><h4 id="HttpClient-请求转发"><a href="#HttpClient-请求转发" class="headerlink" title="HttpClient 请求转发"></a>HttpClient 请求转发</h4><ol>
<li>这种方式客户端是向 JavaWeb02 项目发送请求，而不是上面的向 JavaWeb01 发送请求，然后在 JavaWeb02 的后台通过 HttpClient 将请求发送到 JavaWeb01，得到数据后返回。这种方式相当于绕过浏览器的同源机制，直接通过后端进行转发。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>什么是同源策略</p>
<ol>
<li><h6 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h6><ol>
<li>所谓同源策略，指的是浏览器对不同源的脚本或者文本的访问方式进行的限制。比如源 a 的 js 不能读取或设置引入的源 b 的元素属性。那么先定义下什么是同源，所谓同源，就是指两个页面具有相同的协议，主机（也常说域名），端口，三个要素缺一不可。</li>
</ol>
</li>
</ol>
</li>
<li><p>介绍一下 hooks</p>
</li>
<li><p>高阶组件</p>
<ol>
<li><p>高阶组件（HOC）是一个将组件作为参数并返回一个新组件的函数。他是一种由 React 自身组合性质产生的模式。由于高阶组件接受他的组件参数来动态创建子组件，且不会修改或复制其组件中的任何行为，因此他与纯组件较为类似。</p>
<ol>
<li><p>高阶组件可以用来作为状态的抽象和管理、属性的管理、组件的渲染等。</p>
<p>由于 Mixins 产生的问题比其带来的价值要大的多，因此我们要么避免过早的抽象，要么可以使用高阶组件。</p>
<p>不要在 render 方法内使用高阶组件，否则每一次渲染都会创建一个新的组件，并引起该组件的卸载和渲染。</p>
<p>高阶组件返回的新组件中将没有参数组件中的任何静态方法。因此需要对静态方法进行拷贝(可使用 <a target="_blank" rel="noopener" href="https://link.ld246.com/forward?goto=https://github.com/mridgway/hoist-non-react-statics">hoist-non-react-statics</a> ）或分别导出组件自身的静态方法。</p>
<p>在高阶组件中由于 refs 属性不能贯穿传递，但可以使用 <code>React.forwardRef</code> 来替代。</p>
<p>在高阶组件内，应避免对组件做任何修改。应使用组合技术，将输入的组件包裹到一个容器组件中。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>重绘和回流的区别和关系</p>
<ol>
<li><p>重绘：当渲染树中的元素外观发生改变，不影响布局时，产生重绘</p>
</li>
<li><p>回流：当渲染树中的元素布局发生改变是产生重绘回流</p>
<ol>
<li>注意：JS 获取 Layout 属性值也会引起回流，因为浏览器需要通过回流计算最新值回流必将引起重绘，而重绘不一定会引起回流</li>
</ol>
</li>
<li><p>如何最小重绘和回流</p>
<ol>
<li>需要对元素进行复杂的操作是，可以先隐藏，操作完成后在显示，</li>
<li>需要创建多个 DOM 节点时，使用 DocumentFragment 创建完成后一次性的加入 document 缓存 Layout 属性值，如 var left=elem.offsetLeft，这样，多次使用 left 只产生一次回流</li>
<li>尽量避免用 table 布局，（table 元素一旦触发回流就会导致 table 里所有的其他元素回流）</li>
<li>避免使用 css 表达式属性简写，</li>
</ol>
</li>
</ol>
</li>
<li><h1 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h1><ol>
<li>它是可以理解为 promise 的语法糖,</li>
<li>async 用于申明一个 function 是异步的，</li>
<li>await 可以认为是 async await 的简写，等待一个异步方法执行完成。</li>
<li>async/await 使得异步代码看起来像同步代码，明显节约了不少代码，大大地提高可读性</li>
<li>async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完 成，并将其 resolve 的结果返回出来。</li>
</ol>
</li>
<li><p>es6 中 map 和 set 的区别</p>
<ol>
<li>Map 中存储的是 key-value 形式的键值对, 其中的 key 和 value 可以是任何类型的, 即对象也可以作为 key . 这比用对象来模拟的方式就灵活了很多</li>
<li>Map 可用的方法</li>
<li>set(key, value): 向其中加入一个键值对</li>
<li>get(key): 若不存在 key 则返回 undefifined</li>
<li>has(key):返回布尔值</li>
<li>delete(key): 删除成功则返回 true, 若 key 不存在或者删除失败会返回 false</li>
<li>clear(): 将全部元素清除 、</li>
<li>Set 和 Map 最大的区别是只有键 key 而没有 value, 所以一般用来判断某个元素(key)是否存在于其中.</li>
</ol>
</li>
</ol>
<p>我对上家领导的看法：<br>我们领导工作认真负责，有责任心,做事特别细致，但是可能是太过于细致了对我们的要求非常高，感谢他的带领，在他的带领下我成长了不少，但是确实压力也挺大的，<br>年龄不符：<br>当时晚上了几年户口，父母不太在意这些事情，再加上农村查的不严，就晚上了几年户口<br>跳槽看法：<br>我个人频繁跳槽不太好但是偶尔可以增加薪资，在技术方面也会有提升<br>在公司的话可以给新公司添加新鲜血液，如果一直都是老员工的话气氛不会太活跃<br>离职原因：<br>因为当时家里有点比较重要的事情<br>那为什么在年底找工作<br>因为身上担负着房贷和车贷迫于经济压力本来打算年后找工作，但是没办法想着先碰碰运气看看年前能不能找到，如果找不到就年后再找</p>
<p>性能维护： 1.前后端解藕 2.集中开发页面通用组件<br>a.具体的业务逻辑方面多用函数式编程<br>b.页面 UI 方面多用对象化编程<br>map 和 weakmap 区别：</p>
<pre><code>         1. Set
              1. ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。
              2. Set本身是一个构造函数，用来生成 Set 数据结构。
              3. 成员唯一、无序且不重复；
              4. [value, value]，键值与键名是一致的（或者说只有键值，没有键名）；可以遍历，方法有：add、delete、has。
</code></pre>
<p>2.WeakSet</p>
<p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>
<p>成员都是对象；</p>
<p>成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏；</p>
<p>不能遍历，方法有 add、delete、has。</p>
<p>3.Map</p>
<p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<p>可以遍历，方法很多，可以跟各种数据格式转换。</p>
<p>4.WeakMap</p>
<p>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。</p>
<p>只接受对象最为键名（null 除外），不接受其他类型的值作为键名；</p>
<p>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的；</p>
<p>不能遍历，方法有 get、set、has、delete。</p>
<ol start="5">
<li><p>axios 二次封装</p>
<ol>
<li>api 统一管理,不管接口有多少,所有的接口都可以非常清晰,容易维护.</li>
<li>通常我们的项目会越做越大,页面也会越来越多,如果页面非常的少,直接用 axios 也没有什么大的影响,那页面组件多了起来,上百个接口呢,这个时候后端改了接口,多加了一个参数什么的呢?那就只有找到那个页面,进去修改.整个过程很繁琐不易于项目的维护和迭代</li>
<li>这个时候如果我们统一的区管理接口,需要修改某一个接口的时候直接在 api 里修改对应的请求是不是很方便呢?因为我们用的最多的还是 get post 请求.我们就可以针对封装.</li>
</ol>
</li>
<li><p>axios 和 fetch</p>
<ol>
<li>axios 是一个基于 Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生 XHR 的封装，只不过它是 Promise 的实现版本，符合最新的 ES 规范，它本身具有以下特征：<ol>
<li>从浏览器中创建 XMLHttpRequest</li>
<li>支持 Promise API</li>
<li>客户端支持防止 CSRF</li>
<li>提供了一些并发请求的接口（重要，方便了很多的操作）</li>
<li>从 node.js 创建 http 请求</li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>取消请求</li>
<li>自动转换 JSON 数据</li>
</ol>
</li>
<li>fetch 优势：<ol>
<li>语法简洁，更加语义化</li>
<li>基于标准 Promise 实现，支持 async/await</li>
<li>同构方便，使用 <a target="_blank" rel="noopener" href="https://github.com/matthew-andrews/isomorphic-fetch">isomorphic-fetch</a></li>
<li>更加底层，提供的 API 丰富（request, response）</li>
<li>脱离了 XHR，是 ES 规范里新的实现方式</li>
</ol>
</li>
<li>fetch 存在问题<br>fetch 是一个低层次的 API，你可以把它考虑成原生的 XHR，所以使用起来并不是那么舒服，需要进行封装。<ol>
<li>fetch 只对网络请求报错，对 400，500 都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li>
<li>fetch 默认不会带 cookie，需要添加配置项： fetch(url, {credentials: 'include'})</li>
<li>fetch 不支持 abort，不支持超时控制，使用 setTimeout 及 Promise.reject 的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</li>
<li>fetch 没有办法原生监测请求的进度，而 XHR 可以</li>
</ol>
</li>
</ol>
</li>
<li><p>路由懒加载如何实现</p>
<ol>
<li><p><strong>import()</strong></p>
<p>符合 ECMAScript 提议的 import()语法，该提案与普通 import 语句或 require 函数的类似，但返回一个 Promise 对象。这意味着模块时异步加载的；webpack v2+ 使用</p>
</li>
<li><p><strong>require.ensure</strong></p>
<ol>
<li>webpack 指定的使用方式</li>
<li>webpack v1 v2 指定使用方式</li>
</ol>
</li>
<li><p><strong>lazyload-loader</strong></p>
</li>
</ol>
<p>6.闭包的原理？优点是什么？缺点是什么？举例说明</p>
</li>
<li><p>什么是闭包?</p>
<ol>
<li>密闭的容器，类似于 set，map 容器，存储数据的</li>
<li>闭包是一个对象，存放数据的格式： key: value</li>
</ol>
</li>
<li><p>形成的条件：</p>
<ol>
<li>函数嵌套</li>
<li>内部函数引用外部函数的局部变量</li>
</ol>
</li>
<li><p>闭包的优点： 1.延长外部函数局部变量的 生命周期</p>
</li>
<li><p>闭包的缺点： 1.由于闭包会使函数中的变量保存在内存中，内存消耗很大，所以不能滥用闭包，解决办法是，退出函数之前，将不使用的局部变量删除，容易造成内存泄漏</p>
</li>
<li><p>闭包的使用场景</p>
<ol>
<li>setTimeout：<ol>
<li>原生的 setTimeout 传递的第一个函数不能带参数，通过闭包可以实现传参效果。</li>
</ol>
</li>
<li>回调：<ol>
<li>定义行为，然后把它关联到某个用户事件上（点击或者按键）。代码通常会作为一个回调（事件触发时调用的函数）绑定到事件。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="1-手写深拷贝"><a href="#1-手写深拷贝" class="headerlink" title="1.手写深拷贝"></a>1.手写深拷贝</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">copyObj</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> cloneObj</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    cloneObj = obj</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    cloneObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj[key] &amp;&amp; <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">          cloneObj[key] = <span class="title function_">copyObj</span>(obj[key])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          cloneObj[key] = obj[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.如何用 class 继承</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">eat</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> eat something...`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="comment">// [extends] (ES6)关键字用来创建一个普通类或者内建对象的子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">People</span> &#123;</span><br><span class="line">  <span class="comment">//constructor 属性返回对创建此对象的数组函数的引用。</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, number</span>) &#123;</span><br><span class="line">    <span class="comment">//[super](ES6)关键字用于访问和调用一个对象的父对象上的函数。</span></span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">number</span> = number</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`姓名 <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> ，学号 <span class="subst">$&#123;<span class="variable language_">this</span>.number&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_ inherited__">People</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, major</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">major</span> = major</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">teach</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> 教授 <span class="subst">$&#123;<span class="variable language_">this</span>.major&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过类声明对象/实例</span></span><br><span class="line"><span class="keyword">const</span> xialuo = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;夏洛&#x27;</span>, <span class="number">100</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xialuo.<span class="property">name</span>) <span class="comment">//夏洛</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xialuo.<span class="property">number</span>) <span class="comment">//100</span></span><br><span class="line">xialuo.<span class="title function_">sayHi</span>() <span class="comment">//姓名 夏洛 ，学号 100</span></span><br><span class="line">xialuo.<span class="title function_">eat</span>() <span class="comment">//夏洛 eat something...</span></span><br><span class="line"><span class="comment">// //通过类声明对象/实例</span></span><br><span class="line"><span class="keyword">const</span> wang = <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&#x27;王老师&#x27;</span>, <span class="string">&#x27;语文&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(wang.<span class="property">name</span>) <span class="comment">//王老师</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(wang.<span class="property">major</span>) <span class="comment">//语文</span></span><br><span class="line">wang.<span class="title function_">teach</span>() <span class="comment">//王老师 教授 语文</span></span><br><span class="line">wang.<span class="title function_">eat</span>() <span class="comment">//王老师 eat something...</span></span><br></pre></td></tr></table></figure>

<h1 id="如何理解-js-原型"><a href="#如何理解-js-原型" class="headerlink" title="如何理解 js 原型"></a>如何理解 js 原型</h1><p>prototype:是一个函数的属性，每个函数中都会有一个 prototype 属性，这个属性是一个指针，指向一个对象。</p>
<h2 id="let-和-const-的区别"><a href="#let-和-const-的区别" class="headerlink" title="let 和 const 的区别"></a>let 和 const 的区别</h2><ol>
<li>let 与 const 都是只在声明所在的块级作用域内有效。</li>
<li>let 声明的变量可以改变，值和类型都可以改变，没有限制。</li>
<li><code>const</code>声明的变量不得改变值，这意味着，const 一旦声明变量，就必须立即初始化，不能留到以后赋值。</li>
</ol>
<h1 id="DOM-和-BOM-的区别"><a href="#DOM-和-BOM-的区别" class="headerlink" title="DOM 和 BOM 的区别"></a>DOM 和 BOM 的区别</h1><p>DOM 是为了操作文档出现的 API，document 是其的一个对象；</p>
<p>BOM 是浏览器对象模型，</p>
<p>DOM 是文档对象模型，</p>
<p>BOM 是为了操作浏览器出现的 API，window 是其的一个对象。</p>
<p>前者是对浏览器本身进行操作</p>
<p>，而后者是对浏览器（可看成容器）内的内容进行操作</p>
<h1 id="函数组件和类组件的区别"><a href="#函数组件和类组件的区别" class="headerlink" title="函数组件和类组件的区别"></a>函数组件和类组件的区别</h1><ol>
<li>使用 class 创建的组件，有自己的私有数据（this.state）和生命周期</li>
<li>使用 function 创建的组件，只有 props，没有自己的私有数据和生命周期函数。</li>
<li>用构造函数创建的组件叫无状态组件，用 class 创建的组件叫有状态组件</li>
<li>组件中的 props 和 state/data 之间的区别<ul>
<li>props 的数据都是从外界传递过来的</li>
<li>state/data 中的数据，都是组件私有的；（通过 ajax 获取的数据一般都是私有数据）</li>
<li>props 中的数据都是只读的，不能重新赋值的。</li>
<li>state/data 中的数据，都是可读可写的。</li>
</ul>
</li>
</ol>
<h1 id="说说原型和原型链"><a href="#说说原型和原型链" class="headerlink" title="说说原型和原型链"></a>说说原型和原型链</h1><ol>
<li>原型：<ol>
<li>一个可以被克隆的一个类，通过复制原型可以创建一个一模一样的新对象，也可以说原型就是一个模板，在设计语言中更准确的说是一个对象模板</li>
<li>原型是定义了一些公用的属性和方法，利用原型创建出来的新对象实例会共享原型的所有属性和方法</li>
</ol>
</li>
<li>原型链：<ol>
<li>原型链是原型对象创建过程的历史记录，当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的<code>__proto__</code>隐式原型上查找，即它的构造函数的 prototype，如果还没有找到就会再在构造函数的 prototype 的<code>__proto__</code>中查找，这样一层一层向上查找就会形成一个链式结构</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/26/mianshiti/" data-id="clgx1lptb0000uktz74r7gc1c" data-title="面试题" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2023/04/25/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/04/26/mianshiti/">面试题</a>
          </li>
        
          <li>
            <a href="/2023/04/25/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>